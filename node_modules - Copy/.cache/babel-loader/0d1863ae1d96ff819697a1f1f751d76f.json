{"ast":null,"code":"\"use strict\";\n\nmodule.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {\n  var getDomain = Promise._getDomain;\n  var util = require(\"./util\");\n  var tryCatch = util.tryCatch;\n  function ReductionPromiseArray(promises, fn, initialValue, _each) {\n    this.constructor$(promises);\n    var domain = getDomain();\n    this._fn = domain === null ? fn : util.domainBind(domain, fn);\n    if (initialValue !== undefined) {\n      initialValue = Promise.resolve(initialValue);\n      initialValue._attachCancellationCallback(this);\n    }\n    this._initialValue = initialValue;\n    this._currentCancellable = null;\n    if (_each === INTERNAL) {\n      this._eachValues = Array(this._length);\n    } else if (_each === 0) {\n      this._eachValues = null;\n    } else {\n      this._eachValues = undefined;\n    }\n    this._promise._captureStackTrace();\n    this._init$(undefined, -5);\n  }\n  util.inherits(ReductionPromiseArray, PromiseArray);\n  ReductionPromiseArray.prototype._gotAccum = function (accum) {\n    if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {\n      this._eachValues.push(accum);\n    }\n  };\n  ReductionPromiseArray.prototype._eachComplete = function (value) {\n    if (this._eachValues !== null) {\n      this._eachValues.push(value);\n    }\n    return this._eachValues;\n  };\n  ReductionPromiseArray.prototype._init = function () {};\n  ReductionPromiseArray.prototype._resolveEmptyArray = function () {\n    this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);\n  };\n  ReductionPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n  };\n  ReductionPromiseArray.prototype._resolve = function (value) {\n    this._promise._resolveCallback(value);\n    this._values = null;\n  };\n  ReductionPromiseArray.prototype._resultCancelled = function (sender) {\n    if (sender === this._initialValue) return this._cancel();\n    if (this._isResolved()) return;\n    this._resultCancelled$();\n    if (this._currentCancellable instanceof Promise) {\n      this._currentCancellable.cancel();\n    }\n    if (this._initialValue instanceof Promise) {\n      this._initialValue.cancel();\n    }\n  };\n  ReductionPromiseArray.prototype._iterate = function (values) {\n    this._values = values;\n    var value;\n    var i;\n    var length = values.length;\n    if (this._initialValue !== undefined) {\n      value = this._initialValue;\n      i = 0;\n    } else {\n      value = Promise.resolve(values[0]);\n      i = 1;\n    }\n    this._currentCancellable = value;\n    if (!value.isRejected()) {\n      for (; i < length; ++i) {\n        var ctx = {\n          accum: null,\n          value: values[i],\n          index: i,\n          length: length,\n          array: this\n        };\n        value = value._then(gotAccum, undefined, undefined, ctx, undefined);\n      }\n    }\n    if (this._eachValues !== undefined) {\n      value = value._then(this._eachComplete, undefined, undefined, this, undefined);\n    }\n    value._then(completed, completed, undefined, value, this);\n  };\n  Promise.prototype.reduce = function (fn, initialValue) {\n    return reduce(this, fn, initialValue, null);\n  };\n  Promise.reduce = function (promises, fn, initialValue, _each) {\n    return reduce(promises, fn, initialValue, _each);\n  };\n  function completed(valueOrReason, array) {\n    if (this.isFulfilled()) {\n      array._resolve(valueOrReason);\n    } else {\n      array._reject(valueOrReason);\n    }\n  }\n  function reduce(promises, fn, initialValue, _each) {\n    if (typeof fn !== \"function\") {\n      return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n    return array.promise();\n  }\n  function gotAccum(accum) {\n    this.accum = accum;\n    this.array._gotAccum(accum);\n    var value = tryConvertToPromise(this.value, this.array._promise);\n    if (value instanceof Promise) {\n      this.array._currentCancellable = value;\n      return value._then(gotValue, undefined, undefined, this, undefined);\n    } else {\n      return gotValue.call(this, value);\n    }\n  }\n  function gotValue(value) {\n    var array = this.array;\n    var promise = array._promise;\n    var fn = tryCatch(array._fn);\n    promise._pushContext();\n    var ret;\n    if (array._eachValues !== undefined) {\n      ret = fn.call(promise._boundValue(), value, this.index, this.length);\n    } else {\n      ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);\n    }\n    if (ret instanceof Promise) {\n      array._currentCancellable = ret;\n    }\n    var promiseCreated = promise._popContext();\n    debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? \"Promise.each\" : \"Promise.reduce\", promise);\n    return ret;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}