{"ast":null,"code":"var _asyncToGenerator = require(\"C:\\\\Users\\\\dell2\\\\Desktop\\\\canjobs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\nvar _slicedToArray = require(\"C:\\\\Users\\\\dell2\\\\Desktop\\\\canjobs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _construct = require(\"C:\\\\Users\\\\dell2\\\\Desktop\\\\canjobs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/construct\");\nvar _objectWithoutProperties = require(\"C:\\\\Users\\\\dell2\\\\Desktop\\\\canjobs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectWithoutProperties\");\nvar _objectSpread = require(\"C:\\\\Users\\\\dell2\\\\Desktop\\\\canjobs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _defineProperty = require(\"C:\\\\Users\\\\dell2\\\\Desktop\\\\canjobs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\nvar _toConsumableArray = require(\"C:\\\\Users\\\\dell2\\\\Desktop\\\\canjobs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"C:\\\\Users\\\\dell2\\\\Desktop\\\\canjobs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\dell2\\\\Desktop\\\\canjobs\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * TinyMCE version 6.8.0 (2023-11-22)\n */\n\n(function (_mergeWith, _toolbarButtonEventOr) {\n  'use strict';\n\n  var getPrototypeOf$2 = Object.getPrototypeOf;\n  var hasProto = function hasProto(v, constructor, predicate) {\n    var _a;\n    if (predicate(v, constructor.prototype)) {\n      return true;\n    } else {\n      return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n    }\n  };\n  var typeOf = function typeOf(x) {\n    var t = typeof x;\n    if (x === null) {\n      return 'null';\n    } else if (t === 'object' && Array.isArray(x)) {\n      return 'array';\n    } else if (t === 'object' && hasProto(x, String, function (o, proto) {\n      return proto.isPrototypeOf(o);\n    })) {\n      return 'string';\n    } else {\n      return t;\n    }\n  };\n  var isType$1 = function isType$1(type) {\n    return function (value) {\n      return typeOf(value) === type;\n    };\n  };\n  var isSimpleType = function isSimpleType(type) {\n    return function (value) {\n      return typeof value === type;\n    };\n  };\n  var eq$1 = function eq$1(t) {\n    return function (a) {\n      return t === a;\n    };\n  };\n  var is$2 = function is$2(value, constructor) {\n    return isObject(value) && hasProto(value, constructor, function (o, proto) {\n      return getPrototypeOf$2(o) === proto;\n    });\n  };\n  var isString = isType$1('string');\n  var isObject = isType$1('object');\n  var isPlainObject = function isPlainObject(value) {\n    return is$2(value, Object);\n  };\n  var isArray = isType$1('array');\n  var isNull = eq$1(null);\n  var isBoolean = isSimpleType('boolean');\n  var isUndefined = eq$1(undefined);\n  var isNullable = function isNullable(a) {\n    return a === null || a === undefined;\n  };\n  var isNonNullable = function isNonNullable(a) {\n    return !isNullable(a);\n  };\n  var isFunction = isSimpleType('function');\n  var isNumber = isSimpleType('number');\n  var isArrayOf = function isArrayOf(value, pred) {\n    if (isArray(value)) {\n      for (var i = 0, len = value.length; i < len; ++i) {\n        if (!pred(value[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n  var noop = function noop() {};\n  var noarg = function noarg(f) {\n    return function () {\n      return f();\n    };\n  };\n  var compose = function compose(fa, fb) {\n    return function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return fa(fb.apply(null, args));\n    };\n  };\n  var compose1 = function compose1(fbc, fab) {\n    return function (a) {\n      return fbc(fab(a));\n    };\n  };\n  var constant$1 = function constant$1(value) {\n    return function () {\n      return value;\n    };\n  };\n  var identity = function identity(x) {\n    return x;\n  };\n  var tripleEquals = function tripleEquals(a, b) {\n    return a === b;\n  };\n  function curry(fn) {\n    for (var _len4 = arguments.length, initialArgs = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      initialArgs[_key4 - 1] = arguments[_key4];\n    }\n    return function () {\n      for (var _len5 = arguments.length, restArgs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        restArgs[_key5] = arguments[_key5];\n      }\n      var all = initialArgs.concat(restArgs);\n      return fn.apply(null, all);\n    };\n  }\n  var not = function not(f) {\n    return function (t) {\n      return !f(t);\n    };\n  };\n  var die = function die(msg) {\n    return function () {\n      throw new Error(msg);\n    };\n  };\n  var apply$1 = function apply$1(f) {\n    return f();\n  };\n  var never = constant$1(false);\n  var always = constant$1(true);\n  var Optional = /*#__PURE__*/function () {\n    function Optional(tag, value) {\n      _classCallCheck(this, Optional);\n      this.tag = tag;\n      this.value = value;\n    }\n    _createClass(Optional, [{\n      key: \"fold\",\n      value: function fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n    }, {\n      key: \"isSome\",\n      value: function isSome() {\n        return this.tag;\n      }\n    }, {\n      key: \"isNone\",\n      value: function isNone() {\n        return !this.tag;\n      }\n    }, {\n      key: \"map\",\n      value: function map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n    }, {\n      key: \"bind\",\n      value: function bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n    }, {\n      key: \"exists\",\n      value: function exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n    }, {\n      key: \"forall\",\n      value: function forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n    }, {\n      key: \"filter\",\n      value: function filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n    }, {\n      key: \"getOr\",\n      value: function getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n    }, {\n      key: \"or\",\n      value: function or(replacement) {\n        return this.tag ? this : replacement;\n      }\n    }, {\n      key: \"getOrThunk\",\n      value: function getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n    }, {\n      key: \"orThunk\",\n      value: function orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n    }, {\n      key: \"getOrDie\",\n      value: function getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n    }, {\n      key: \"getOrNull\",\n      value: function getOrNull() {\n        return this.tag ? this.value : null;\n      }\n    }, {\n      key: \"getOrUndefined\",\n      value: function getOrUndefined() {\n        return this.value;\n      }\n    }, {\n      key: \"each\",\n      value: function each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n    }, {\n      key: \"toArray\",\n      value: function toArray() {\n        return this.tag ? [this.value] : [];\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        return this.tag ? \"some(\".concat(this.value, \")\") : 'none()';\n      }\n    }], [{\n      key: \"some\",\n      value: function some(value) {\n        return new Optional(true, value);\n      }\n    }, {\n      key: \"none\",\n      value: function none() {\n        return Optional.singletonNone;\n      }\n    }, {\n      key: \"from\",\n      value: function from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n    }]);\n    return Optional;\n  }();\n  Optional.singletonNone = new Optional(false);\n  var nativeSlice = Array.prototype.slice;\n  var nativeIndexOf = Array.prototype.indexOf;\n  var nativePush = Array.prototype.push;\n  var rawIndexOf = function rawIndexOf(ts, t) {\n    return nativeIndexOf.call(ts, t);\n  };\n  var indexOf = function indexOf(xs, x) {\n    var r = rawIndexOf(xs, x);\n    return r === -1 ? Optional.none() : Optional.some(r);\n  };\n  var contains$2 = function contains$2(xs, x) {\n    return rawIndexOf(xs, x) > -1;\n  };\n  var exists = function exists(xs, pred) {\n    for (var i = 0, len = xs.length; i < len; i++) {\n      var x = xs[i];\n      if (pred(x, i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  var range$2 = function range$2(num, f) {\n    var r = [];\n    for (var i = 0; i < num; i++) {\n      r.push(f(i));\n    }\n    return r;\n  };\n  var chunk$1 = function chunk$1(array, size) {\n    var r = [];\n    for (var i = 0; i < array.length; i += size) {\n      var s = nativeSlice.call(array, i, i + size);\n      r.push(s);\n    }\n    return r;\n  };\n  var map$2 = function map$2(xs, f) {\n    var len = xs.length;\n    var r = new Array(len);\n    for (var i = 0; i < len; i++) {\n      var x = xs[i];\n      r[i] = f(x, i);\n    }\n    return r;\n  };\n  var each$1 = function each$1(xs, f) {\n    for (var i = 0, len = xs.length; i < len; i++) {\n      var x = xs[i];\n      f(x, i);\n    }\n  };\n  var eachr = function eachr(xs, f) {\n    for (var i = xs.length - 1; i >= 0; i--) {\n      var x = xs[i];\n      f(x, i);\n    }\n  };\n  var partition$3 = function partition$3(xs, pred) {\n    var pass = [];\n    var fail = [];\n    for (var i = 0, len = xs.length; i < len; i++) {\n      var x = xs[i];\n      var arr = pred(x, i) ? pass : fail;\n      arr.push(x);\n    }\n    return {\n      pass: pass,\n      fail: fail\n    };\n  };\n  var filter$2 = function filter$2(xs, pred) {\n    var r = [];\n    for (var i = 0, len = xs.length; i < len; i++) {\n      var x = xs[i];\n      if (pred(x, i)) {\n        r.push(x);\n      }\n    }\n    return r;\n  };\n  var foldr = function foldr(xs, f, acc) {\n    eachr(xs, function (x, i) {\n      acc = f(acc, x, i);\n    });\n    return acc;\n  };\n  var foldl = function foldl(xs, f, acc) {\n    each$1(xs, function (x, i) {\n      acc = f(acc, x, i);\n    });\n    return acc;\n  };\n  var findUntil = function findUntil(xs, pred, until) {\n    for (var i = 0, len = xs.length; i < len; i++) {\n      var x = xs[i];\n      if (pred(x, i)) {\n        return Optional.some(x);\n      } else if (until(x, i)) {\n        break;\n      }\n    }\n    return Optional.none();\n  };\n  var find$5 = function find$5(xs, pred) {\n    return findUntil(xs, pred, never);\n  };\n  var findIndex$1 = function findIndex$1(xs, pred) {\n    for (var i = 0, len = xs.length; i < len; i++) {\n      var x = xs[i];\n      if (pred(x, i)) {\n        return Optional.some(i);\n      }\n    }\n    return Optional.none();\n  };\n  var flatten = function flatten(xs) {\n    var r = [];\n    for (var i = 0, len = xs.length; i < len; ++i) {\n      if (!isArray(xs[i])) {\n        throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n      }\n      nativePush.apply(r, xs[i]);\n    }\n    return r;\n  };\n  var bind$3 = function bind$3(xs, f) {\n    return flatten(map$2(xs, f));\n  };\n  var forall = function forall(xs, pred) {\n    for (var i = 0, len = xs.length; i < len; ++i) {\n      var x = xs[i];\n      if (pred(x, i) !== true) {\n        return false;\n      }\n    }\n    return true;\n  };\n  var reverse = function reverse(xs) {\n    var r = nativeSlice.call(xs, 0);\n    r.reverse();\n    return r;\n  };\n  var difference = function difference(a1, a2) {\n    return filter$2(a1, function (x) {\n      return !contains$2(a2, x);\n    });\n  };\n  var mapToObject = function mapToObject(xs, f) {\n    var r = {};\n    for (var i = 0, len = xs.length; i < len; i++) {\n      var x = xs[i];\n      r[String(x)] = f(x, i);\n    }\n    return r;\n  };\n  var pure$2 = function pure$2(x) {\n    return [x];\n  };\n  var sort = function sort(xs, comparator) {\n    var copy = nativeSlice.call(xs, 0);\n    copy.sort(comparator);\n    return copy;\n  };\n  var get$h = function get$h(xs, i) {\n    return i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n  };\n  var head = function head(xs) {\n    return get$h(xs, 0);\n  };\n  var last$1 = function last$1(xs) {\n    return get$h(xs, xs.length - 1);\n  };\n  var from = isFunction(Array.from) ? Array.from : function (x) {\n    return nativeSlice.call(x);\n  };\n  var findMap = function findMap(arr, f) {\n    for (var i = 0; i < arr.length; i++) {\n      var _r = f(arr[i], i);\n      if (_r.isSome()) {\n        return _r;\n      }\n    }\n    return Optional.none();\n  };\n  var keys = Object.keys;\n  var hasOwnProperty = Object.hasOwnProperty;\n  var each = function each(obj, f) {\n    var props = keys(obj);\n    for (var k = 0, len = props.length; k < len; k++) {\n      var i = props[k];\n      var x = obj[i];\n      f(x, i);\n    }\n  };\n  var map$1 = function map$1(obj, f) {\n    return tupleMap(obj, function (x, i) {\n      return {\n        k: i,\n        v: f(x, i)\n      };\n    });\n  };\n  var tupleMap = function tupleMap(obj, f) {\n    var r = {};\n    each(obj, function (x, i) {\n      var tuple = f(x, i);\n      r[tuple.k] = tuple.v;\n    });\n    return r;\n  };\n  var objAcc = function objAcc(r) {\n    return function (x, i) {\n      r[i] = x;\n    };\n  };\n  var internalFilter = function internalFilter(obj, pred, onTrue, onFalse) {\n    each(obj, function (x, i) {\n      (pred(x, i) ? onTrue : onFalse)(x, i);\n    });\n  };\n  var bifilter = function bifilter(obj, pred) {\n    var t = {};\n    var f = {};\n    internalFilter(obj, pred, objAcc(t), objAcc(f));\n    return {\n      t: t,\n      f: f\n    };\n  };\n  var filter$1 = function filter$1(obj, pred) {\n    var t = {};\n    internalFilter(obj, pred, objAcc(t), noop);\n    return t;\n  };\n  var mapToArray = function mapToArray(obj, f) {\n    var r = [];\n    each(obj, function (value, name) {\n      r.push(f(value, name));\n    });\n    return r;\n  };\n  var find$4 = function find$4(obj, pred) {\n    var props = keys(obj);\n    for (var k = 0, len = props.length; k < len; k++) {\n      var i = props[k];\n      var x = obj[i];\n      if (pred(x, i, obj)) {\n        return Optional.some(x);\n      }\n    }\n    return Optional.none();\n  };\n  var values = function values(obj) {\n    return mapToArray(obj, identity);\n  };\n  var get$g = function get$g(obj, key) {\n    return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n  };\n  var has$2 = function has$2(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n  var hasNonNullableKey = function hasNonNullableKey(obj, key) {\n    return has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n  };\n  var is$1 = function is$1(lhs, rhs) {\n    var comparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : tripleEquals;\n    return lhs.exists(function (left) {\n      return comparator(left, rhs);\n    });\n  };\n  var equals = function equals(lhs, rhs) {\n    var comparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : tripleEquals;\n    return lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n  };\n  var cat = function cat(arr) {\n    var r = [];\n    var push = function push(x) {\n      r.push(x);\n    };\n    for (var i = 0; i < arr.length; i++) {\n      arr[i].each(push);\n    }\n    return r;\n  };\n  var sequence = function sequence(arr) {\n    var r = [];\n    for (var i = 0; i < arr.length; i++) {\n      var x = arr[i];\n      if (x.isSome()) {\n        r.push(x.getOrDie());\n      } else {\n        return Optional.none();\n      }\n    }\n    return Optional.some(r);\n  };\n  var lift2 = function lift2(oa, ob, f) {\n    return oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n  };\n  var lift3 = function lift3(oa, ob, oc, f) {\n    return oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n  };\n  var mapFrom = function mapFrom(a, f) {\n    return a !== undefined && a !== null ? Optional.some(f(a)) : Optional.none();\n  };\n  var someIf = function someIf(b, a) {\n    return b ? Optional.some(a) : Optional.none();\n  };\n  var addToEnd = function addToEnd(str, suffix) {\n    return str + suffix;\n  };\n  var removeFromStart = function removeFromStart(str, numChars) {\n    return str.substring(numChars);\n  };\n  var checkRange = function checkRange(str, substr, start) {\n    return substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n  };\n  var removeLeading = function removeLeading(str, prefix) {\n    return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n  };\n  var ensureTrailing = function ensureTrailing(str, suffix) {\n    return endsWith(str, suffix) ? str : addToEnd(str, suffix);\n  };\n  var contains$1 = function contains$1(str, substr) {\n    var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var end = arguments.length > 3 ? arguments[3] : undefined;\n    var idx = str.indexOf(substr, start);\n    if (idx !== -1) {\n      return isUndefined(end) ? true : idx + substr.length <= end;\n    } else {\n      return false;\n    }\n  };\n  var startsWith = function startsWith(str, prefix) {\n    return checkRange(str, prefix, 0);\n  };\n  var endsWith = function endsWith(str, suffix) {\n    return checkRange(str, suffix, str.length - suffix.length);\n  };\n  var blank = function blank(r) {\n    return function (s) {\n      return s.replace(r, '');\n    };\n  };\n  var trim$1 = blank(/^\\s+|\\s+$/g);\n  var isNotEmpty = function isNotEmpty(s) {\n    return s.length > 0;\n  };\n  var isEmpty = function isEmpty(s) {\n    return !isNotEmpty(s);\n  };\n  var isSupported$1 = function isSupported$1(dom) {\n    return dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n  };\n  var fromHtml$2 = function fromHtml$2(html, scope) {\n    var doc = scope || document;\n    var div = doc.createElement('div');\n    div.innerHTML = html;\n    if (!div.hasChildNodes() || div.childNodes.length > 1) {\n      var message = 'HTML does not have a single root node';\n      console.error(message, html);\n      throw new Error(message);\n    }\n    return fromDom(div.childNodes[0]);\n  };\n  var fromTag = function fromTag(tag, scope) {\n    var doc = scope || document;\n    var node = doc.createElement(tag);\n    return fromDom(node);\n  };\n  var fromText = function fromText(text, scope) {\n    var doc = scope || document;\n    var node = doc.createTextNode(text);\n    return fromDom(node);\n  };\n  var fromDom = function fromDom(node) {\n    if (node === null || node === undefined) {\n      throw new Error('Node cannot be null or undefined');\n    }\n    return {\n      dom: node\n    };\n  };\n  var fromPoint = function fromPoint(docElm, x, y) {\n    return Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\n  };\n  var SugarElement = {\n    fromHtml: fromHtml$2,\n    fromTag: fromTag,\n    fromText: fromText,\n    fromDom: fromDom,\n    fromPoint: fromPoint\n  };\n  var Global = typeof window !== 'undefined' ? window : Function('return this;')();\n  var path$1 = function path$1(parts, scope) {\n    var o = scope !== undefined && scope !== null ? scope : Global;\n    for (var i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n      o = o[parts[i]];\n    }\n    return o;\n  };\n  var resolve = function resolve(p, scope) {\n    var parts = p.split('.');\n    return path$1(parts, scope);\n  };\n  var unsafe = function unsafe(name, scope) {\n    return resolve(name, scope);\n  };\n  var getOrDie$1 = function getOrDie$1(name, scope) {\n    var actual = unsafe(name, scope);\n    if (actual === undefined || actual === null) {\n      throw new Error(name + ' not available on this browser');\n    }\n    return actual;\n  };\n  var getPrototypeOf$1 = Object.getPrototypeOf;\n  var sandHTMLElement = function sandHTMLElement(scope) {\n    return getOrDie$1('HTMLElement', scope);\n  };\n  var isPrototypeOf = function isPrototypeOf(x) {\n    var scope = resolve('ownerDocument.defaultView', x);\n    return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf$1(x).constructor.name));\n  };\n  var DOCUMENT = 9;\n  var DOCUMENT_FRAGMENT = 11;\n  var ELEMENT = 1;\n  var TEXT = 3;\n  var name$3 = function name$3(element) {\n    var r = element.dom.nodeName;\n    return r.toLowerCase();\n  };\n  var type$1 = function type$1(element) {\n    return element.dom.nodeType;\n  };\n  var isType = function isType(t) {\n    return function (element) {\n      return type$1(element) === t;\n    };\n  };\n  var isHTMLElement = function isHTMLElement(element) {\n    return isElement$1(element) && isPrototypeOf(element.dom);\n  };\n  var isElement$1 = isType(ELEMENT);\n  var isText = isType(TEXT);\n  var isDocument = isType(DOCUMENT);\n  var isDocumentFragment = isType(DOCUMENT_FRAGMENT);\n  var isTag = function isTag(tag) {\n    return function (e) {\n      return isElement$1(e) && name$3(e) === tag;\n    };\n  };\n  var is = function is(element, selector) {\n    var dom = element.dom;\n    if (dom.nodeType !== ELEMENT) {\n      return false;\n    } else {\n      var elem = dom;\n      if (elem.matches !== undefined) {\n        return elem.matches(selector);\n      } else if (elem.msMatchesSelector !== undefined) {\n        return elem.msMatchesSelector(selector);\n      } else if (elem.webkitMatchesSelector !== undefined) {\n        return elem.webkitMatchesSelector(selector);\n      } else if (elem.mozMatchesSelector !== undefined) {\n        return elem.mozMatchesSelector(selector);\n      } else {\n        throw new Error('Browser lacks native selectors');\n      }\n    }\n  };\n  var bypassSelector = function bypassSelector(dom) {\n    return dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n  };\n  var all$3 = function all$3(selector, scope) {\n    var base = scope === undefined ? document : scope.dom;\n    return bypassSelector(base) ? [] : map$2(base.querySelectorAll(selector), SugarElement.fromDom);\n  };\n  var one = function one(selector, scope) {\n    var base = scope === undefined ? document : scope.dom;\n    return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n  };\n  var eq = function eq(e1, e2) {\n    return e1.dom === e2.dom;\n  };\n  var contains = function contains(e1, e2) {\n    var d1 = e1.dom;\n    var d2 = e2.dom;\n    return d1 === d2 ? false : d1.contains(d2);\n  };\n  var owner$4 = function owner$4(element) {\n    return SugarElement.fromDom(element.dom.ownerDocument);\n  };\n  var documentOrOwner = function documentOrOwner(dos) {\n    return isDocument(dos) ? dos : owner$4(dos);\n  };\n  var documentElement = function documentElement(element) {\n    return SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n  };\n  var defaultView = function defaultView(element) {\n    return SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n  };\n  var parent = function parent(element) {\n    return Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n  };\n  var parentNode = function parentNode(element) {\n    return parent(element);\n  };\n  var parentElement = function parentElement(element) {\n    return Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n  };\n  var parents = function parents(element, isRoot) {\n    var stop = isFunction(isRoot) ? isRoot : never;\n    var dom = element.dom;\n    var ret = [];\n    while (dom.parentNode !== null && dom.parentNode !== undefined) {\n      var rawParent = dom.parentNode;\n      var p = SugarElement.fromDom(rawParent);\n      ret.push(p);\n      if (stop(p) === true) {\n        break;\n      } else {\n        dom = rawParent;\n      }\n    }\n    return ret;\n  };\n  var offsetParent = function offsetParent(element) {\n    return Optional.from(element.dom.offsetParent).map(SugarElement.fromDom);\n  };\n  var nextSibling = function nextSibling(element) {\n    return Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n  };\n  var children = function children(element) {\n    return map$2(element.dom.childNodes, SugarElement.fromDom);\n  };\n  var child$2 = function child$2(element, index) {\n    var cs = element.dom.childNodes;\n    return Optional.from(cs[index]).map(SugarElement.fromDom);\n  };\n  var firstChild = function firstChild(element) {\n    return child$2(element, 0);\n  };\n  var spot = function spot(element, offset) {\n    return {\n      element: element,\n      offset: offset\n    };\n  };\n  var leaf = function leaf(element, offset) {\n    var cs = children(element);\n    return cs.length > 0 && offset < cs.length ? spot(cs[offset], 0) : spot(element, offset);\n  };\n  var isShadowRoot = function isShadowRoot(dos) {\n    return isDocumentFragment(dos) && isNonNullable(dos.dom.host);\n  };\n  var supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n  var isSupported = constant$1(supported);\n  var getRootNode = supported ? function (e) {\n    return SugarElement.fromDom(e.dom.getRootNode());\n  } : documentOrOwner;\n  var getContentContainer = function getContentContainer(dos) {\n    return isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);\n  };\n  var isInShadowRoot = function isInShadowRoot(e) {\n    return getShadowRoot(e).isSome();\n  };\n  var getShadowRoot = function getShadowRoot(e) {\n    var r = getRootNode(e);\n    return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n  };\n  var getShadowHost = function getShadowHost(e) {\n    return SugarElement.fromDom(e.dom.host);\n  };\n  var getOriginalEventTarget = function getOriginalEventTarget(event) {\n    if (isSupported() && isNonNullable(event.target)) {\n      var el = SugarElement.fromDom(event.target);\n      if (isElement$1(el) && isOpenShadowHost(el)) {\n        if (event.composed && event.composedPath) {\n          var composedPath = event.composedPath();\n          if (composedPath) {\n            return head(composedPath);\n          }\n        }\n      }\n    }\n    return Optional.from(event.target);\n  };\n  var isOpenShadowHost = function isOpenShadowHost(element) {\n    return isNonNullable(element.dom.shadowRoot);\n  };\n  var inBody = function inBody(element) {\n    var dom = isText(element) ? element.dom.parentNode : element.dom;\n    if (dom === undefined || dom === null || dom.ownerDocument === null) {\n      return false;\n    }\n    var doc = dom.ownerDocument;\n    return getShadowRoot(SugarElement.fromDom(dom)).fold(function () {\n      return doc.body.contains(dom);\n    }, compose1(inBody, getShadowHost));\n  };\n  var body = function body() {\n    return getBody(SugarElement.fromDom(document));\n  };\n  var getBody = function getBody(doc) {\n    var b = doc.dom.body;\n    if (b === null || b === undefined) {\n      throw new Error('Body is not available yet');\n    }\n    return SugarElement.fromDom(b);\n  };\n  var rawSet = function rawSet(dom, key, value) {\n    if (isString(value) || isBoolean(value) || isNumber(value)) {\n      dom.setAttribute(key, value + '');\n    } else {\n      console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n      throw new Error('Attribute value was not simple');\n    }\n  };\n  var set$9 = function set$9(element, key, value) {\n    rawSet(element.dom, key, value);\n  };\n  var setAll$1 = function setAll$1(element, attrs) {\n    var dom = element.dom;\n    each(attrs, function (v, k) {\n      rawSet(dom, k, v);\n    });\n  };\n  var get$f = function get$f(element, key) {\n    var v = element.dom.getAttribute(key);\n    return v === null ? undefined : v;\n  };\n  var getOpt = function getOpt(element, key) {\n    return Optional.from(get$f(element, key));\n  };\n  var has$1 = function has$1(element, key) {\n    var dom = element.dom;\n    return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n  };\n  var remove$7 = function remove$7(element, key) {\n    element.dom.removeAttribute(key);\n  };\n  var clone$2 = function clone$2(element) {\n    return foldl(element.dom.attributes, function (acc, attr) {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n  };\n  var internalSet = function internalSet(dom, property, value) {\n    if (!isString(value)) {\n      console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n      throw new Error('CSS value must be a string: ' + value);\n    }\n    if (isSupported$1(dom)) {\n      dom.style.setProperty(property, value);\n    }\n  };\n  var internalRemove = function internalRemove(dom, property) {\n    if (isSupported$1(dom)) {\n      dom.style.removeProperty(property);\n    }\n  };\n  var set$8 = function set$8(element, property, value) {\n    var dom = element.dom;\n    internalSet(dom, property, value);\n  };\n  var setAll = function setAll(element, css) {\n    var dom = element.dom;\n    each(css, function (v, k) {\n      internalSet(dom, k, v);\n    });\n  };\n  var setOptions = function setOptions(element, css) {\n    var dom = element.dom;\n    each(css, function (v, k) {\n      v.fold(function () {\n        internalRemove(dom, k);\n      }, function (value) {\n        internalSet(dom, k, value);\n      });\n    });\n  };\n  var get$e = function get$e(element, property) {\n    var dom = element.dom;\n    var styles = window.getComputedStyle(dom);\n    var r = styles.getPropertyValue(property);\n    return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n  };\n  var getUnsafeProperty = function getUnsafeProperty(dom, property) {\n    return isSupported$1(dom) ? dom.style.getPropertyValue(property) : '';\n  };\n  var getRaw = function getRaw(element, property) {\n    var dom = element.dom;\n    var raw = getUnsafeProperty(dom, property);\n    return Optional.from(raw).filter(function (r) {\n      return r.length > 0;\n    });\n  };\n  var getAllRaw = function getAllRaw(element) {\n    var css = {};\n    var dom = element.dom;\n    if (isSupported$1(dom)) {\n      for (var i = 0; i < dom.style.length; i++) {\n        var ruleName = dom.style.item(i);\n        css[ruleName] = dom.style[ruleName];\n      }\n    }\n    return css;\n  };\n  var isValidValue$1 = function isValidValue$1(tag, property, value) {\n    var element = SugarElement.fromTag(tag);\n    set$8(element, property, value);\n    var style = getRaw(element, property);\n    return style.isSome();\n  };\n  var remove$6 = function remove$6(element, property) {\n    var dom = element.dom;\n    internalRemove(dom, property);\n    if (is$1(getOpt(element, 'style').map(trim$1), '')) {\n      remove$7(element, 'style');\n    }\n  };\n  var reflow = function reflow(e) {\n    return e.dom.offsetWidth;\n  };\n  var Dimension = function Dimension(name, getOffset) {\n    var set = function set(element, h) {\n      if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n        throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n      }\n      var dom = element.dom;\n      if (isSupported$1(dom)) {\n        dom.style[name] = h + 'px';\n      }\n    };\n    var get = function get(element) {\n      var r = getOffset(element);\n      if (r <= 0 || r === null) {\n        var css = get$e(element, name);\n        return parseFloat(css) || 0;\n      }\n      return r;\n    };\n    var getOuter = get;\n    var aggregate = function aggregate(element, properties) {\n      return foldl(properties, function (acc, property) {\n        var val = get$e(element, property);\n        var value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n    };\n    var max = function max(element, value, properties) {\n      var cumulativeInclusions = aggregate(element, properties);\n      var absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n      return absoluteMax;\n    };\n    return {\n      set: set,\n      get: get,\n      getOuter: getOuter,\n      aggregate: aggregate,\n      max: max\n    };\n  };\n  var api$2 = Dimension('height', function (element) {\n    var dom = element.dom;\n    return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n  });\n  var get$d = function get$d(element) {\n    return api$2.get(element);\n  };\n  var getOuter$2 = function getOuter$2(element) {\n    return api$2.getOuter(element);\n  };\n  var setMax$1 = function setMax$1(element, value) {\n    var inclusions = ['margin-top', 'border-top-width', 'padding-top', 'padding-bottom', 'border-bottom-width', 'margin-bottom'];\n    var absMax = api$2.max(element, value, inclusions);\n    set$8(element, 'max-height', absMax + 'px');\n  };\n  var r$1 = function r$1(left, top) {\n    var translate = function translate(x, y) {\n      return r$1(left + x, top + y);\n    };\n    return {\n      left: left,\n      top: top,\n      translate: translate\n    };\n  };\n  var SugarPosition = r$1;\n  var boxPosition = function boxPosition(dom) {\n    var box = dom.getBoundingClientRect();\n    return SugarPosition(box.left, box.top);\n  };\n  var firstDefinedOrZero = function firstDefinedOrZero(a, b) {\n    if (a !== undefined) {\n      return a;\n    } else {\n      return b !== undefined ? b : 0;\n    }\n  };\n  var absolute$3 = function absolute$3(element) {\n    var doc = element.dom.ownerDocument;\n    var body = doc.body;\n    var win = doc.defaultView;\n    var html = doc.documentElement;\n    if (body === element.dom) {\n      return SugarPosition(body.offsetLeft, body.offsetTop);\n    }\n    var scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n    var scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n    var clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n    var clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n    return viewport$1(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n  };\n  var viewport$1 = function viewport$1(element) {\n    var dom = element.dom;\n    var doc = dom.ownerDocument;\n    var body = doc.body;\n    if (body === dom) {\n      return SugarPosition(body.offsetLeft, body.offsetTop);\n    }\n    if (!inBody(element)) {\n      return SugarPosition(0, 0);\n    }\n    return boxPosition(dom);\n  };\n  var api$1 = Dimension('width', function (element) {\n    return element.dom.offsetWidth;\n  });\n  var set$7 = function set$7(element, h) {\n    return api$1.set(element, h);\n  };\n  var get$c = function get$c(element) {\n    return api$1.get(element);\n  };\n  var getOuter$1 = function getOuter$1(element) {\n    return api$1.getOuter(element);\n  };\n  var setMax = function setMax(element, value) {\n    var inclusions = ['margin-left', 'border-left-width', 'padding-left', 'padding-right', 'border-right-width', 'margin-right'];\n    var absMax = api$1.max(element, value, inclusions);\n    set$8(element, 'max-width', absMax + 'px');\n  };\n  var cached = function cached(f) {\n    var called = false;\n    var r;\n    return function () {\n      if (!called) {\n        called = true;\n        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          args[_key6] = arguments[_key6];\n        }\n        r = f.apply(null, args);\n      }\n      return r;\n    };\n  };\n  var DeviceType = function DeviceType(os, browser, userAgent, mediaMatch) {\n    var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n    var isiPhone = os.isiOS() && !isiPad;\n    var isMobile = os.isiOS() || os.isAndroid();\n    var isTouch = isMobile || mediaMatch('(pointer:coarse)');\n    var isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n    var isPhone = isiPhone || isMobile && !isTablet;\n    var iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n    var isDesktop = !isPhone && !isTablet && !iOSwebview;\n    return {\n      isiPad: constant$1(isiPad),\n      isiPhone: constant$1(isiPhone),\n      isTablet: constant$1(isTablet),\n      isPhone: constant$1(isPhone),\n      isTouch: constant$1(isTouch),\n      isAndroid: os.isAndroid,\n      isiOS: os.isiOS,\n      isWebView: constant$1(iOSwebview),\n      isDesktop: constant$1(isDesktop)\n    };\n  };\n  var firstMatch = function firstMatch(regexes, s) {\n    for (var i = 0; i < regexes.length; i++) {\n      var x = regexes[i];\n      if (x.test(s)) {\n        return x;\n      }\n    }\n    return undefined;\n  };\n  var find$3 = function find$3(regexes, agent) {\n    var r = firstMatch(regexes, agent);\n    if (!r) {\n      return {\n        major: 0,\n        minor: 0\n      };\n    }\n    var group = function group(i) {\n      return Number(agent.replace(r, '$' + i));\n    };\n    return nu$d(group(1), group(2));\n  };\n  var detect$5 = function detect$5(versionRegexes, agent) {\n    var cleanedAgent = String(agent).toLowerCase();\n    if (versionRegexes.length === 0) {\n      return unknown$3();\n    }\n    return find$3(versionRegexes, cleanedAgent);\n  };\n  var unknown$3 = function unknown$3() {\n    return nu$d(0, 0);\n  };\n  var nu$d = function nu$d(major, minor) {\n    return {\n      major: major,\n      minor: minor\n    };\n  };\n  var Version = {\n    nu: nu$d,\n    detect: detect$5,\n    unknown: unknown$3\n  };\n  var detectBrowser$1 = function detectBrowser$1(browsers, userAgentData) {\n    return findMap(userAgentData.brands, function (uaBrand) {\n      var lcBrand = uaBrand.brand.toLowerCase();\n      return find$5(browsers, function (browser) {\n        var _a;\n        return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n      }).map(function (info) {\n        return {\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        };\n      });\n    });\n  };\n  var detect$4 = function detect$4(candidates, userAgent) {\n    var agent = String(userAgent).toLowerCase();\n    return find$5(candidates, function (candidate) {\n      return candidate.search(agent);\n    });\n  };\n  var detectBrowser = function detectBrowser(browsers, userAgent) {\n    return detect$4(browsers, userAgent).map(function (browser) {\n      var version = Version.detect(browser.versionRegexes, userAgent);\n      return {\n        current: browser.name,\n        version: version\n      };\n    });\n  };\n  var detectOs = function detectOs(oses, userAgent) {\n    return detect$4(oses, userAgent).map(function (os) {\n      var version = Version.detect(os.versionRegexes, userAgent);\n      return {\n        current: os.name,\n        version: version\n      };\n    });\n  };\n  var normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n  var checkContains = function checkContains(target) {\n    return function (uastring) {\n      return contains$1(uastring, target);\n    };\n  };\n  var browsers = [{\n    name: 'Edge',\n    versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n    search: function search(uastring) {\n      return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n    }\n  }, {\n    name: 'Chromium',\n    brand: 'Chromium',\n    versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/, normalVersionRegex],\n    search: function search(uastring) {\n      return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n    }\n  }, {\n    name: 'IE',\n    versionRegexes: [/.*?msie\\ ?([0-9]+)\\.([0-9]+).*/, /.*?rv:([0-9]+)\\.([0-9]+).*/],\n    search: function search(uastring) {\n      return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n    }\n  }, {\n    name: 'Opera',\n    versionRegexes: [normalVersionRegex, /.*?opera\\/([0-9]+)\\.([0-9]+).*/],\n    search: checkContains('opera')\n  }, {\n    name: 'Firefox',\n    versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n    search: checkContains('firefox')\n  }, {\n    name: 'Safari',\n    versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],\n    search: function search(uastring) {\n      return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n    }\n  }];\n  var oses = [{\n    name: 'Windows',\n    search: checkContains('win'),\n    versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n  }, {\n    name: 'iOS',\n    search: function search(uastring) {\n      return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n    },\n    versionRegexes: [/.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]\n  }, {\n    name: 'Android',\n    search: checkContains('android'),\n    versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n  }, {\n    name: 'macOS',\n    search: checkContains('mac os x'),\n    versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n  }, {\n    name: 'Linux',\n    search: checkContains('linux'),\n    versionRegexes: []\n  }, {\n    name: 'Solaris',\n    search: checkContains('sunos'),\n    versionRegexes: []\n  }, {\n    name: 'FreeBSD',\n    search: checkContains('freebsd'),\n    versionRegexes: []\n  }, {\n    name: 'ChromeOS',\n    search: checkContains('cros'),\n    versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n  }];\n  var PlatformInfo = {\n    browsers: constant$1(browsers),\n    oses: constant$1(oses)\n  };\n  var edge = 'Edge';\n  var chromium = 'Chromium';\n  var ie = 'IE';\n  var opera = 'Opera';\n  var firefox = 'Firefox';\n  var safari = 'Safari';\n  var unknown$2 = function unknown$2() {\n    return nu$c({\n      current: undefined,\n      version: Version.unknown()\n    });\n  };\n  var nu$c = function nu$c(info) {\n    var current = info.current;\n    var version = info.version;\n    var isBrowser = function isBrowser(name) {\n      return function () {\n        return current === name;\n      };\n    };\n    return {\n      current: current,\n      version: version,\n      isEdge: isBrowser(edge),\n      isChromium: isBrowser(chromium),\n      isIE: isBrowser(ie),\n      isOpera: isBrowser(opera),\n      isFirefox: isBrowser(firefox),\n      isSafari: isBrowser(safari)\n    };\n  };\n  var Browser = {\n    unknown: unknown$2,\n    nu: nu$c,\n    edge: constant$1(edge),\n    chromium: constant$1(chromium),\n    ie: constant$1(ie),\n    opera: constant$1(opera),\n    firefox: constant$1(firefox),\n    safari: constant$1(safari)\n  };\n  var windows = 'Windows';\n  var ios = 'iOS';\n  var android = 'Android';\n  var linux = 'Linux';\n  var macos = 'macOS';\n  var solaris = 'Solaris';\n  var freebsd = 'FreeBSD';\n  var chromeos = 'ChromeOS';\n  var unknown$1 = function unknown$1() {\n    return nu$b({\n      current: undefined,\n      version: Version.unknown()\n    });\n  };\n  var nu$b = function nu$b(info) {\n    var current = info.current;\n    var version = info.version;\n    var isOS = function isOS(name) {\n      return function () {\n        return current === name;\n      };\n    };\n    return {\n      current: current,\n      version: version,\n      isWindows: isOS(windows),\n      isiOS: isOS(ios),\n      isAndroid: isOS(android),\n      isMacOS: isOS(macos),\n      isLinux: isOS(linux),\n      isSolaris: isOS(solaris),\n      isFreeBSD: isOS(freebsd),\n      isChromeOS: isOS(chromeos)\n    };\n  };\n  var OperatingSystem = {\n    unknown: unknown$1,\n    nu: nu$b,\n    windows: constant$1(windows),\n    ios: constant$1(ios),\n    android: constant$1(android),\n    linux: constant$1(linux),\n    macos: constant$1(macos),\n    solaris: constant$1(solaris),\n    freebsd: constant$1(freebsd),\n    chromeos: constant$1(chromeos)\n  };\n  var detect$3 = function detect$3(userAgent, userAgentDataOpt, mediaMatch) {\n    var browsers = PlatformInfo.browsers();\n    var oses = PlatformInfo.oses();\n    var browser = userAgentDataOpt.bind(function (userAgentData) {\n      return detectBrowser$1(browsers, userAgentData);\n    }).orThunk(function () {\n      return detectBrowser(browsers, userAgent);\n    }).fold(Browser.unknown, Browser.nu);\n    var os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n    var deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n    return {\n      browser: browser,\n      os: os,\n      deviceType: deviceType\n    };\n  };\n  var PlatformDetection = {\n    detect: detect$3\n  };\n  var mediaMatch = function mediaMatch(query) {\n    return window.matchMedia(query).matches;\n  };\n  var platform = cached(function () {\n    return PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch);\n  });\n  var detect$2 = function detect$2() {\n    return platform();\n  };\n  var mkEvent = function mkEvent(target, x, y, stop, prevent, kill, raw) {\n    return {\n      target: target,\n      x: x,\n      y: y,\n      stop: stop,\n      prevent: prevent,\n      kill: kill,\n      raw: raw\n    };\n  };\n  var fromRawEvent$1 = function fromRawEvent$1(rawEvent) {\n    var target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n    var stop = function stop() {\n      return rawEvent.stopPropagation();\n    };\n    var prevent = function prevent() {\n      return rawEvent.preventDefault();\n    };\n    var kill = compose(prevent, stop);\n    return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n  };\n  var handle = function handle(filter, handler) {\n    return function (rawEvent) {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent$1(rawEvent));\n      }\n    };\n  };\n  var binder = function binder(element, event, filter, handler, useCapture) {\n    var wrapped = handle(filter, handler);\n    element.dom.addEventListener(event, wrapped, useCapture);\n    return {\n      unbind: curry(unbind, element, event, wrapped, useCapture)\n    };\n  };\n  var bind$2 = function bind$2(element, event, filter, handler) {\n    return binder(element, event, filter, handler, false);\n  };\n  var capture$1 = function capture$1(element, event, filter, handler) {\n    return binder(element, event, filter, handler, true);\n  };\n  var unbind = function unbind(element, event, handler, useCapture) {\n    element.dom.removeEventListener(event, handler, useCapture);\n  };\n  var before$1 = function before$1(marker, element) {\n    var parent$1 = parent(marker);\n    parent$1.each(function (v) {\n      v.dom.insertBefore(element.dom, marker.dom);\n    });\n  };\n  var after$2 = function after$2(marker, element) {\n    var sibling = nextSibling(marker);\n    sibling.fold(function () {\n      var parent$1 = parent(marker);\n      parent$1.each(function (v) {\n        append$2(v, element);\n      });\n    }, function (v) {\n      before$1(v, element);\n    });\n  };\n  var prepend$1 = function prepend$1(parent, element) {\n    var firstChild$1 = firstChild(parent);\n    firstChild$1.fold(function () {\n      append$2(parent, element);\n    }, function (v) {\n      parent.dom.insertBefore(element.dom, v.dom);\n    });\n  };\n  var append$2 = function append$2(parent, element) {\n    parent.dom.appendChild(element.dom);\n  };\n  var appendAt = function appendAt(parent, element, index) {\n    child$2(parent, index).fold(function () {\n      append$2(parent, element);\n    }, function (v) {\n      before$1(v, element);\n    });\n  };\n  var append$1 = function append$1(parent, elements) {\n    each$1(elements, function (x) {\n      append$2(parent, x);\n    });\n  };\n  var empty = function empty(element) {\n    element.dom.textContent = '';\n    each$1(children(element), function (rogue) {\n      remove$5(rogue);\n    });\n  };\n  var remove$5 = function remove$5(element) {\n    var dom = element.dom;\n    if (dom.parentNode !== null) {\n      dom.parentNode.removeChild(dom);\n    }\n  };\n  var get$b = function get$b(_DOC) {\n    var doc = _DOC !== undefined ? _DOC.dom : document;\n    var x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n    var y = doc.body.scrollTop || doc.documentElement.scrollTop;\n    return SugarPosition(x, y);\n  };\n  var to = function to(x, y, _DOC) {\n    var doc = _DOC !== undefined ? _DOC.dom : document;\n    var win = doc.defaultView;\n    if (win) {\n      win.scrollTo(x, y);\n    }\n  };\n  var get$a = function get$a(_win) {\n    var win = _win === undefined ? window : _win;\n    if (detect$2().browser.isFirefox()) {\n      return Optional.none();\n    } else {\n      return Optional.from(win.visualViewport);\n    }\n  };\n  var bounds$1 = function bounds$1(x, y, width, height) {\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      right: x + width,\n      bottom: y + height\n    };\n  };\n  var getBounds$3 = function getBounds$3(_win) {\n    var win = _win === undefined ? window : _win;\n    var doc = win.document;\n    var scroll = get$b(SugarElement.fromDom(doc));\n    return get$a(win).fold(function () {\n      var html = win.document.documentElement;\n      var width = html.clientWidth;\n      var height = html.clientHeight;\n      return bounds$1(scroll.left, scroll.top, width, height);\n    }, function (visualViewport) {\n      return bounds$1(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height);\n    });\n  };\n  var getDocument = function getDocument() {\n    return SugarElement.fromDom(document);\n  };\n  var walkUp = function walkUp(navigation, doc) {\n    var frame = navigation.view(doc);\n    return frame.fold(constant$1([]), function (f) {\n      var parent = navigation.owner(f);\n      var rest = walkUp(navigation, parent);\n      return [f].concat(rest);\n    });\n  };\n  var pathTo = function pathTo(element, navigation) {\n    var d = navigation.owner(element);\n    var paths = walkUp(navigation, d);\n    return Optional.some(paths);\n  };\n  var view = function view(doc) {\n    var _a;\n    var element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n    return element.map(SugarElement.fromDom);\n  };\n  var owner$3 = function owner$3(element) {\n    return owner$4(element);\n  };\n  var Navigation = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    view: view,\n    owner: owner$3\n  });\n  var find$2 = function find$2(element) {\n    var doc = getDocument();\n    var scroll = get$b(doc);\n    var path = pathTo(element, Navigation);\n    return path.fold(curry(absolute$3, element), function (frames) {\n      var offset = viewport$1(element);\n      var r = foldr(frames, function (b, a) {\n        var loc = viewport$1(a);\n        return {\n          left: b.left + loc.left,\n          top: b.top + loc.top\n        };\n      }, {\n        left: 0,\n        top: 0\n      });\n      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n    });\n  };\n  var pointed = function pointed(point, width, height) {\n    return {\n      point: point,\n      width: width,\n      height: height\n    };\n  };\n  var rect = function rect(x, y, width, height) {\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  };\n  var bounds = function bounds(x, y, width, height) {\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      right: x + width,\n      bottom: y + height\n    };\n  };\n  var box$1 = function box$1(element) {\n    var xy = absolute$3(element);\n    var w = getOuter$1(element);\n    var h = getOuter$2(element);\n    return bounds(xy.left, xy.top, w, h);\n  };\n  var absolute$2 = function absolute$2(element) {\n    var position = find$2(element);\n    var width = getOuter$1(element);\n    var height = getOuter$2(element);\n    return bounds(position.left, position.top, width, height);\n  };\n  var constrain = function constrain(original, constraint) {\n    var left = Math.max(original.x, constraint.x);\n    var top = Math.max(original.y, constraint.y);\n    var right = Math.min(original.right, constraint.right);\n    var bottom = Math.min(original.bottom, constraint.bottom);\n    var width = right - left;\n    var height = bottom - top;\n    return bounds(left, top, width, height);\n  };\n  var constrainByMany = function constrainByMany(original, constraints) {\n    return foldl(constraints, function (acc, c) {\n      return constrain(acc, c);\n    }, original);\n  };\n  var win = function win() {\n    return getBounds$3(window);\n  };\n  var global$a = tinymce.util.Tools.resolve('tinymce.ThemeManager');\n  var value$4 = function value$4(value) {\n    var applyHelper = function applyHelper(fn) {\n      return fn(value);\n    };\n    var constHelper = constant$1(value);\n    var outputHelper = function outputHelper() {\n      return output;\n    };\n    var output = {\n      tag: true,\n      inner: value,\n      fold: function fold(_onError, onValue) {\n        return onValue(value);\n      },\n      isValue: always,\n      isError: never,\n      map: function map(mapper) {\n        return Result.value(mapper(value));\n      },\n      mapError: outputHelper,\n      bind: applyHelper,\n      exists: applyHelper,\n      forall: applyHelper,\n      getOr: constHelper,\n      or: outputHelper,\n      getOrThunk: constHelper,\n      orThunk: outputHelper,\n      getOrDie: constHelper,\n      each: function each(fn) {\n        fn(value);\n      },\n      toOptional: function toOptional() {\n        return Optional.some(value);\n      }\n    };\n    return output;\n  };\n  var error$1 = function error$1(error) {\n    var outputHelper = function outputHelper() {\n      return output;\n    };\n    var output = {\n      tag: false,\n      inner: error,\n      fold: function fold(onError, _onValue) {\n        return onError(error);\n      },\n      isValue: never,\n      isError: always,\n      map: outputHelper,\n      mapError: function mapError(mapper) {\n        return Result.error(mapper(error));\n      },\n      bind: outputHelper,\n      exists: never,\n      forall: always,\n      getOr: identity,\n      or: identity,\n      getOrThunk: apply$1,\n      orThunk: apply$1,\n      getOrDie: die(String(error)),\n      each: noop,\n      toOptional: Optional.none\n    };\n    return output;\n  };\n  var fromOption = function fromOption(optional, err) {\n    return optional.fold(function () {\n      return error$1(err);\n    }, value$4);\n  };\n  var Result = {\n    value: value$4,\n    error: error$1,\n    fromOption: fromOption\n  };\n  var SimpleResultType;\n  (function (SimpleResultType) {\n    SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n    SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n  })(SimpleResultType || (SimpleResultType = {}));\n  var fold$1 = function fold$1(res, onError, onValue) {\n    return res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n  };\n  var partition$2 = function partition$2(results) {\n    var values = [];\n    var errors = [];\n    each$1(results, function (obj) {\n      fold$1(obj, function (err) {\n        return errors.push(err);\n      }, function (val) {\n        return values.push(val);\n      });\n    });\n    return {\n      values: values,\n      errors: errors\n    };\n  };\n  var mapError = function mapError(res, f) {\n    if (res.stype === SimpleResultType.Error) {\n      return {\n        stype: SimpleResultType.Error,\n        serror: f(res.serror)\n      };\n    } else {\n      return res;\n    }\n  };\n  var map = function map(res, f) {\n    if (res.stype === SimpleResultType.Value) {\n      return {\n        stype: SimpleResultType.Value,\n        svalue: f(res.svalue)\n      };\n    } else {\n      return res;\n    }\n  };\n  var bind$1 = function bind$1(res, f) {\n    if (res.stype === SimpleResultType.Value) {\n      return f(res.svalue);\n    } else {\n      return res;\n    }\n  };\n  var bindError = function bindError(res, f) {\n    if (res.stype === SimpleResultType.Error) {\n      return f(res.serror);\n    } else {\n      return res;\n    }\n  };\n  var svalue = function svalue(v) {\n    return {\n      stype: SimpleResultType.Value,\n      svalue: v\n    };\n  };\n  var serror = function serror(e) {\n    return {\n      stype: SimpleResultType.Error,\n      serror: e\n    };\n  };\n  var toResult$1 = function toResult$1(res) {\n    return fold$1(res, Result.error, Result.value);\n  };\n  var fromResult$1 = function fromResult$1(res) {\n    return res.fold(serror, svalue);\n  };\n  var SimpleResult = {\n    fromResult: fromResult$1,\n    toResult: toResult$1,\n    svalue: svalue,\n    partition: partition$2,\n    serror: serror,\n    bind: bind$1,\n    bindError: bindError,\n    map: map,\n    mapError: mapError,\n    fold: fold$1\n  };\n  var field$2 = function field$2(key, newKey, presence, prop) {\n    return {\n      tag: 'field',\n      key: key,\n      newKey: newKey,\n      presence: presence,\n      prop: prop\n    };\n  };\n  var customField$1 = function customField$1(newKey, instantiator) {\n    return {\n      tag: 'custom',\n      newKey: newKey,\n      instantiator: instantiator\n    };\n  };\n  var fold = function fold(value, ifField, ifCustom) {\n    switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n    }\n  };\n  var shallow$1 = function shallow$1(old, nu) {\n    return nu;\n  };\n  var deep$1 = function deep$1(old, nu) {\n    var bothObjects = isPlainObject(old) && isPlainObject(nu);\n    return bothObjects ? deepMerge(old, nu) : nu;\n  };\n  var baseMerge = function baseMerge(merger) {\n    return function () {\n      if (arguments.length === 0) {\n        throw new Error(\"Can't merge zero objects\");\n      }\n      var ret = {};\n      for (var j = 0; j < arguments.length; j++) {\n        var curObject = j < 0 || arguments.length <= j ? undefined : arguments[j];\n        for (var key in curObject) {\n          if (has$2(curObject, key)) {\n            ret[key] = merger(ret[key], curObject[key]);\n          }\n        }\n      }\n      return ret;\n    };\n  };\n  var deepMerge = baseMerge(deep$1);\n  var merge$1 = baseMerge(shallow$1);\n  var required$2 = function required$2() {\n    return {\n      tag: 'required',\n      process: {}\n    };\n  };\n  var defaultedThunk = function defaultedThunk(fallbackThunk) {\n    return {\n      tag: 'defaultedThunk',\n      process: fallbackThunk\n    };\n  };\n  var defaulted$1 = function defaulted$1(fallback) {\n    return defaultedThunk(constant$1(fallback));\n  };\n  var asOption = function asOption() {\n    return {\n      tag: 'option',\n      process: {}\n    };\n  };\n  var mergeWithThunk = function mergeWithThunk(baseThunk) {\n    return {\n      tag: 'mergeWithThunk',\n      process: baseThunk\n    };\n  };\n  var mergeWith = function mergeWith(base) {\n    return mergeWithThunk(constant$1(base));\n  };\n  var mergeValues$1 = function mergeValues$1(values, base) {\n    return values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge$1.apply(undefined, values))) : SimpleResult.svalue(base);\n  };\n  var mergeErrors$1 = function mergeErrors$1(errors) {\n    return compose(SimpleResult.serror, flatten)(errors);\n  };\n  var consolidateObj = function consolidateObj(objects, base) {\n    var partition = SimpleResult.partition(objects);\n    return partition.errors.length > 0 ? mergeErrors$1(partition.errors) : mergeValues$1(partition.values, base);\n  };\n  var consolidateArr = function consolidateArr(objects) {\n    var partitions = SimpleResult.partition(objects);\n    return partitions.errors.length > 0 ? mergeErrors$1(partitions.errors) : SimpleResult.svalue(partitions.values);\n  };\n  var ResultCombine = {\n    consolidateObj: consolidateObj,\n    consolidateArr: consolidateArr\n  };\n  var formatObj = function formatObj(input) {\n    return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n  };\n  var formatErrors = function formatErrors(errors) {\n    var es = errors.length > 10 ? errors.slice(0, 10).concat([{\n      path: [],\n      getErrorInfo: constant$1('... (only showing first ten failures)')\n    }]) : errors;\n    return map$2(es, function (e) {\n      return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n    });\n  };\n  var nu$a = function nu$a(path, getErrorInfo) {\n    return SimpleResult.serror([{\n      path: path,\n      getErrorInfo: getErrorInfo\n    }]);\n  };\n  var missingRequired = function missingRequired(path, key, obj) {\n    return nu$a(path, function () {\n      return 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj);\n    });\n  };\n  var missingKey = function missingKey(path, key) {\n    return nu$a(path, function () {\n      return 'Choice schema did not contain choice key: \"' + key + '\"';\n    });\n  };\n  var missingBranch = function missingBranch(path, branches, branch) {\n    return nu$a(path, function () {\n      return 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches);\n    });\n  };\n  var unsupportedFields = function unsupportedFields(path, unsupported) {\n    return nu$a(path, function () {\n      return 'There are unsupported fields: [' + unsupported.join(', ') + '] specified';\n    });\n  };\n  var custom = function custom(path, err) {\n    return nu$a(path, constant$1(err));\n  };\n  var value$3 = function value$3(validator) {\n    var extract = function extract(path, val) {\n      return SimpleResult.bindError(validator(val), function (err) {\n        return custom(path, err);\n      });\n    };\n    var toString = constant$1('val');\n    return {\n      extract: extract,\n      toString: toString\n    };\n  };\n  var anyValue$1 = value$3(SimpleResult.svalue);\n  var requiredAccess = function requiredAccess(path, obj, key, bundle) {\n    return get$g(obj, key).fold(function () {\n      return missingRequired(path, key, obj);\n    }, bundle);\n  };\n  var fallbackAccess = function fallbackAccess(obj, key, fallback, bundle) {\n    var v = get$g(obj, key).getOrThunk(function () {\n      return fallback(obj);\n    });\n    return bundle(v);\n  };\n  var optionAccess = function optionAccess(obj, key, bundle) {\n    return bundle(get$g(obj, key));\n  };\n  var optionDefaultedAccess = function optionDefaultedAccess(obj, key, fallback, bundle) {\n    var opt = get$g(obj, key).map(function (val) {\n      return val === true ? fallback(obj) : val;\n    });\n    return bundle(opt);\n  };\n  var extractField = function extractField(field, path, obj, key, prop) {\n    var bundle = function bundle(av) {\n      return prop.extract(path.concat([key]), av);\n    };\n    var bundleAsOption = function bundleAsOption(optValue) {\n      return optValue.fold(function () {\n        return SimpleResult.svalue(Optional.none());\n      }, function (ov) {\n        var result = prop.extract(path.concat([key]), ov);\n        return SimpleResult.map(result, Optional.some);\n      });\n    };\n    switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n      case 'mergeWithThunk':\n        {\n          return fallbackAccess(obj, key, constant$1({}), function (v) {\n            var result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n    }\n  };\n  var extractFields = function extractFields(path, obj, fields) {\n    var success = {};\n    var errors = [];\n    var _iterator = _createForOfIteratorHelper(fields),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _field2 = _step.value;\n        fold(_field2, function (key, newKey, presence, prop) {\n          var result = extractField(presence, path, obj, key, prop);\n          SimpleResult.fold(result, function (err) {\n            errors.push.apply(errors, _toConsumableArray(err));\n          }, function (res) {\n            success[newKey] = res;\n          });\n        }, function (newKey, instantiator) {\n          success[newKey] = instantiator(obj);\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n  };\n  var valueThunk = function valueThunk(getDelegate) {\n    var extract = function extract(path, val) {\n      return getDelegate().extract(path, val);\n    };\n    var toString = function toString() {\n      return getDelegate().toString();\n    };\n    return {\n      extract: extract,\n      toString: toString\n    };\n  };\n  var getSetKeys = function getSetKeys(obj) {\n    return keys(filter$1(obj, isNonNullable));\n  };\n  var objOfOnly = function objOfOnly(fields) {\n    var delegate = objOf(fields);\n    var fieldNames = foldr(fields, function (acc, value) {\n      return fold(value, function (key) {\n        return deepMerge(acc, _defineProperty({}, key, true));\n      }, constant$1(acc));\n    }, {});\n    var extract = function extract(path, o) {\n      var keys = isBoolean(o) ? [] : getSetKeys(o);\n      var extra = filter$2(keys, function (k) {\n        return !hasNonNullableKey(fieldNames, k);\n      });\n      return extra.length === 0 ? delegate.extract(path, o) : unsupportedFields(path, extra);\n    };\n    return {\n      extract: extract,\n      toString: delegate.toString\n    };\n  };\n  var objOf = function objOf(values) {\n    var extract = function extract(path, o) {\n      return extractFields(path, o, values);\n    };\n    var toString = function toString() {\n      var fieldStrings = map$2(values, function (value) {\n        return fold(value, function (key, _okey, _presence, prop) {\n          return key + ' -> ' + prop.toString();\n        }, function (newKey, _instantiator) {\n          return 'state(' + newKey + ')';\n        });\n      });\n      return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n    };\n    return {\n      extract: extract,\n      toString: toString\n    };\n  };\n  var arrOf = function arrOf(prop) {\n    var extract = function extract(path, array) {\n      var results = map$2(array, function (a, i) {\n        return prop.extract(path.concat(['[' + i + ']']), a);\n      });\n      return ResultCombine.consolidateArr(results);\n    };\n    var toString = function toString() {\n      return 'array(' + prop.toString() + ')';\n    };\n    return {\n      extract: extract,\n      toString: toString\n    };\n  };\n  var oneOf = function oneOf(props, rawF) {\n    var f = rawF !== undefined ? rawF : identity;\n    var extract = function extract(path, val) {\n      var errors = [];\n      var _iterator2 = _createForOfIteratorHelper(props),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var prop = _step2.value;\n          var res = prop.extract(path, val);\n          if (res.stype === SimpleResultType.Value) {\n            return {\n              stype: SimpleResultType.Value,\n              svalue: f(res.svalue)\n            };\n          }\n          errors.push(res);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return ResultCombine.consolidateArr(errors);\n    };\n    var toString = function toString() {\n      return 'oneOf(' + map$2(props, function (prop) {\n        return prop.toString();\n      }).join(', ') + ')';\n    };\n    return {\n      extract: extract,\n      toString: toString\n    };\n  };\n  var setOf$1 = function setOf$1(validator, prop) {\n    var validateKeys = function validateKeys(path, keys) {\n      return arrOf(value$3(validator)).extract(path, keys);\n    };\n    var extract = function extract(path, o) {\n      var keys$1 = keys(o);\n      var validatedKeys = validateKeys(path, keys$1);\n      return SimpleResult.bind(validatedKeys, function (validKeys) {\n        var schema = map$2(validKeys, function (vk) {\n          return field$2(vk, vk, required$2(), prop);\n        });\n        return objOf(schema).extract(path, o);\n      });\n    };\n    var toString = function toString() {\n      return 'setOf(' + prop.toString() + ')';\n    };\n    return {\n      extract: extract,\n      toString: toString\n    };\n  };\n  var thunk = function thunk(_desc, processor) {\n    var getP = cached(processor);\n    var extract = function extract(path, val) {\n      return getP().extract(path, val);\n    };\n    var toString = function toString() {\n      return getP().toString();\n    };\n    return {\n      extract: extract,\n      toString: toString\n    };\n  };\n  var arrOfObj = compose(arrOf, objOf);\n  var anyValue = constant$1(anyValue$1);\n  var typedValue = function typedValue(validator, expectedType) {\n    return value$3(function (a) {\n      var actualType = typeof a;\n      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(\"Expected type: \".concat(expectedType, \" but got: \").concat(actualType));\n    });\n  };\n  var number = typedValue(isNumber, 'number');\n  var string = typedValue(isString, 'string');\n  var boolean = typedValue(isBoolean, 'boolean');\n  var functionProcessor = typedValue(isFunction, 'function');\n  var isPostMessageable = function isPostMessageable(val) {\n    if (Object(val) !== val) {\n      return true;\n    }\n    switch ({}.toString.call(val).slice(8, -1)) {\n      case 'Boolean':\n      case 'Number':\n      case 'String':\n      case 'Date':\n      case 'RegExp':\n      case 'Blob':\n      case 'FileList':\n      case 'ImageData':\n      case 'ImageBitmap':\n      case 'ArrayBuffer':\n        return true;\n      case 'Array':\n      case 'Object':\n        return Object.keys(val).every(function (prop) {\n          return isPostMessageable(val[prop]);\n        });\n      default:\n        return false;\n    }\n  };\n  var postMessageable = value$3(function (a) {\n    if (isPostMessageable(a)) {\n      return SimpleResult.svalue(a);\n    } else {\n      return SimpleResult.serror('Expected value to be acceptable for sending via postMessage');\n    }\n  });\n  var chooseFrom = function chooseFrom(path, input, branches, ch) {\n    var fields = get$g(branches, ch);\n    return fields.fold(function () {\n      return missingBranch(path, branches, ch);\n    }, function (vp) {\n      return vp.extract(path.concat(['branch: ' + ch]), input);\n    });\n  };\n  var choose$2 = function choose$2(key, branches) {\n    var extract = function extract(path, input) {\n      var choice = get$g(input, key);\n      return choice.fold(function () {\n        return missingKey(path, key);\n      }, function (chosen) {\n        return chooseFrom(path, input, branches, chosen);\n      });\n    };\n    var toString = function toString() {\n      return 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n    };\n    return {\n      extract: extract,\n      toString: toString\n    };\n  };\n  var arrOfVal = function arrOfVal() {\n    return arrOf(anyValue$1);\n  };\n  var valueOf = function valueOf(validator) {\n    return value$3(function (v) {\n      return validator(v).fold(SimpleResult.serror, SimpleResult.svalue);\n    });\n  };\n  var setOf = function setOf(validator, prop) {\n    return setOf$1(function (v) {\n      return SimpleResult.fromResult(validator(v));\n    }, prop);\n  };\n  var extractValue = function extractValue(label, prop, obj) {\n    var res = prop.extract([label], obj);\n    return SimpleResult.mapError(res, function (errs) {\n      return {\n        input: obj,\n        errors: errs\n      };\n    });\n  };\n  var asRaw = function asRaw(label, prop, obj) {\n    return SimpleResult.toResult(extractValue(label, prop, obj));\n  };\n  var getOrDie = function getOrDie(extraction) {\n    return extraction.fold(function (errInfo) {\n      throw new Error(formatError(errInfo));\n    }, identity);\n  };\n  var asRawOrDie$1 = function asRawOrDie$1(label, prop, obj) {\n    return getOrDie(asRaw(label, prop, obj));\n  };\n  var formatError = function formatError(errInfo) {\n    return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n  };\n  var choose$1 = function choose$1(key, branches) {\n    return choose$2(key, map$1(branches, objOf));\n  };\n  var thunkOf = function thunkOf(desc, schema) {\n    return thunk(desc, schema);\n  };\n  var field$1 = field$2;\n  var customField = customField$1;\n  var validateEnum = function validateEnum(values) {\n    return valueOf(function (value) {\n      return contains$2(values, value) ? Result.value(value) : Result.error(\"Unsupported value: \\\"\".concat(value, \"\\\", choose one of \\\"\").concat(values.join(', '), \"\\\".\"));\n    });\n  };\n  var required$1 = function required$1(key) {\n    return field$1(key, key, required$2(), anyValue());\n  };\n  var requiredOf = function requiredOf(key, schema) {\n    return field$1(key, key, required$2(), schema);\n  };\n  var requiredNumber = function requiredNumber(key) {\n    return requiredOf(key, number);\n  };\n  var requiredString = function requiredString(key) {\n    return requiredOf(key, string);\n  };\n  var requiredStringEnum = function requiredStringEnum(key, values) {\n    return field$1(key, key, required$2(), validateEnum(values));\n  };\n  var requiredBoolean = function requiredBoolean(key) {\n    return requiredOf(key, boolean);\n  };\n  var requiredFunction = function requiredFunction(key) {\n    return requiredOf(key, functionProcessor);\n  };\n  var forbid = function forbid(key, message) {\n    return field$1(key, key, asOption(), value$3(function (_v) {\n      return SimpleResult.serror('The field: ' + key + ' is forbidden. ' + message);\n    }));\n  };\n  var requiredObjOf = function requiredObjOf(key, objSchema) {\n    return field$1(key, key, required$2(), objOf(objSchema));\n  };\n  var requiredArrayOfObj = function requiredArrayOfObj(key, objFields) {\n    return field$1(key, key, required$2(), arrOfObj(objFields));\n  };\n  var requiredArrayOf = function requiredArrayOf(key, schema) {\n    return field$1(key, key, required$2(), arrOf(schema));\n  };\n  var option$3 = function option$3(key) {\n    return field$1(key, key, asOption(), anyValue());\n  };\n  var optionOf = function optionOf(key, schema) {\n    return field$1(key, key, asOption(), schema);\n  };\n  var optionNumber = function optionNumber(key) {\n    return optionOf(key, number);\n  };\n  var optionString = function optionString(key) {\n    return optionOf(key, string);\n  };\n  var optionStringEnum = function optionStringEnum(key, values) {\n    return optionOf(key, validateEnum(values));\n  };\n  var optionFunction = function optionFunction(key) {\n    return optionOf(key, functionProcessor);\n  };\n  var optionArrayOf = function optionArrayOf(key, schema) {\n    return optionOf(key, arrOf(schema));\n  };\n  var optionObjOf = function optionObjOf(key, objSchema) {\n    return optionOf(key, objOf(objSchema));\n  };\n  var optionObjOfOnly = function optionObjOfOnly(key, objSchema) {\n    return optionOf(key, objOfOnly(objSchema));\n  };\n  var defaulted = function defaulted(key, fallback) {\n    return field$1(key, key, defaulted$1(fallback), anyValue());\n  };\n  var defaultedOf = function defaultedOf(key, fallback, schema) {\n    return field$1(key, key, defaulted$1(fallback), schema);\n  };\n  var defaultedNumber = function defaultedNumber(key, fallback) {\n    return defaultedOf(key, fallback, number);\n  };\n  var defaultedString = function defaultedString(key, fallback) {\n    return defaultedOf(key, fallback, string);\n  };\n  var defaultedStringEnum = function defaultedStringEnum(key, fallback, values) {\n    return defaultedOf(key, fallback, validateEnum(values));\n  };\n  var defaultedBoolean = function defaultedBoolean(key, fallback) {\n    return defaultedOf(key, fallback, boolean);\n  };\n  var defaultedFunction = function defaultedFunction(key, fallback) {\n    return defaultedOf(key, fallback, functionProcessor);\n  };\n  var defaultedPostMsg = function defaultedPostMsg(key, fallback) {\n    return defaultedOf(key, fallback, postMessageable);\n  };\n  var defaultedArrayOf = function defaultedArrayOf(key, fallback, schema) {\n    return defaultedOf(key, fallback, arrOf(schema));\n  };\n  var defaultedObjOf = function defaultedObjOf(key, fallback, objSchema) {\n    return defaultedOf(key, fallback, objOf(objSchema));\n  };\n  var Cell = function Cell(initial) {\n    var value = initial;\n    var get = function get() {\n      return value;\n    };\n    var set = function set(v) {\n      value = v;\n    };\n    return {\n      get: get,\n      set: set\n    };\n  };\n  var generate$7 = function generate$7(cases) {\n    if (!isArray(cases)) {\n      throw new Error('cases must be an array');\n    }\n    if (cases.length === 0) {\n      throw new Error('there must be at least one case');\n    }\n    var constructors = [];\n    var adt = {};\n    each$1(cases, function (acase, count) {\n      var keys$1 = keys(acase);\n      if (keys$1.length !== 1) {\n        throw new Error('one and only one name per case');\n      }\n      var key = keys$1[0];\n      var value = acase[key];\n      if (adt[key] !== undefined) {\n        throw new Error('duplicate key detected:' + key);\n      } else if (key === 'cata') {\n        throw new Error('cannot have a case named cata (sorry)');\n      } else if (!isArray(value)) {\n        throw new Error('case arguments must be an array');\n      }\n      constructors.push(key);\n      adt[key] = function () {\n        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n          args[_key7] = arguments[_key7];\n        }\n        var argLength = args.length;\n        if (argLength !== value.length) {\n          throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n        }\n        var match = function match(branches) {\n          var branchKeys = keys(branches);\n          if (constructors.length !== branchKeys.length) {\n            throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n          }\n          var allReqd = forall(constructors, function (reqKey) {\n            return contains$2(branchKeys, reqKey);\n          });\n          if (!allReqd) {\n            throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n          }\n          return branches[key].apply(null, args);\n        };\n        return {\n          fold: function fold() {\n            for (var _len8 = arguments.length, foldArgs = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n              foldArgs[_key8] = arguments[_key8];\n            }\n            if (foldArgs.length !== cases.length) {\n              throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n            }\n            var target = foldArgs[count];\n            return target.apply(null, args);\n          },\n          match: match,\n          log: function log(label) {\n            console.log(label, {\n              constructors: constructors,\n              constructor: key,\n              params: args\n            });\n          }\n        };\n      };\n    });\n    return adt;\n  };\n  var Adt = {\n    generate: generate$7\n  };\n  Adt.generate([{\n    bothErrors: ['error1', 'error2']\n  }, {\n    firstError: ['error1', 'value2']\n  }, {\n    secondError: ['value1', 'error2']\n  }, {\n    bothValues: ['value1', 'value2']\n  }]);\n  var partition$1 = function partition$1(results) {\n    var errors = [];\n    var values = [];\n    each$1(results, function (result) {\n      result.fold(function (err) {\n        errors.push(err);\n      }, function (value) {\n        values.push(value);\n      });\n    });\n    return {\n      errors: errors,\n      values: values\n    };\n  };\n  var exclude$1 = function exclude$1(obj, fields) {\n    var r = {};\n    each(obj, function (v, k) {\n      if (!contains$2(fields, k)) {\n        r[k] = v;\n      }\n    });\n    return r;\n  };\n  var wrap$2 = function wrap$2(key, value) {\n    return _defineProperty({}, key, value);\n  };\n  var wrapAll$1 = function wrapAll$1(keyvalues) {\n    var r = {};\n    each$1(keyvalues, function (kv) {\n      r[kv.key] = kv.value;\n    });\n    return r;\n  };\n  var exclude = function exclude(obj, fields) {\n    return exclude$1(obj, fields);\n  };\n  var wrap$1 = function wrap$1(key, value) {\n    return wrap$2(key, value);\n  };\n  var wrapAll = function wrapAll(keyvalues) {\n    return wrapAll$1(keyvalues);\n  };\n  var mergeValues = function mergeValues(values, base) {\n    return values.length === 0 ? Result.value(base) : Result.value(deepMerge(base, merge$1.apply(undefined, values)));\n  };\n  var mergeErrors = function mergeErrors(errors) {\n    return Result.error(flatten(errors));\n  };\n  var consolidate = function consolidate(objs, base) {\n    var partitions = partition$1(objs);\n    return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : mergeValues(partitions.values, base);\n  };\n  var ensureIsRoot = function ensureIsRoot(isRoot) {\n    return isFunction(isRoot) ? isRoot : never;\n  };\n  var ancestor$2 = function ancestor$2(scope, transform, isRoot) {\n    var element = scope.dom;\n    var stop = ensureIsRoot(isRoot);\n    while (element.parentNode) {\n      element = element.parentNode;\n      var el = SugarElement.fromDom(element);\n      var transformed = transform(el);\n      if (transformed.isSome()) {\n        return transformed;\n      } else if (stop(el)) {\n        break;\n      }\n    }\n    return Optional.none();\n  };\n  var closest$4 = function closest$4(scope, transform, isRoot) {\n    var current = transform(scope);\n    var stop = ensureIsRoot(isRoot);\n    return current.orThunk(function () {\n      return stop(scope) ? Optional.none() : ancestor$2(scope, transform, stop);\n    });\n  };\n  var isSource = function isSource(component, simulatedEvent) {\n    return eq(component.element, simulatedEvent.event.target);\n  };\n  var defaultEventHandler = {\n    can: always,\n    abort: never,\n    run: noop\n  };\n  var nu$9 = function nu$9(parts) {\n    if (!hasNonNullableKey(parts, 'can') && !hasNonNullableKey(parts, 'abort') && !hasNonNullableKey(parts, 'run')) {\n      throw new Error('EventHandler defined by: ' + JSON.stringify(parts, null, 2) + ' does not have can, abort, or run!');\n    }\n    return _objectSpread({}, defaultEventHandler, parts);\n  };\n  var all$2 = function all$2(handlers, f) {\n    return function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return foldl(handlers, function (acc, handler) {\n        return acc && f(handler).apply(undefined, args);\n      }, true);\n    };\n  };\n  var any = function any(handlers, f) {\n    return function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return foldl(handlers, function (acc, handler) {\n        return acc || f(handler).apply(undefined, args);\n      }, false);\n    };\n  };\n  var read$2 = function read$2(handler) {\n    return isFunction(handler) ? {\n      can: always,\n      abort: never,\n      run: handler\n    } : handler;\n  };\n  var fuse$1 = function fuse$1(handlers) {\n    var can = all$2(handlers, function (handler) {\n      return handler.can;\n    });\n    var abort = any(handlers, function (handler) {\n      return handler.abort;\n    });\n    var run = function run() {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      each$1(handlers, function (handler) {\n        handler.run.apply(undefined, args);\n      });\n    };\n    return {\n      can: can,\n      abort: abort,\n      run: run\n    };\n  };\n  var constant = constant$1;\n  var touchstart = constant('touchstart');\n  var touchmove = constant('touchmove');\n  var touchend = constant('touchend');\n  var touchcancel = constant('touchcancel');\n  var mousedown = constant('mousedown');\n  var mousemove = constant('mousemove');\n  var mouseout = constant('mouseout');\n  var mouseup = constant('mouseup');\n  var mouseover = constant('mouseover');\n  var focusin = constant('focusin');\n  var focusout = constant('focusout');\n  var keydown = constant('keydown');\n  var keyup = constant('keyup');\n  var input = constant('input');\n  var change = constant('change');\n  var click = constant('click');\n  var transitioncancel = constant('transitioncancel');\n  var transitionend = constant('transitionend');\n  var transitionstart = constant('transitionstart');\n  var selectstart = constant('selectstart');\n  var prefixName = function prefixName(name) {\n    return constant$1('alloy.' + name);\n  };\n  var alloy = {\n    tap: prefixName('tap')\n  };\n  var focus$4 = prefixName('focus');\n  var postBlur = prefixName('blur.post');\n  var postPaste = prefixName('paste.post');\n  var receive = prefixName('receive');\n  var execute$5 = prefixName('execute');\n  var focusItem = prefixName('focus.item');\n  var tap = alloy.tap;\n  var longpress = prefixName('longpress');\n  var sandboxClose = prefixName('sandbox.close');\n  var typeaheadCancel = prefixName('typeahead.cancel');\n  var systemInit = prefixName('system.init');\n  var documentTouchmove = prefixName('system.touchmove');\n  var documentTouchend = prefixName('system.touchend');\n  var windowScroll = prefixName('system.scroll');\n  var windowResize = prefixName('system.resize');\n  var attachedToDom = prefixName('system.attached');\n  var detachedFromDom = prefixName('system.detached');\n  var dismissRequested = prefixName('system.dismissRequested');\n  var repositionRequested = prefixName('system.repositionRequested');\n  var focusShifted = prefixName('focusmanager.shifted');\n  var slotVisibility = prefixName('slotcontainer.visibility');\n  var externalElementScroll = prefixName('system.external.element.scroll');\n  var changeTab = prefixName('change.tab');\n  var dismissTab = prefixName('dismiss.tab');\n  var highlight$1 = prefixName('highlight');\n  var dehighlight$1 = prefixName('dehighlight');\n  var emit = function emit(component, event) {\n    dispatchWith(component, component.element, event, {});\n  };\n  var emitWith = function emitWith(component, event, properties) {\n    dispatchWith(component, component.element, event, properties);\n  };\n  var emitExecute = function emitExecute(component) {\n    emit(component, execute$5());\n  };\n  var dispatch = function dispatch(component, target, event) {\n    dispatchWith(component, target, event, {});\n  };\n  var dispatchWith = function dispatchWith(component, target, event, properties) {\n    var data = _objectSpread({\n      target: target\n    }, properties);\n    component.getSystem().triggerEvent(event, target, data);\n  };\n  var retargetAndDispatchWith = function retargetAndDispatchWith(component, target, eventName, properties) {\n    var data = _objectSpread({}, properties, {\n      target: target\n    });\n    component.getSystem().triggerEvent(eventName, target, data);\n  };\n  var dispatchEvent = function dispatchEvent(component, target, event, simulatedEvent) {\n    component.getSystem().triggerEvent(event, target, simulatedEvent.event);\n  };\n  var derive$2 = function derive$2(configs) {\n    return wrapAll(configs);\n  };\n  var abort = function abort(name, predicate) {\n    return {\n      key: name,\n      value: nu$9({\n        abort: predicate\n      })\n    };\n  };\n  var can = function can(name, predicate) {\n    return {\n      key: name,\n      value: nu$9({\n        can: predicate\n      })\n    };\n  };\n  var preventDefault = function preventDefault(name) {\n    return {\n      key: name,\n      value: nu$9({\n        run: function run(component, simulatedEvent) {\n          simulatedEvent.event.prevent();\n        }\n      })\n    };\n  };\n  var run$1 = function run$1(name, handler) {\n    return {\n      key: name,\n      value: nu$9({\n        run: handler\n      })\n    };\n  };\n  var runActionExtra = function runActionExtra(name, action, extra) {\n    return {\n      key: name,\n      value: nu$9({\n        run: function run(component, simulatedEvent) {\n          action.apply(undefined, [component, simulatedEvent].concat(extra));\n        }\n      })\n    };\n  };\n  var runOnName = function runOnName(name) {\n    return function (handler) {\n      return run$1(name, handler);\n    };\n  };\n  var runOnSourceName = function runOnSourceName(name) {\n    return function (handler) {\n      return {\n        key: name,\n        value: nu$9({\n          run: function run(component, simulatedEvent) {\n            if (isSource(component, simulatedEvent)) {\n              handler(component, simulatedEvent);\n            }\n          }\n        })\n      };\n    };\n  };\n  var redirectToUid = function redirectToUid(name, uid) {\n    return run$1(name, function (component, simulatedEvent) {\n      component.getSystem().getByUid(uid).each(function (redirectee) {\n        dispatchEvent(redirectee, redirectee.element, name, simulatedEvent);\n      });\n    });\n  };\n  var redirectToPart = function redirectToPart(name, detail, partName) {\n    var uid = detail.partUids[partName];\n    return redirectToUid(name, uid);\n  };\n  var runWithTarget = function runWithTarget(name, f) {\n    return run$1(name, function (component, simulatedEvent) {\n      var ev = simulatedEvent.event;\n      var target = component.getSystem().getByDom(ev.target).getOrThunk(function () {\n        var closest = closest$4(ev.target, function (el) {\n          return component.getSystem().getByDom(el).toOptional();\n        }, never);\n        return closest.getOr(component);\n      });\n      f(component, target, simulatedEvent);\n    });\n  };\n  var cutter = function cutter(name) {\n    return run$1(name, function (component, simulatedEvent) {\n      simulatedEvent.cut();\n    });\n  };\n  var stopper = function stopper(name) {\n    return run$1(name, function (component, simulatedEvent) {\n      simulatedEvent.stop();\n    });\n  };\n  var runOnSource = function runOnSource(name, f) {\n    return runOnSourceName(name)(f);\n  };\n  var runOnAttached = runOnSourceName(attachedToDom());\n  var runOnDetached = runOnSourceName(detachedFromDom());\n  var runOnInit = runOnSourceName(systemInit());\n  var runOnExecute$1 = runOnName(execute$5());\n  var fromHtml$1 = function fromHtml$1(html, scope) {\n    var doc = scope || document;\n    var div = doc.createElement('div');\n    div.innerHTML = html;\n    return children(SugarElement.fromDom(div));\n  };\n  var get$9 = function get$9(element) {\n    return element.dom.innerHTML;\n  };\n  var set$6 = function set$6(element, content) {\n    var owner = owner$4(element);\n    var docDom = owner.dom;\n    var fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n    var contentElements = fromHtml$1(content, docDom);\n    append$1(fragment, contentElements);\n    empty(element);\n    append$2(element, fragment);\n  };\n  var getOuter = function getOuter(element) {\n    var container = SugarElement.fromTag('div');\n    var clone = SugarElement.fromDom(element.dom.cloneNode(true));\n    append$2(container, clone);\n    return get$9(container);\n  };\n  var clone$1 = function clone$1(original, isDeep) {\n    return SugarElement.fromDom(original.dom.cloneNode(isDeep));\n  };\n  var shallow = function shallow(original) {\n    return clone$1(original, false);\n  };\n  var deep = function deep(original) {\n    return clone$1(original, true);\n  };\n  var getHtml = function getHtml(element) {\n    if (isShadowRoot(element)) {\n      return '#shadow-root';\n    } else {\n      var _clone = shallow(element);\n      return getOuter(_clone);\n    }\n  };\n  var element = function element(elem) {\n    return getHtml(elem);\n  };\n  var isRecursive = function isRecursive(component, originator, target) {\n    return eq(originator, component.element) && !eq(originator, target);\n  };\n  var events$i = derive$2([can(focus$4(), function (component, simulatedEvent) {\n    var event = simulatedEvent.event;\n    var originator = event.originator;\n    var target = event.target;\n    if (isRecursive(component, originator, target)) {\n      console.warn(focus$4() + ' did not get interpreted by the desired target. ' + '\\nOriginator: ' + element(originator) + '\\nTarget: ' + element(target) + '\\nCheck the ' + focus$4() + ' event handlers');\n      return false;\n    } else {\n      return true;\n    }\n  })]);\n  var DefaultEvents = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    events: events$i\n  });\n  var unique = 0;\n  var generate$6 = function generate$6(prefix) {\n    var date = new Date();\n    var time = date.getTime();\n    var random = Math.floor(Math.random() * 1000000000);\n    unique++;\n    return prefix + '_' + random + unique + String(time);\n  };\n  var prefix$1 = constant$1('alloy-id-');\n  var idAttr$1 = constant$1('data-alloy-id');\n  var prefix = prefix$1();\n  var idAttr = idAttr$1();\n  var write = function write(label, elem) {\n    var id = generate$6(prefix + label);\n    writeOnly(elem, id);\n    return id;\n  };\n  var writeOnly = function writeOnly(elem, uid) {\n    Object.defineProperty(elem.dom, idAttr, {\n      value: uid,\n      writable: true\n    });\n  };\n  var read$1 = function read$1(elem) {\n    var id = isElement$1(elem) ? elem.dom[idAttr] : null;\n    return Optional.from(id);\n  };\n  var generate$5 = function generate$5(prefix) {\n    return generate$6(prefix);\n  };\n  var make$8 = identity;\n  var NoContextApi = function NoContextApi(getComp) {\n    var getMessage = function getMessage(event) {\n      return \"The component must be in a context to execute: \".concat(event) + (getComp ? '\\n' + element(getComp().element) + ' is not in context.' : '');\n    };\n    var fail = function fail(event) {\n      return function () {\n        throw new Error(getMessage(event));\n      };\n    };\n    var warn = function warn(event) {\n      return function () {\n        console.warn(getMessage(event));\n      };\n    };\n    return {\n      debugInfo: constant$1('fake'),\n      triggerEvent: warn('triggerEvent'),\n      triggerFocus: warn('triggerFocus'),\n      triggerEscape: warn('triggerEscape'),\n      broadcast: warn('broadcast'),\n      broadcastOn: warn('broadcastOn'),\n      broadcastEvent: warn('broadcastEvent'),\n      build: fail('build'),\n      buildOrPatch: fail('buildOrPatch'),\n      addToWorld: fail('addToWorld'),\n      removeFromWorld: fail('removeFromWorld'),\n      addToGui: fail('addToGui'),\n      removeFromGui: fail('removeFromGui'),\n      getByUid: fail('getByUid'),\n      getByDom: fail('getByDom'),\n      isConnected: never\n    };\n  };\n  var singleton$1 = NoContextApi();\n  var markAsBehaviourApi = function markAsBehaviourApi(f, apiName, apiFunction) {\n    var delegate = apiFunction.toString();\n    var endIndex = delegate.indexOf(')') + 1;\n    var openBracketIndex = delegate.indexOf('(');\n    var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\\s*/);\n    f.toFunctionAnnotation = function () {\n      return {\n        name: apiName,\n        parameters: cleanParameters(parameters.slice(0, 1).concat(parameters.slice(3)))\n      };\n    };\n    return f;\n  };\n  var cleanParameters = function cleanParameters(parameters) {\n    return map$2(parameters, function (p) {\n      return endsWith(p, '/*') ? p.substring(0, p.length - '/*'.length) : p;\n    });\n  };\n  var markAsExtraApi = function markAsExtraApi(f, extraName) {\n    var delegate = f.toString();\n    var endIndex = delegate.indexOf(')') + 1;\n    var openBracketIndex = delegate.indexOf('(');\n    var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\\s*/);\n    f.toFunctionAnnotation = function () {\n      return {\n        name: extraName,\n        parameters: cleanParameters(parameters)\n      };\n    };\n    return f;\n  };\n  var markAsSketchApi = function markAsSketchApi(f, apiFunction) {\n    var delegate = apiFunction.toString();\n    var endIndex = delegate.indexOf(')') + 1;\n    var openBracketIndex = delegate.indexOf('(');\n    var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\\s*/);\n    f.toFunctionAnnotation = function () {\n      return {\n        name: 'OVERRIDE',\n        parameters: cleanParameters(parameters.slice(1))\n      };\n    };\n    return f;\n  };\n  var premadeTag = generate$6('alloy-premade');\n  var premade$1 = function premade$1(comp) {\n    Object.defineProperty(comp.element.dom, premadeTag, {\n      value: comp.uid,\n      writable: true\n    });\n    return wrap$1(premadeTag, comp);\n  };\n  var isPremade = function isPremade(element) {\n    return has$2(element.dom, premadeTag);\n  };\n  var getPremade = function getPremade(spec) {\n    return get$g(spec, premadeTag);\n  };\n  var makeApi = function makeApi(f) {\n    return markAsSketchApi(function (component) {\n      for (var _len12 = arguments.length, rest = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n        rest[_key12 - 1] = arguments[_key12];\n      }\n      return f.apply(void 0, [component.getApis(), component].concat(rest));\n    }, f);\n  };\n  var NoState = {\n    init: function init() {\n      return nu$8({\n        readState: constant$1('No State required')\n      });\n    }\n  };\n  var nu$8 = function nu$8(spec) {\n    return spec;\n  };\n  var generateFrom$1 = function generateFrom$1(spec, all) {\n    var schema = map$2(all, function (a) {\n      return optionObjOf(a.name(), [required$1('config'), defaulted('state', NoState)]);\n    });\n    var validated = asRaw('component.behaviours', objOf(schema), spec.behaviours).fold(function (errInfo) {\n      throw new Error(formatError(errInfo) + '\\nComplete spec:\\n' + JSON.stringify(spec, null, 2));\n    }, identity);\n    return {\n      list: all,\n      data: map$1(validated, function (optBlobThunk) {\n        var output = optBlobThunk.map(function (blob) {\n          return {\n            config: blob.config,\n            state: blob.state.init(blob.config)\n          };\n        });\n        return constant$1(output);\n      })\n    };\n  };\n  var getBehaviours$3 = function getBehaviours$3(bData) {\n    return bData.list;\n  };\n  var getData$2 = function getData$2(bData) {\n    return bData.data;\n  };\n  var byInnerKey = function byInnerKey(data, tuple) {\n    var r = {};\n    each(data, function (detail, key) {\n      each(detail, function (value, indexKey) {\n        var chain = get$g(r, indexKey).getOr([]);\n        r[indexKey] = chain.concat([tuple(key, value)]);\n      });\n    });\n    return r;\n  };\n  var nu$7 = function nu$7(s) {\n    return {\n      classes: isUndefined(s.classes) ? [] : s.classes,\n      attributes: isUndefined(s.attributes) ? {} : s.attributes,\n      styles: isUndefined(s.styles) ? {} : s.styles\n    };\n  };\n  var merge = function merge(defnA, mod) {\n    return _objectSpread({}, defnA, {\n      attributes: _objectSpread({}, defnA.attributes, mod.attributes),\n      styles: _objectSpread({}, defnA.styles, mod.styles),\n      classes: defnA.classes.concat(mod.classes)\n    });\n  };\n  var combine$2 = function combine$2(info, baseMod, behaviours, base) {\n    var modsByBehaviour = _objectSpread({}, baseMod);\n    each$1(behaviours, function (behaviour) {\n      modsByBehaviour[behaviour.name()] = behaviour.exhibit(info, base);\n    });\n    var byAspect = byInnerKey(modsByBehaviour, function (name, modification) {\n      return {\n        name: name,\n        modification: modification\n      };\n    });\n    var combineObjects = function combineObjects(objects) {\n      return foldr(objects, function (b, a) {\n        return _objectSpread({}, a.modification, b);\n      }, {});\n    };\n    var combinedClasses = foldr(byAspect.classes, function (b, a) {\n      return a.modification.concat(b);\n    }, []);\n    var combinedAttributes = combineObjects(byAspect.attributes);\n    var combinedStyles = combineObjects(byAspect.styles);\n    return nu$7({\n      classes: combinedClasses,\n      attributes: combinedAttributes,\n      styles: combinedStyles\n    });\n  };\n  var sortKeys = function sortKeys(label, keyName, array, order) {\n    try {\n      var sorted = sort(array, function (a, b) {\n        var aKey = a[keyName];\n        var bKey = b[keyName];\n        var aIndex = order.indexOf(aKey);\n        var bIndex = order.indexOf(bKey);\n        if (aIndex === -1) {\n          throw new Error('The ordering for ' + label + ' does not have an entry for ' + aKey + '.\\nOrder specified: ' + JSON.stringify(order, null, 2));\n        }\n        if (bIndex === -1) {\n          throw new Error('The ordering for ' + label + ' does not have an entry for ' + bKey + '.\\nOrder specified: ' + JSON.stringify(order, null, 2));\n        }\n        if (aIndex < bIndex) {\n          return -1;\n        } else if (bIndex < aIndex) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n      return Result.value(sorted);\n    } catch (err) {\n      return Result.error([err]);\n    }\n  };\n  var uncurried = function uncurried(handler, purpose) {\n    return {\n      handler: handler,\n      purpose: purpose\n    };\n  };\n  var curried = function curried(handler, purpose) {\n    return {\n      cHandler: handler,\n      purpose: purpose\n    };\n  };\n  var curryArgs = function curryArgs(descHandler, extraArgs) {\n    return curried(curry.apply(undefined, [descHandler.handler].concat(extraArgs)), descHandler.purpose);\n  };\n  var getCurried = function getCurried(descHandler) {\n    return descHandler.cHandler;\n  };\n  var behaviourTuple = function behaviourTuple(name, handler) {\n    return {\n      name: name,\n      handler: handler\n    };\n  };\n  var nameToHandlers = function nameToHandlers(behaviours, info) {\n    var r = {};\n    each$1(behaviours, function (behaviour) {\n      r[behaviour.name()] = behaviour.handlers(info);\n    });\n    return r;\n  };\n  var groupByEvents = function groupByEvents(info, behaviours, base) {\n    var behaviourEvents = _objectSpread({}, base, nameToHandlers(behaviours, info));\n    return byInnerKey(behaviourEvents, behaviourTuple);\n  };\n  var combine$1 = function combine$1(info, eventOrder, behaviours, base) {\n    var byEventName = groupByEvents(info, behaviours, base);\n    return combineGroups(byEventName, eventOrder);\n  };\n  var assemble = function assemble(rawHandler) {\n    var handler = read$2(rawHandler);\n    return function (component, simulatedEvent) {\n      for (var _len13 = arguments.length, rest = new Array(_len13 > 2 ? _len13 - 2 : 0), _key13 = 2; _key13 < _len13; _key13++) {\n        rest[_key13 - 2] = arguments[_key13];\n      }\n      var args = [component, simulatedEvent].concat(rest);\n      if (handler.abort.apply(undefined, args)) {\n        simulatedEvent.stop();\n      } else if (handler.can.apply(undefined, args)) {\n        handler.run.apply(undefined, args);\n      }\n    };\n  };\n  var missingOrderError = function missingOrderError(eventName, tuples) {\n    return Result.error(['The event (' + eventName + ') has more than one behaviour that listens to it.\\nWhen this occurs, you must ' + 'specify an event ordering for the behaviours in your spec (e.g. [ \"listing\", \"toggling\" ]).\\nThe behaviours that ' + 'can trigger it are: ' + JSON.stringify(map$2(tuples, function (c) {\n      return c.name;\n    }), null, 2)]);\n  };\n  var fuse = function fuse(tuples, eventOrder, eventName) {\n    var order = eventOrder[eventName];\n    if (!order) {\n      return missingOrderError(eventName, tuples);\n    } else {\n      return sortKeys('Event: ' + eventName, 'name', tuples, order).map(function (sortedTuples) {\n        var handlers = map$2(sortedTuples, function (tuple) {\n          return tuple.handler;\n        });\n        return fuse$1(handlers);\n      });\n    }\n  };\n  var combineGroups = function combineGroups(byEventName, eventOrder) {\n    var r = mapToArray(byEventName, function (tuples, eventName) {\n      var combined = tuples.length === 1 ? Result.value(tuples[0].handler) : fuse(tuples, eventOrder, eventName);\n      return combined.map(function (handler) {\n        var assembled = assemble(handler);\n        var purpose = tuples.length > 1 ? filter$2(eventOrder[eventName], function (o) {\n          return exists(tuples, function (t) {\n            return t.name === o;\n          });\n        }).join(' > ') : tuples[0].name;\n        return wrap$1(eventName, uncurried(assembled, purpose));\n      });\n    });\n    return consolidate(r, {});\n  };\n  var baseBehaviour = 'alloy.base.behaviour';\n  var schema$z = objOf([field$1('dom', 'dom', required$2(), objOf([required$1('tag'), defaulted('styles', {}), defaulted('classes', []), defaulted('attributes', {}), option$3('value'), option$3('innerHtml')])), required$1('components'), required$1('uid'), defaulted('events', {}), defaulted('apis', {}), field$1('eventOrder', 'eventOrder', mergeWith((_mergeWith = {}, _defineProperty(_mergeWith, execute$5(), ['disabling', baseBehaviour, 'toggling', 'typeaheadevents']), _defineProperty(_mergeWith, focus$4(), [baseBehaviour, 'focusing', 'keying']), _defineProperty(_mergeWith, systemInit(), [baseBehaviour, 'disabling', 'toggling', 'representing']), _defineProperty(_mergeWith, input(), [baseBehaviour, 'representing', 'streaming', 'invalidating']), _defineProperty(_mergeWith, detachedFromDom(), [baseBehaviour, 'representing', 'item-events', 'tooltipping']), _defineProperty(_mergeWith, mousedown(), ['focusing', baseBehaviour, 'item-type-events']), _defineProperty(_mergeWith, touchstart(), ['focusing', baseBehaviour, 'item-type-events']), _defineProperty(_mergeWith, mouseover(), ['item-type-events', 'tooltipping']), _defineProperty(_mergeWith, receive(), ['receiving', 'reflecting', 'tooltipping']), _mergeWith)), anyValue()), option$3('domModification')]);\n  var toInfo = function toInfo(spec) {\n    return asRaw('custom.definition', schema$z, spec);\n  };\n  var toDefinition = function toDefinition(detail) {\n    return _objectSpread({}, detail.dom, {\n      uid: detail.uid,\n      domChildren: map$2(detail.components, function (comp) {\n        return comp.element;\n      })\n    });\n  };\n  var toModification = function toModification(detail) {\n    return detail.domModification.fold(function () {\n      return nu$7({});\n    }, nu$7);\n  };\n  var toEvents = function toEvents(info) {\n    return info.events;\n  };\n  var read = function read(element, attr) {\n    var value = get$f(element, attr);\n    return value === undefined || value === '' ? [] : value.split(' ');\n  };\n  var add$4 = function add$4(element, attr, id) {\n    var old = read(element, attr);\n    var nu = old.concat([id]);\n    set$9(element, attr, nu.join(' '));\n    return true;\n  };\n  var remove$4 = function remove$4(element, attr, id) {\n    var nu = filter$2(read(element, attr), function (v) {\n      return v !== id;\n    });\n    if (nu.length > 0) {\n      set$9(element, attr, nu.join(' '));\n    } else {\n      remove$7(element, attr);\n    }\n    return false;\n  };\n  var supports = function supports(element) {\n    return element.dom.classList !== undefined;\n  };\n  var get$8 = function get$8(element) {\n    return read(element, 'class');\n  };\n  var add$3 = function add$3(element, clazz) {\n    return add$4(element, 'class', clazz);\n  };\n  var remove$3 = function remove$3(element, clazz) {\n    return remove$4(element, 'class', clazz);\n  };\n  var toggle$5 = function toggle$5(element, clazz) {\n    if (contains$2(get$8(element), clazz)) {\n      return remove$3(element, clazz);\n    } else {\n      return add$3(element, clazz);\n    }\n  };\n  var add$2 = function add$2(element, clazz) {\n    if (supports(element)) {\n      element.dom.classList.add(clazz);\n    } else {\n      add$3(element, clazz);\n    }\n  };\n  var cleanClass = function cleanClass(element) {\n    var classList = supports(element) ? element.dom.classList : get$8(element);\n    if (classList.length === 0) {\n      remove$7(element, 'class');\n    }\n  };\n  var remove$2 = function remove$2(element, clazz) {\n    if (supports(element)) {\n      var classList = element.dom.classList;\n      classList.remove(clazz);\n    } else {\n      remove$3(element, clazz);\n    }\n    cleanClass(element);\n  };\n  var toggle$4 = function toggle$4(element, clazz) {\n    var result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$5(element, clazz);\n    cleanClass(element);\n    return result;\n  };\n  var has = function has(element, clazz) {\n    return supports(element) && element.dom.classList.contains(clazz);\n  };\n  var add$1 = function add$1(element, classes) {\n    each$1(classes, function (x) {\n      add$2(element, x);\n    });\n  };\n  var remove$1 = function remove$1(element, classes) {\n    each$1(classes, function (x) {\n      remove$2(element, x);\n    });\n  };\n  var toggle$3 = function toggle$3(element, classes) {\n    each$1(classes, function (x) {\n      toggle$4(element, x);\n    });\n  };\n  var hasAll = function hasAll(element, classes) {\n    return forall(classes, function (clazz) {\n      return has(element, clazz);\n    });\n  };\n  var getNative = function getNative(element) {\n    var classList = element.dom.classList;\n    var r = new Array(classList.length);\n    for (var i = 0; i < classList.length; i++) {\n      var _item2 = classList.item(i);\n      if (_item2 !== null) {\n        r[i] = _item2;\n      }\n    }\n    return r;\n  };\n  var get$7 = function get$7(element) {\n    return supports(element) ? getNative(element) : get$8(element);\n  };\n  var get$6 = function get$6(element) {\n    return element.dom.value;\n  };\n  var set$5 = function set$5(element, value) {\n    if (value === undefined) {\n      throw new Error('Value.set was undefined');\n    }\n    element.dom.value = value;\n  };\n  var determineObsoleted = function determineObsoleted(parent, index, oldObsoleted) {\n    var newObsoleted = child$2(parent, index);\n    return newObsoleted.map(function (newObs) {\n      var elemChanged = oldObsoleted.exists(function (o) {\n        return !eq(o, newObs);\n      });\n      if (elemChanged) {\n        var oldTag = oldObsoleted.map(name$3).getOr('span');\n        var marker = SugarElement.fromTag(oldTag);\n        before$1(newObs, marker);\n        return marker;\n      } else {\n        return newObs;\n      }\n    });\n  };\n  var ensureInDom = function ensureInDom(parent, child, obsoleted) {\n    obsoleted.fold(function () {\n      return append$2(parent, child);\n    }, function (obs) {\n      if (!eq(obs, child)) {\n        before$1(obs, child);\n        remove$5(obs);\n      }\n    });\n  };\n  var patchChildrenWith = function patchChildrenWith(parent, nu, f) {\n    var builtChildren = map$2(nu, f);\n    var currentChildren = children(parent);\n    each$1(currentChildren.slice(builtChildren.length), remove$5);\n    return builtChildren;\n  };\n  var patchSpecChild = function patchSpecChild(parent, index, spec, build) {\n    var oldObsoleted = child$2(parent, index);\n    var childComp = build(spec, oldObsoleted);\n    var obsoleted = determineObsoleted(parent, index, oldObsoleted);\n    ensureInDom(parent, childComp.element, obsoleted);\n    return childComp;\n  };\n  var patchSpecChildren = function patchSpecChildren(parent, specs, build) {\n    return patchChildrenWith(parent, specs, function (spec, index) {\n      return patchSpecChild(parent, index, spec, build);\n    });\n  };\n  var patchDomChildren = function patchDomChildren(parent, nodes) {\n    return patchChildrenWith(parent, nodes, function (node, index) {\n      var optObsoleted = child$2(parent, index);\n      ensureInDom(parent, node, optObsoleted);\n      return node;\n    });\n  };\n  var diffKeyValueSet = function diffKeyValueSet(newObj, oldObj) {\n    var newKeys = keys(newObj);\n    var oldKeys = keys(oldObj);\n    var toRemove = difference(oldKeys, newKeys);\n    var toSet = bifilter(newObj, function (v, k) {\n      return !has$2(oldObj, k) || v !== oldObj[k];\n    }).t;\n    return {\n      toRemove: toRemove,\n      toSet: toSet\n    };\n  };\n  var reconcileToDom = function reconcileToDom(definition, obsoleted) {\n    var _clone$ = clone$2(obsoleted),\n      clazz = _clone$.class,\n      style = _clone$.style,\n      existingAttributes = _objectWithoutProperties(_clone$, [\"class\", \"style\"]);\n    var _diffKeyValueSet = diffKeyValueSet(definition.attributes, existingAttributes),\n      attrsToSet = _diffKeyValueSet.toSet,\n      attrsToRemove = _diffKeyValueSet.toRemove;\n    var updateAttrs = function updateAttrs() {\n      each$1(attrsToRemove, function (a) {\n        return remove$7(obsoleted, a);\n      });\n      setAll$1(obsoleted, attrsToSet);\n    };\n    var existingStyles = getAllRaw(obsoleted);\n    var _diffKeyValueSet2 = diffKeyValueSet(definition.styles, existingStyles),\n      stylesToSet = _diffKeyValueSet2.toSet,\n      stylesToRemove = _diffKeyValueSet2.toRemove;\n    var updateStyles = function updateStyles() {\n      each$1(stylesToRemove, function (s) {\n        return remove$6(obsoleted, s);\n      });\n      setAll(obsoleted, stylesToSet);\n    };\n    var existingClasses = get$7(obsoleted);\n    var classesToRemove = difference(existingClasses, definition.classes);\n    var classesToAdd = difference(definition.classes, existingClasses);\n    var updateClasses = function updateClasses() {\n      add$1(obsoleted, classesToAdd);\n      remove$1(obsoleted, classesToRemove);\n    };\n    var updateHtml = function updateHtml(html) {\n      set$6(obsoleted, html);\n    };\n    var updateChildren = function updateChildren() {\n      var children = definition.domChildren;\n      patchDomChildren(obsoleted, children);\n    };\n    var updateValue = function updateValue() {\n      var valueElement = obsoleted;\n      var value = definition.value.getOrUndefined();\n      if (value !== get$6(valueElement)) {\n        set$5(valueElement, value !== null && value !== void 0 ? value : '');\n      }\n    };\n    updateAttrs();\n    updateClasses();\n    updateStyles();\n    definition.innerHtml.fold(updateChildren, updateHtml);\n    updateValue();\n    return obsoleted;\n  };\n  var introduceToDom = function introduceToDom(definition) {\n    var subject = SugarElement.fromTag(definition.tag);\n    setAll$1(subject, definition.attributes);\n    add$1(subject, definition.classes);\n    setAll(subject, definition.styles);\n    definition.innerHtml.each(function (html) {\n      return set$6(subject, html);\n    });\n    var children = definition.domChildren;\n    append$1(subject, children);\n    definition.value.each(function (value) {\n      set$5(subject, value);\n    });\n    return subject;\n  };\n  var attemptPatch = function attemptPatch(definition, obsoleted) {\n    try {\n      var e = reconcileToDom(definition, obsoleted);\n      return Optional.some(e);\n    } catch (err) {\n      return Optional.none();\n    }\n  };\n  var hasMixedChildren = function hasMixedChildren(definition) {\n    return definition.innerHtml.isSome() && definition.domChildren.length > 0;\n  };\n  var renderToDom = function renderToDom(definition, optObsoleted) {\n    var canBePatched = function canBePatched(candidate) {\n      return name$3(candidate) === definition.tag && !hasMixedChildren(definition) && !isPremade(candidate);\n    };\n    var elem = optObsoleted.filter(canBePatched).bind(function (obsoleted) {\n      return attemptPatch(definition, obsoleted);\n    }).getOrThunk(function () {\n      return introduceToDom(definition);\n    });\n    writeOnly(elem, definition.uid);\n    return elem;\n  };\n  var getBehaviours$2 = function getBehaviours$2(spec) {\n    var behaviours = get$g(spec, 'behaviours').getOr({});\n    return bind$3(keys(behaviours), function (name) {\n      var behaviour = behaviours[name];\n      return isNonNullable(behaviour) ? [behaviour.me] : [];\n    });\n  };\n  var generateFrom = function generateFrom(spec, all) {\n    return generateFrom$1(spec, all);\n  };\n  var generate$4 = function generate$4(spec) {\n    var all = getBehaviours$2(spec);\n    return generateFrom(spec, all);\n  };\n  var getDomDefinition = function getDomDefinition(info, bList, bData) {\n    var definition = toDefinition(info);\n    var infoModification = toModification(info);\n    var baseModification = {\n      'alloy.base.modification': infoModification\n    };\n    var modification = bList.length > 0 ? combine$2(bData, baseModification, bList, definition) : infoModification;\n    return merge(definition, modification);\n  };\n  var getEvents = function getEvents(info, bList, bData) {\n    var baseEvents = {\n      'alloy.base.behaviour': toEvents(info)\n    };\n    return combine$1(bData, info.eventOrder, bList, baseEvents).getOrDie();\n  };\n  var build$2 = function build$2(spec, obsoleted) {\n    var getMe = function getMe() {\n      return me;\n    };\n    var systemApi = Cell(singleton$1);\n    var info = getOrDie(toInfo(spec));\n    var bBlob = generate$4(spec);\n    var bList = getBehaviours$3(bBlob);\n    var bData = getData$2(bBlob);\n    var modDefinition = getDomDefinition(info, bList, bData);\n    var item = renderToDom(modDefinition, obsoleted);\n    var events = getEvents(info, bList, bData);\n    var subcomponents = Cell(info.components);\n    var connect = function connect(newApi) {\n      systemApi.set(newApi);\n    };\n    var disconnect = function disconnect() {\n      systemApi.set(NoContextApi(getMe));\n    };\n    var syncComponents = function syncComponents() {\n      var children$1 = children(item);\n      var subs = bind$3(children$1, function (child) {\n        return systemApi.get().getByDom(child).fold(function () {\n          return [];\n        }, pure$2);\n      });\n      subcomponents.set(subs);\n    };\n    var config = function config(behaviour) {\n      var b = bData;\n      var f = isFunction(b[behaviour.name()]) ? b[behaviour.name()] : function () {\n        throw new Error('Could not find ' + behaviour.name() + ' in ' + JSON.stringify(spec, null, 2));\n      };\n      return f();\n    };\n    var hasConfigured = function hasConfigured(behaviour) {\n      return isFunction(bData[behaviour.name()]);\n    };\n    var getApis = function getApis() {\n      return info.apis;\n    };\n    var readState = function readState(behaviourName) {\n      return bData[behaviourName]().map(function (b) {\n        return b.state.readState();\n      }).getOr('not enabled');\n    };\n    var me = {\n      uid: spec.uid,\n      getSystem: systemApi.get,\n      config: config,\n      hasConfigured: hasConfigured,\n      spec: spec,\n      readState: readState,\n      getApis: getApis,\n      connect: connect,\n      disconnect: disconnect,\n      element: item,\n      syncComponents: syncComponents,\n      components: subcomponents.get,\n      events: events\n    };\n    return me;\n  };\n  var buildSubcomponents = function buildSubcomponents(spec, obsoleted) {\n    var components = get$g(spec, 'components').getOr([]);\n    return obsoleted.fold(function () {\n      return map$2(components, build$1);\n    }, function (obs) {\n      return map$2(components, function (c, i) {\n        return buildOrPatch(c, child$2(obs, i));\n      });\n    });\n  };\n  var buildFromSpec = function buildFromSpec(userSpec, obsoleted) {\n    var _make$ = make$8(userSpec),\n      specEvents = _make$.events,\n      spec = _objectWithoutProperties(_make$, [\"events\"]);\n    var components = buildSubcomponents(spec, obsoleted);\n    var completeSpec = _objectSpread({}, spec, {\n      events: _objectSpread({}, DefaultEvents, specEvents),\n      components: components\n    });\n    return Result.value(build$2(completeSpec, obsoleted));\n  };\n  var text$2 = function text$2(textContent) {\n    var element = SugarElement.fromText(textContent);\n    return external$1({\n      element: element\n    });\n  };\n  var external$1 = function external$1(spec) {\n    var extSpec = asRawOrDie$1('external.component', objOfOnly([required$1('element'), option$3('uid')]), spec);\n    var systemApi = Cell(NoContextApi());\n    var connect = function connect(newApi) {\n      systemApi.set(newApi);\n    };\n    var disconnect = function disconnect() {\n      systemApi.set(NoContextApi(function () {\n        return me;\n      }));\n    };\n    var uid = extSpec.uid.getOrThunk(function () {\n      return generate$5('external');\n    });\n    writeOnly(extSpec.element, uid);\n    var me = {\n      uid: uid,\n      getSystem: systemApi.get,\n      config: Optional.none,\n      hasConfigured: never,\n      connect: connect,\n      disconnect: disconnect,\n      getApis: function getApis() {\n        return {};\n      },\n      element: extSpec.element,\n      spec: spec,\n      readState: constant$1('No state'),\n      syncComponents: noop,\n      components: constant$1([]),\n      events: {}\n    };\n    return premade$1(me);\n  };\n  var uids = generate$5;\n  var isSketchSpec$1 = function isSketchSpec$1(spec) {\n    return has$2(spec, 'uid');\n  };\n  var buildOrPatch = function buildOrPatch(spec, obsoleted) {\n    return getPremade(spec).getOrThunk(function () {\n      var userSpecWithUid = isSketchSpec$1(spec) ? spec : _objectSpread({\n        uid: uids('')\n      }, spec);\n      return buildFromSpec(userSpecWithUid, obsoleted).getOrDie();\n    });\n  };\n  var build$1 = function build$1(spec) {\n    return buildOrPatch(spec, Optional.none());\n  };\n  var premade = premade$1;\n  var ClosestOrAncestor = function ClosestOrAncestor(is, ancestor, scope, a, isRoot) {\n    if (is(scope, a)) {\n      return Optional.some(scope);\n    } else if (isFunction(isRoot) && isRoot(scope)) {\n      return Optional.none();\n    } else {\n      return ancestor(scope, a, isRoot);\n    }\n  };\n  var ancestor$1 = function ancestor$1(scope, predicate, isRoot) {\n    var element = scope.dom;\n    var stop = isFunction(isRoot) ? isRoot : never;\n    while (element.parentNode) {\n      element = element.parentNode;\n      var el = SugarElement.fromDom(element);\n      if (predicate(el)) {\n        return Optional.some(el);\n      } else if (stop(el)) {\n        break;\n      }\n    }\n    return Optional.none();\n  };\n  var closest$3 = function closest$3(scope, predicate, isRoot) {\n    var is = function is(s, test) {\n      return test(s);\n    };\n    return ClosestOrAncestor(is, ancestor$1, scope, predicate, isRoot);\n  };\n  var child$1 = function child$1(scope, predicate) {\n    var pred = function pred(node) {\n      return predicate(SugarElement.fromDom(node));\n    };\n    var result = find$5(scope.dom.childNodes, pred);\n    return result.map(SugarElement.fromDom);\n  };\n  var descendant$1 = function descendant$1(scope, predicate) {\n    var descend = function descend(node) {\n      for (var i = 0; i < node.childNodes.length; i++) {\n        var _child = SugarElement.fromDom(node.childNodes[i]);\n        if (predicate(_child)) {\n          return Optional.some(_child);\n        }\n        var res = descend(node.childNodes[i]);\n        if (res.isSome()) {\n          return res;\n        }\n      }\n      return Optional.none();\n    };\n    return descend(scope.dom);\n  };\n  var closest$2 = function closest$2(scope, predicate, isRoot) {\n    return closest$3(scope, predicate, isRoot).isSome();\n  };\n  var ancestor = function ancestor(scope, selector, isRoot) {\n    return ancestor$1(scope, function (e) {\n      return is(e, selector);\n    }, isRoot);\n  };\n  var child = function child(scope, selector) {\n    return child$1(scope, function (e) {\n      return is(e, selector);\n    });\n  };\n  var descendant = function descendant(scope, selector) {\n    return one(selector, scope);\n  };\n  var closest$1 = function closest$1(scope, selector, isRoot) {\n    var is$1 = function is$1(element, selector) {\n      return is(element, selector);\n    };\n    return ClosestOrAncestor(is$1, ancestor, scope, selector, isRoot);\n  };\n  var attribute = 'aria-controls';\n  var find$1 = function find$1(queryElem) {\n    var dependent = closest$3(queryElem, function (elem) {\n      if (!isElement$1(elem)) {\n        return false;\n      }\n      var id = get$f(elem, 'id');\n      return id !== undefined && id.indexOf(attribute) > -1;\n    });\n    return dependent.bind(function (dep) {\n      var id = get$f(dep, 'id');\n      var dos = getRootNode(dep);\n      return descendant(dos, \"[\".concat(attribute, \"=\\\"\").concat(id, \"\\\"]\"));\n    });\n  };\n  var manager = function manager() {\n    var ariaId = generate$6(attribute);\n    var link = function link(elem) {\n      set$9(elem, attribute, ariaId);\n    };\n    var unlink = function unlink(elem) {\n      remove$7(elem, attribute);\n    };\n    return {\n      id: ariaId,\n      link: link,\n      unlink: unlink\n    };\n  };\n  var isAriaPartOf = function isAriaPartOf(component, queryElem) {\n    return find$1(queryElem).exists(function (owner) {\n      return isPartOf$1(component, owner);\n    });\n  };\n  var isPartOf$1 = function isPartOf$1(component, queryElem) {\n    return closest$2(queryElem, function (el) {\n      return eq(el, component.element);\n    }, never) || isAriaPartOf(component, queryElem);\n  };\n  var unknown = 'unknown';\n  var EventConfiguration;\n  (function (EventConfiguration) {\n    EventConfiguration[EventConfiguration['STOP'] = 0] = 'STOP';\n    EventConfiguration[EventConfiguration['NORMAL'] = 1] = 'NORMAL';\n    EventConfiguration[EventConfiguration['LOGGING'] = 2] = 'LOGGING';\n  })(EventConfiguration || (EventConfiguration = {}));\n  var eventConfig = Cell({});\n  var makeEventLogger = function makeEventLogger(eventName, initialTarget) {\n    var sequence = [];\n    var startTime = new Date().getTime();\n    return {\n      logEventCut: function logEventCut(_name, target, purpose) {\n        sequence.push({\n          outcome: 'cut',\n          target: target,\n          purpose: purpose\n        });\n      },\n      logEventStopped: function logEventStopped(_name, target, purpose) {\n        sequence.push({\n          outcome: 'stopped',\n          target: target,\n          purpose: purpose\n        });\n      },\n      logNoParent: function logNoParent(_name, target, purpose) {\n        sequence.push({\n          outcome: 'no-parent',\n          target: target,\n          purpose: purpose\n        });\n      },\n      logEventNoHandlers: function logEventNoHandlers(_name, target) {\n        sequence.push({\n          outcome: 'no-handlers-left',\n          target: target\n        });\n      },\n      logEventResponse: function logEventResponse(_name, target, purpose) {\n        sequence.push({\n          outcome: 'response',\n          purpose: purpose,\n          target: target\n        });\n      },\n      write: function write() {\n        var finishTime = new Date().getTime();\n        if (contains$2(['mousemove', 'mouseover', 'mouseout', systemInit()], eventName)) {\n          return;\n        }\n        console.log(eventName, {\n          event: eventName,\n          time: finishTime - startTime,\n          target: initialTarget.dom,\n          sequence: map$2(sequence, function (s) {\n            if (!contains$2(['cut', 'stopped', 'response'], s.outcome)) {\n              return s.outcome;\n            } else {\n              return '{' + s.purpose + '} ' + s.outcome + ' at (' + element(s.target) + ')';\n            }\n          })\n        });\n      }\n    };\n  };\n  var processEvent = function processEvent(eventName, initialTarget, f) {\n    var status = get$g(eventConfig.get(), eventName).orThunk(function () {\n      var patterns = keys(eventConfig.get());\n      return findMap(patterns, function (p) {\n        return eventName.indexOf(p) > -1 ? Optional.some(eventConfig.get()[p]) : Optional.none();\n      });\n    }).getOr(EventConfiguration.NORMAL);\n    switch (status) {\n      case EventConfiguration.NORMAL:\n        return f(noLogger());\n      case EventConfiguration.LOGGING:\n        {\n          var logger = makeEventLogger(eventName, initialTarget);\n          var _output = f(logger);\n          logger.write();\n          return _output;\n        }\n      case EventConfiguration.STOP:\n        return true;\n    }\n  };\n  var path = ['alloy/data/Fields', 'alloy/debugging/Debugging'];\n  var getTrace = function getTrace() {\n    var err = new Error();\n    if (err.stack !== undefined) {\n      var lines = err.stack.split('\\n');\n      return find$5(lines, function (line) {\n        return line.indexOf('alloy') > 0 && !exists(path, function (p) {\n          return line.indexOf(p) > -1;\n        });\n      }).getOr(unknown);\n    } else {\n      return unknown;\n    }\n  };\n  var ignoreEvent = {\n    logEventCut: noop,\n    logEventStopped: noop,\n    logNoParent: noop,\n    logEventNoHandlers: noop,\n    logEventResponse: noop,\n    write: noop\n  };\n  var monitorEvent = function monitorEvent(eventName, initialTarget, f) {\n    return processEvent(eventName, initialTarget, f);\n  };\n  var noLogger = constant$1(ignoreEvent);\n  var menuFields = constant$1([required$1('menu'), required$1('selectedMenu')]);\n  var itemFields = constant$1([required$1('item'), required$1('selectedItem')]);\n  constant$1(objOf(itemFields().concat(menuFields())));\n  var itemSchema$3 = constant$1(objOf(itemFields()));\n  var _initSize = requiredObjOf('initSize', [required$1('numColumns'), required$1('numRows')]);\n  var itemMarkers = function itemMarkers() {\n    return requiredOf('markers', itemSchema$3());\n  };\n  var tieredMenuMarkers = function tieredMenuMarkers() {\n    return requiredObjOf('markers', [required$1('backgroundMenu')].concat(menuFields()).concat(itemFields()));\n  };\n  var markers$1 = function markers$1(required) {\n    return requiredObjOf('markers', map$2(required, required$1));\n  };\n  var onPresenceHandler = function onPresenceHandler(label, fieldName, presence) {\n    getTrace();\n    return field$1(fieldName, fieldName, presence, valueOf(function (f) {\n      return Result.value(function () {\n        for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n          args[_key14] = arguments[_key14];\n        }\n        return f.apply(undefined, args);\n      });\n    }));\n  };\n  var onHandler = function onHandler(fieldName) {\n    return onPresenceHandler('onHandler', fieldName, defaulted$1(noop));\n  };\n  var onKeyboardHandler = function onKeyboardHandler(fieldName) {\n    return onPresenceHandler('onKeyboardHandler', fieldName, defaulted$1(Optional.none));\n  };\n  var onStrictHandler = function onStrictHandler(fieldName) {\n    return onPresenceHandler('onHandler', fieldName, required$2());\n  };\n  var onStrictKeyboardHandler = function onStrictKeyboardHandler(fieldName) {\n    return onPresenceHandler('onKeyboardHandler', fieldName, required$2());\n  };\n  var output$1 = function output$1(name, value) {\n    return customField(name, constant$1(value));\n  };\n  var snapshot = function snapshot(name) {\n    return customField(name, identity);\n  };\n  var initSize = constant$1(_initSize);\n  var nu$6 = function nu$6(x, y, bubble, direction, placement, boundsRestriction, labelPrefix) {\n    var alwaysFit = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n    return {\n      x: x,\n      y: y,\n      bubble: bubble,\n      direction: direction,\n      placement: placement,\n      restriction: boundsRestriction,\n      label: \"\".concat(labelPrefix, \"-\").concat(placement),\n      alwaysFit: alwaysFit\n    };\n  };\n  var adt$a = Adt.generate([{\n    southeast: []\n  }, {\n    southwest: []\n  }, {\n    northeast: []\n  }, {\n    northwest: []\n  }, {\n    south: []\n  }, {\n    north: []\n  }, {\n    east: []\n  }, {\n    west: []\n  }]);\n  var cata$2 = function cata$2(subject, southeast, southwest, northeast, northwest, south, north, east, west) {\n    return subject.fold(southeast, southwest, northeast, northwest, south, north, east, west);\n  };\n  var cataVertical = function cataVertical(subject, south, middle, north) {\n    return subject.fold(south, south, north, north, south, north, middle, middle);\n  };\n  var cataHorizontal = function cataHorizontal(subject, east, middle, west) {\n    return subject.fold(east, west, east, west, middle, middle, east, west);\n  };\n  var southeast$3 = adt$a.southeast;\n  var southwest$3 = adt$a.southwest;\n  var northeast$3 = adt$a.northeast;\n  var northwest$3 = adt$a.northwest;\n  var south$3 = adt$a.south;\n  var north$3 = adt$a.north;\n  var east$3 = adt$a.east;\n  var west$3 = adt$a.west;\n  var cycleBy = function cycleBy(value, delta, min, max) {\n    var r = value + delta;\n    if (r > max) {\n      return min;\n    } else if (r < min) {\n      return max;\n    } else {\n      return r;\n    }\n  };\n  var clamp = function clamp(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n  };\n  var getRestriction = function getRestriction(anchor, restriction) {\n    switch (restriction) {\n      case 1:\n        return anchor.x;\n      case 0:\n        return anchor.x + anchor.width;\n      case 2:\n        return anchor.y;\n      case 3:\n        return anchor.y + anchor.height;\n    }\n  };\n  var boundsRestriction = function boundsRestriction(anchor, restrictions) {\n    return mapToObject(['left', 'right', 'top', 'bottom'], function (dir) {\n      return get$g(restrictions, dir).map(function (restriction) {\n        return getRestriction(anchor, restriction);\n      });\n    });\n  };\n  var adjustBounds = function adjustBounds(bounds$1, restriction, bubbleOffset) {\n    var applyRestriction = function applyRestriction(dir, current) {\n      return restriction[dir].map(function (pos) {\n        var isVerticalAxis = dir === 'top' || dir === 'bottom';\n        var offset = isVerticalAxis ? bubbleOffset.top : bubbleOffset.left;\n        var comparator = dir === 'left' || dir === 'top' ? Math.max : Math.min;\n        var newPos = comparator(pos, current) + offset;\n        return isVerticalAxis ? clamp(newPos, bounds$1.y, bounds$1.bottom) : clamp(newPos, bounds$1.x, bounds$1.right);\n      }).getOr(current);\n    };\n    var adjustedLeft = applyRestriction('left', bounds$1.x);\n    var adjustedTop = applyRestriction('top', bounds$1.y);\n    var adjustedRight = applyRestriction('right', bounds$1.right);\n    var adjustedBottom = applyRestriction('bottom', bounds$1.bottom);\n    return bounds(adjustedLeft, adjustedTop, adjustedRight - adjustedLeft, adjustedBottom - adjustedTop);\n  };\n  var labelPrefix$2 = 'layout';\n  var eastX$1 = function eastX$1(anchor) {\n    return anchor.x;\n  };\n  var middleX$1 = function middleX$1(anchor, element) {\n    return anchor.x + anchor.width / 2 - element.width / 2;\n  };\n  var westX$1 = function westX$1(anchor, element) {\n    return anchor.x + anchor.width - element.width;\n  };\n  var northY$2 = function northY$2(anchor, element) {\n    return anchor.y - element.height;\n  };\n  var southY$2 = function southY$2(anchor) {\n    return anchor.y + anchor.height;\n  };\n  var centreY$1 = function centreY$1(anchor, element) {\n    return anchor.y + anchor.height / 2 - element.height / 2;\n  };\n  var eastEdgeX$1 = function eastEdgeX$1(anchor) {\n    return anchor.x + anchor.width;\n  };\n  var westEdgeX$1 = function westEdgeX$1(anchor, element) {\n    return anchor.x - element.width;\n  };\n  var southeast$2 = function southeast$2(anchor, element, bubbles) {\n    return nu$6(eastX$1(anchor), southY$2(anchor), bubbles.southeast(), southeast$3(), 'southeast', boundsRestriction(anchor, {\n      left: 1,\n      top: 3\n    }), labelPrefix$2);\n  };\n  var southwest$2 = function southwest$2(anchor, element, bubbles) {\n    return nu$6(westX$1(anchor, element), southY$2(anchor), bubbles.southwest(), southwest$3(), 'southwest', boundsRestriction(anchor, {\n      right: 0,\n      top: 3\n    }), labelPrefix$2);\n  };\n  var northeast$2 = function northeast$2(anchor, element, bubbles) {\n    return nu$6(eastX$1(anchor), northY$2(anchor, element), bubbles.northeast(), northeast$3(), 'northeast', boundsRestriction(anchor, {\n      left: 1,\n      bottom: 2\n    }), labelPrefix$2);\n  };\n  var northwest$2 = function northwest$2(anchor, element, bubbles) {\n    return nu$6(westX$1(anchor, element), northY$2(anchor, element), bubbles.northwest(), northwest$3(), 'northwest', boundsRestriction(anchor, {\n      right: 0,\n      bottom: 2\n    }), labelPrefix$2);\n  };\n  var north$2 = function north$2(anchor, element, bubbles) {\n    return nu$6(middleX$1(anchor, element), northY$2(anchor, element), bubbles.north(), north$3(), 'north', boundsRestriction(anchor, {\n      bottom: 2\n    }), labelPrefix$2);\n  };\n  var south$2 = function south$2(anchor, element, bubbles) {\n    return nu$6(middleX$1(anchor, element), southY$2(anchor), bubbles.south(), south$3(), 'south', boundsRestriction(anchor, {\n      top: 3\n    }), labelPrefix$2);\n  };\n  var east$2 = function east$2(anchor, element, bubbles) {\n    return nu$6(eastEdgeX$1(anchor), centreY$1(anchor, element), bubbles.east(), east$3(), 'east', boundsRestriction(anchor, {\n      left: 0\n    }), labelPrefix$2);\n  };\n  var west$2 = function west$2(anchor, element, bubbles) {\n    return nu$6(westEdgeX$1(anchor, element), centreY$1(anchor, element), bubbles.west(), west$3(), 'west', boundsRestriction(anchor, {\n      right: 1\n    }), labelPrefix$2);\n  };\n  var all$1 = function all$1() {\n    return [southeast$2, southwest$2, northeast$2, northwest$2, south$2, north$2, east$2, west$2];\n  };\n  var allRtl$1 = function allRtl$1() {\n    return [southwest$2, southeast$2, northwest$2, northeast$2, south$2, north$2, east$2, west$2];\n  };\n  var aboveOrBelow = function aboveOrBelow() {\n    return [northeast$2, northwest$2, southeast$2, southwest$2, north$2, south$2];\n  };\n  var aboveOrBelowRtl = function aboveOrBelowRtl() {\n    return [northwest$2, northeast$2, southwest$2, southeast$2, north$2, south$2];\n  };\n  var belowOrAbove = function belowOrAbove() {\n    return [southeast$2, southwest$2, northeast$2, northwest$2, south$2, north$2];\n  };\n  var belowOrAboveRtl = function belowOrAboveRtl() {\n    return [southwest$2, southeast$2, northwest$2, northeast$2, south$2, north$2];\n  };\n  var chooseChannels = function chooseChannels(channels, message) {\n    return message.universal ? channels : filter$2(channels, function (ch) {\n      return contains$2(message.channels, ch);\n    });\n  };\n  var events$h = function events$h(receiveConfig) {\n    return derive$2([run$1(receive(), function (component, message) {\n      var channelMap = receiveConfig.channels;\n      var channels = keys(channelMap);\n      var receivingData = message;\n      var targetChannels = chooseChannels(channels, receivingData);\n      each$1(targetChannels, function (ch) {\n        var channelInfo = channelMap[ch];\n        var channelSchema = channelInfo.schema;\n        var data = asRawOrDie$1('channel[' + ch + '] data\\nReceiver: ' + element(component.element), channelSchema, receivingData.data);\n        channelInfo.onReceive(component, data);\n      });\n    })]);\n  };\n  var ActiveReceiving = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    events: events$h\n  });\n  var ReceivingSchema = [requiredOf('channels', setOf(Result.value, objOfOnly([onStrictHandler('onReceive'), defaulted('schema', anyValue())])))];\n  var executeEvent = function executeEvent(bConfig, bState, executor) {\n    return runOnExecute$1(function (component) {\n      executor(component, bConfig, bState);\n    });\n  };\n  var loadEvent = function loadEvent(bConfig, bState, f) {\n    return runOnInit(function (component, _simulatedEvent) {\n      f(component, bConfig, bState);\n    });\n  };\n  var create$5 = function create$5(schema, name, active, apis, extra, state) {\n    var configSchema = objOfOnly(schema);\n    var schemaSchema = optionObjOf(name, [optionObjOfOnly('config', schema)]);\n    return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);\n  };\n  var createModes$1 = function createModes$1(modes, name, active, apis, extra, state) {\n    var configSchema = modes;\n    var schemaSchema = optionObjOf(name, [optionOf('config', modes)]);\n    return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);\n  };\n  var wrapApi = function wrapApi(bName, apiFunction, apiName) {\n    var f = function f(component) {\n      for (var _len15 = arguments.length, rest = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {\n        rest[_key15 - 1] = arguments[_key15];\n      }\n      var args = [component].concat(rest);\n      return component.config({\n        name: constant$1(bName)\n      }).fold(function () {\n        throw new Error('We could not find any behaviour configuration for: ' + bName + '. Using API: ' + apiName);\n      }, function (info) {\n        var rest = Array.prototype.slice.call(args, 1);\n        return apiFunction.apply(undefined, [component, info.config, info.state].concat(rest));\n      });\n    };\n    return markAsBehaviourApi(f, apiName, apiFunction);\n  };\n  var revokeBehaviour = function revokeBehaviour(name) {\n    return {\n      key: name,\n      value: undefined\n    };\n  };\n  var doCreate = function doCreate(configSchema, schemaSchema, name, active, apis, extra, state) {\n    var getConfig = function getConfig(info) {\n      return hasNonNullableKey(info, name) ? info[name]() : Optional.none();\n    };\n    var wrappedApis = map$1(apis, function (apiF, apiName) {\n      return wrapApi(name, apiF, apiName);\n    });\n    var wrappedExtra = map$1(extra, function (extraF, extraName) {\n      return markAsExtraApi(extraF, extraName);\n    });\n    var me = _objectSpread({}, wrappedExtra, wrappedApis, {\n      revoke: curry(revokeBehaviour, name),\n      config: function config(spec) {\n        var prepared = asRawOrDie$1(name + '-config', configSchema, spec);\n        return {\n          key: name,\n          value: {\n            config: prepared,\n            me: me,\n            configAsRaw: cached(function () {\n              return asRawOrDie$1(name + '-config', configSchema, spec);\n            }),\n            initialConfig: spec,\n            state: state\n          }\n        };\n      },\n      schema: constant$1(schemaSchema),\n      exhibit: function exhibit(info, base) {\n        return lift2(getConfig(info), get$g(active, 'exhibit'), function (behaviourInfo, exhibitor) {\n          return exhibitor(base, behaviourInfo.config, behaviourInfo.state);\n        }).getOrThunk(function () {\n          return nu$7({});\n        });\n      },\n      name: constant$1(name),\n      handlers: function handlers(info) {\n        return getConfig(info).map(function (behaviourInfo) {\n          var getEvents = get$g(active, 'events').getOr(function () {\n            return {};\n          });\n          return getEvents(behaviourInfo.config, behaviourInfo.state);\n        }).getOr({});\n      }\n    });\n    return me;\n  };\n  var derive$1 = function derive$1(capabilities) {\n    return wrapAll(capabilities);\n  };\n  var simpleSchema = objOfOnly([required$1('fields'), required$1('name'), defaulted('active', {}), defaulted('apis', {}), defaulted('state', NoState), defaulted('extra', {})]);\n  var create$4 = function create$4(data) {\n    var value = asRawOrDie$1('Creating behaviour: ' + data.name, simpleSchema, data);\n    return create$5(value.fields, value.name, value.active, value.apis, value.extra, value.state);\n  };\n  var modeSchema = objOfOnly([required$1('branchKey'), required$1('branches'), required$1('name'), defaulted('active', {}), defaulted('apis', {}), defaulted('state', NoState), defaulted('extra', {})]);\n  var createModes = function createModes(data) {\n    var value = asRawOrDie$1('Creating behaviour: ' + data.name, modeSchema, data);\n    return createModes$1(choose$1(value.branchKey, value.branches), value.name, value.active, value.apis, value.extra, value.state);\n  };\n  var revoke = constant$1(undefined);\n  var Receiving = create$4({\n    fields: ReceivingSchema,\n    name: 'receiving',\n    active: ActiveReceiving\n  });\n  var exhibit$6 = function exhibit$6(base, posConfig) {\n    return nu$7({\n      classes: [],\n      styles: posConfig.useFixed() ? {} : {\n        position: 'relative'\n      }\n    });\n  };\n  var ActivePosition = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    exhibit: exhibit$6\n  });\n  var focus$3 = function focus$3(element) {\n    var preventScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return element.dom.focus({\n      preventScroll: preventScroll\n    });\n  };\n  var blur$1 = function blur$1(element) {\n    return element.dom.blur();\n  };\n  var hasFocus = function hasFocus(element) {\n    var root = getRootNode(element).dom;\n    return element.dom === root.activeElement;\n  };\n  var active$1 = function active$1() {\n    var root = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getDocument();\n    return Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n  };\n  var search = function search(element) {\n    return active$1(getRootNode(element)).filter(function (e) {\n      return element.dom.contains(e.dom);\n    });\n  };\n  var preserve$1 = function preserve$1(f, container) {\n    var dos = getRootNode(container);\n    var refocus = active$1(dos).bind(function (focused) {\n      var hasFocus = function hasFocus(elem) {\n        return eq(focused, elem);\n      };\n      return hasFocus(container) ? Optional.some(container) : descendant$1(container, hasFocus);\n    });\n    var result = f(container);\n    refocus.each(function (oldFocus) {\n      active$1(dos).filter(function (newFocus) {\n        return eq(newFocus, oldFocus);\n      }).fold(function () {\n        focus$3(oldFocus);\n      }, noop);\n    });\n    return result;\n  };\n  var NuPositionCss = function NuPositionCss(position, left, top, right, bottom) {\n    var toPx = function toPx(num) {\n      return num + 'px';\n    };\n    return {\n      position: position,\n      left: left.map(toPx),\n      top: top.map(toPx),\n      right: right.map(toPx),\n      bottom: bottom.map(toPx)\n    };\n  };\n  var toOptions = function toOptions(position) {\n    return _objectSpread({}, position, {\n      position: Optional.some(position.position)\n    });\n  };\n  var applyPositionCss = function applyPositionCss(element, position) {\n    setOptions(element, toOptions(position));\n  };\n  var adt$9 = Adt.generate([{\n    none: []\n  }, {\n    relative: ['x', 'y', 'width', 'height']\n  }, {\n    fixed: ['x', 'y', 'width', 'height']\n  }]);\n  var positionWithDirection = function positionWithDirection(posName, decision, x, y, width, height) {\n    var decisionRect = decision.rect;\n    var decisionX = decisionRect.x - x;\n    var decisionY = decisionRect.y - y;\n    var decisionWidth = decisionRect.width;\n    var decisionHeight = decisionRect.height;\n    var decisionRight = width - (decisionX + decisionWidth);\n    var decisionBottom = height - (decisionY + decisionHeight);\n    var left = Optional.some(decisionX);\n    var top = Optional.some(decisionY);\n    var right = Optional.some(decisionRight);\n    var bottom = Optional.some(decisionBottom);\n    var none = Optional.none();\n    return cata$2(decision.direction, function () {\n      return NuPositionCss(posName, left, top, none, none);\n    }, function () {\n      return NuPositionCss(posName, none, top, right, none);\n    }, function () {\n      return NuPositionCss(posName, left, none, none, bottom);\n    }, function () {\n      return NuPositionCss(posName, none, none, right, bottom);\n    }, function () {\n      return NuPositionCss(posName, left, top, none, none);\n    }, function () {\n      return NuPositionCss(posName, left, none, none, bottom);\n    }, function () {\n      return NuPositionCss(posName, left, top, none, none);\n    }, function () {\n      return NuPositionCss(posName, none, top, right, none);\n    });\n  };\n  var reposition = function reposition(origin, decision) {\n    return origin.fold(function () {\n      var decisionRect = decision.rect;\n      return NuPositionCss('absolute', Optional.some(decisionRect.x), Optional.some(decisionRect.y), Optional.none(), Optional.none());\n    }, function (x, y, width, height) {\n      return positionWithDirection('absolute', decision, x, y, width, height);\n    }, function (x, y, width, height) {\n      return positionWithDirection('fixed', decision, x, y, width, height);\n    });\n  };\n  var toBox = function toBox(origin, element) {\n    var rel = curry(find$2, element);\n    var position = origin.fold(rel, rel, function () {\n      var scroll = get$b();\n      return find$2(element).translate(-scroll.left, -scroll.top);\n    });\n    var width = getOuter$1(element);\n    var height = getOuter$2(element);\n    return bounds(position.left, position.top, width, height);\n  };\n  var viewport = function viewport(origin, optBounds) {\n    return optBounds.fold(function () {\n      return origin.fold(win, win, bounds);\n    }, function (bounds$1) {\n      return origin.fold(constant$1(bounds$1), constant$1(bounds$1), function () {\n        var pos = translate$2(origin, bounds$1.x, bounds$1.y);\n        return bounds(pos.left, pos.top, bounds$1.width, bounds$1.height);\n      });\n    });\n  };\n  var translate$2 = function translate$2(origin, x, y) {\n    var pos = SugarPosition(x, y);\n    var removeScroll = function removeScroll() {\n      var outerScroll = get$b();\n      return pos.translate(-outerScroll.left, -outerScroll.top);\n    };\n    return origin.fold(constant$1(pos), constant$1(pos), removeScroll);\n  };\n  var cata$1 = function cata$1(subject, onNone, onRelative, onFixed) {\n    return subject.fold(onNone, onRelative, onFixed);\n  };\n  adt$9.none;\n  var relative$1 = adt$9.relative;\n  var fixed$1 = adt$9.fixed;\n  var anchor = function anchor(anchorBox, origin) {\n    return {\n      anchorBox: anchorBox,\n      origin: origin\n    };\n  };\n  var box = function box(anchorBox, origin) {\n    return anchor(anchorBox, origin);\n  };\n  var placementAttribute = 'data-alloy-placement';\n  var setPlacement$1 = function setPlacement$1(element, placement) {\n    set$9(element, placementAttribute, placement);\n  };\n  var getPlacement = function getPlacement(element) {\n    return getOpt(element, placementAttribute);\n  };\n  var reset$2 = function reset$2(element) {\n    return remove$7(element, placementAttribute);\n  };\n  var adt$8 = Adt.generate([{\n    fit: ['reposition']\n  }, {\n    nofit: ['reposition', 'visibleW', 'visibleH', 'isVisible']\n  }]);\n  var determinePosition = function determinePosition(box, bounds) {\n    var boundsX = bounds.x,\n      boundsY = bounds.y,\n      boundsRight = bounds.right,\n      boundsBottom = bounds.bottom;\n    var x = box.x,\n      y = box.y,\n      right = box.right,\n      bottom = box.bottom,\n      width = box.width,\n      height = box.height;\n    var xInBounds = x >= boundsX && x <= boundsRight;\n    var yInBounds = y >= boundsY && y <= boundsBottom;\n    var originInBounds = xInBounds && yInBounds;\n    var rightInBounds = right <= boundsRight && right >= boundsX;\n    var bottomInBounds = bottom <= boundsBottom && bottom >= boundsY;\n    var sizeInBounds = rightInBounds && bottomInBounds;\n    var visibleW = Math.min(width, x >= boundsX ? boundsRight - x : right - boundsX);\n    var visibleH = Math.min(height, y >= boundsY ? boundsBottom - y : bottom - boundsY);\n    return {\n      originInBounds: originInBounds,\n      sizeInBounds: sizeInBounds,\n      visibleW: visibleW,\n      visibleH: visibleH\n    };\n  };\n  var calcReposition = function calcReposition(box, bounds$1) {\n    var boundsX = bounds$1.x,\n      boundsY = bounds$1.y,\n      boundsRight = bounds$1.right,\n      boundsBottom = bounds$1.bottom;\n    var x = box.x,\n      y = box.y,\n      width = box.width,\n      height = box.height;\n    var maxX = Math.max(boundsX, boundsRight - width);\n    var maxY = Math.max(boundsY, boundsBottom - height);\n    var restrictedX = clamp(x, boundsX, maxX);\n    var restrictedY = clamp(y, boundsY, maxY);\n    var restrictedWidth = Math.min(restrictedX + width, boundsRight) - restrictedX;\n    var restrictedHeight = Math.min(restrictedY + height, boundsBottom) - restrictedY;\n    return bounds(restrictedX, restrictedY, restrictedWidth, restrictedHeight);\n  };\n  var calcMaxSizes = function calcMaxSizes(direction, box, bounds) {\n    var upAvailable = constant$1(box.bottom - bounds.y);\n    var downAvailable = constant$1(bounds.bottom - box.y);\n    var maxHeight = cataVertical(direction, downAvailable, downAvailable, upAvailable);\n    var westAvailable = constant$1(box.right - bounds.x);\n    var eastAvailable = constant$1(bounds.right - box.x);\n    var maxWidth = cataHorizontal(direction, eastAvailable, eastAvailable, westAvailable);\n    return {\n      maxWidth: maxWidth,\n      maxHeight: maxHeight\n    };\n  };\n  var attempt = function attempt(candidate, width, height, bounds$1) {\n    var bubble = candidate.bubble;\n    var bubbleOffset = bubble.offset;\n    var adjustedBounds = adjustBounds(bounds$1, candidate.restriction, bubbleOffset);\n    var newX = candidate.x + bubbleOffset.left;\n    var newY = candidate.y + bubbleOffset.top;\n    var box = bounds(newX, newY, width, height);\n    var _determinePosition = determinePosition(box, adjustedBounds),\n      originInBounds = _determinePosition.originInBounds,\n      sizeInBounds = _determinePosition.sizeInBounds,\n      visibleW = _determinePosition.visibleW,\n      visibleH = _determinePosition.visibleH;\n    var fits = originInBounds && sizeInBounds;\n    var fittedBox = fits ? box : calcReposition(box, adjustedBounds);\n    var isPartlyVisible = fittedBox.width > 0 && fittedBox.height > 0;\n    var _calcMaxSizes = calcMaxSizes(candidate.direction, fittedBox, bounds$1),\n      maxWidth = _calcMaxSizes.maxWidth,\n      maxHeight = _calcMaxSizes.maxHeight;\n    var reposition = {\n      rect: fittedBox,\n      maxHeight: maxHeight,\n      maxWidth: maxWidth,\n      direction: candidate.direction,\n      placement: candidate.placement,\n      classes: {\n        on: bubble.classesOn,\n        off: bubble.classesOff\n      },\n      layout: candidate.label,\n      testY: newY\n    };\n    return fits || candidate.alwaysFit ? adt$8.fit(reposition) : adt$8.nofit(reposition, visibleW, visibleH, isPartlyVisible);\n  };\n  var attempts = function attempts(element, candidates, anchorBox, elementBox, bubbles, bounds) {\n    var panelWidth = elementBox.width;\n    var panelHeight = elementBox.height;\n    var attemptBestFit = function attemptBestFit(layout, reposition, visibleW, visibleH, isVisible) {\n      var next = layout(anchorBox, elementBox, bubbles, element, bounds);\n      var attemptLayout = attempt(next, panelWidth, panelHeight, bounds);\n      return attemptLayout.fold(constant$1(attemptLayout), function (newReposition, newVisibleW, newVisibleH, newIsVisible) {\n        var improved = isVisible === newIsVisible ? newVisibleH > visibleH || newVisibleW > visibleW : !isVisible && newIsVisible;\n        return improved ? attemptLayout : adt$8.nofit(reposition, visibleW, visibleH, isVisible);\n      });\n    };\n    var abc = foldl(candidates, function (b, a) {\n      var bestNext = curry(attemptBestFit, a);\n      return b.fold(constant$1(b), bestNext);\n    }, adt$8.nofit({\n      rect: anchorBox,\n      maxHeight: elementBox.height,\n      maxWidth: elementBox.width,\n      direction: southeast$3(),\n      placement: 'southeast',\n      classes: {\n        on: [],\n        off: []\n      },\n      layout: 'none',\n      testY: anchorBox.y\n    }, -1, -1, false));\n    return abc.fold(identity, identity);\n  };\n  var singleton = function singleton(doRevoke) {\n    var subject = Cell(Optional.none());\n    var revoke = function revoke() {\n      return subject.get().each(doRevoke);\n    };\n    var clear = function clear() {\n      revoke();\n      subject.set(Optional.none());\n    };\n    var isSet = function isSet() {\n      return subject.get().isSome();\n    };\n    var get = function get() {\n      return subject.get();\n    };\n    var set = function set(s) {\n      revoke();\n      subject.set(Optional.some(s));\n    };\n    return {\n      clear: clear,\n      isSet: isSet,\n      get: get,\n      set: set\n    };\n  };\n  var destroyable = function destroyable() {\n    return singleton(function (s) {\n      return s.destroy();\n    });\n  };\n  var unbindable = function unbindable() {\n    return singleton(function (s) {\n      return s.unbind();\n    });\n  };\n  var value$2 = function value$2() {\n    var subject = singleton(noop);\n    var on = function on(f) {\n      return subject.get().each(f);\n    };\n    return _objectSpread({}, subject, {\n      on: on\n    });\n  };\n  var filter = always;\n  var bind = function bind(element, event, handler) {\n    return bind$2(element, event, filter, handler);\n  };\n  var capture = function capture(element, event, handler) {\n    return capture$1(element, event, filter, handler);\n  };\n  var fromRawEvent = fromRawEvent$1;\n  var properties = ['top', 'bottom', 'right', 'left'];\n  var timerAttr = 'data-alloy-transition-timer';\n  var isTransitioning$1 = function isTransitioning$1(element, transition) {\n    return hasAll(element, transition.classes);\n  };\n  var shouldApplyTransitionCss = function shouldApplyTransitionCss(transition, decision, lastPlacement) {\n    return lastPlacement.exists(function (placer) {\n      var mode = transition.mode;\n      return mode === 'all' ? true : placer[mode] !== decision[mode];\n    });\n  };\n  var hasChanges = function hasChanges(position, intermediate) {\n    var round = function round(value) {\n      return parseFloat(value).toFixed(3);\n    };\n    return find$4(intermediate, function (value, key) {\n      var newValue = position[key].map(round);\n      var val = value.map(round);\n      return !equals(newValue, val);\n    }).isSome();\n  };\n  var getTransitionDuration = function getTransitionDuration(element) {\n    var get = function get(name) {\n      var style = get$e(element, name);\n      var times = style.split(/\\s*,\\s*/);\n      return filter$2(times, isNotEmpty);\n    };\n    var parse = function parse(value) {\n      if (isString(value) && /^[\\d.]+/.test(value)) {\n        var num = parseFloat(value);\n        return endsWith(value, 'ms') ? num : num * 1000;\n      } else {\n        return 0;\n      }\n    };\n    var delay = get('transition-delay');\n    var duration = get('transition-duration');\n    return foldl(duration, function (acc, dur, i) {\n      var time = parse(delay[i]) + parse(dur);\n      return Math.max(acc, time);\n    }, 0);\n  };\n  var setupTransitionListeners = function setupTransitionListeners(element, transition) {\n    var transitionEnd = unbindable();\n    var transitionCancel = unbindable();\n    var timer;\n    var isSourceTransition = function isSourceTransition(e) {\n      var _a;\n      var pseudoElement = (_a = e.raw.pseudoElement) !== null && _a !== void 0 ? _a : '';\n      return eq(e.target, element) && isEmpty(pseudoElement) && contains$2(properties, e.raw.propertyName);\n    };\n    var transitionDone = function transitionDone(e) {\n      if (isNullable(e) || isSourceTransition(e)) {\n        transitionEnd.clear();\n        transitionCancel.clear();\n        var _type = e === null || e === void 0 ? void 0 : e.raw.type;\n        if (isNullable(_type) || _type === transitionend()) {\n          clearTimeout(timer);\n          remove$7(element, timerAttr);\n          remove$1(element, transition.classes);\n        }\n      }\n    };\n    var transitionStart = bind(element, transitionstart(), function (e) {\n      if (isSourceTransition(e)) {\n        transitionStart.unbind();\n        transitionEnd.set(bind(element, transitionend(), transitionDone));\n        transitionCancel.set(bind(element, transitioncancel(), transitionDone));\n      }\n    });\n    var duration = getTransitionDuration(element);\n    requestAnimationFrame(function () {\n      timer = setTimeout(transitionDone, duration + 17);\n      set$9(element, timerAttr, timer);\n    });\n  };\n  var startTransitioning = function startTransitioning(element, transition) {\n    add$1(element, transition.classes);\n    getOpt(element, timerAttr).each(function (timerId) {\n      clearTimeout(parseInt(timerId, 10));\n      remove$7(element, timerAttr);\n    });\n    setupTransitionListeners(element, transition);\n  };\n  var applyTransitionCss = function applyTransitionCss(element, origin, position, transition, decision, lastPlacement) {\n    var shouldTransition = shouldApplyTransitionCss(transition, decision, lastPlacement);\n    if (shouldTransition || isTransitioning$1(element, transition)) {\n      set$8(element, 'position', position.position);\n      var _rect = toBox(origin, element);\n      var intermediatePosition = reposition(origin, _objectSpread({}, decision, {\n        rect: _rect\n      }));\n      var intermediateCssOptions = mapToObject(properties, function (prop) {\n        return intermediatePosition[prop];\n      });\n      if (hasChanges(position, intermediateCssOptions)) {\n        setOptions(element, intermediateCssOptions);\n        if (shouldTransition) {\n          startTransitioning(element, transition);\n        }\n        reflow(element);\n      }\n    } else {\n      remove$1(element, transition.classes);\n    }\n  };\n  var elementSize = function elementSize(p) {\n    return {\n      width: getOuter$1(p),\n      height: getOuter$2(p)\n    };\n  };\n  var layout = function layout(anchorBox, element, bubbles, options) {\n    remove$6(element, 'max-height');\n    remove$6(element, 'max-width');\n    var elementBox = elementSize(element);\n    return attempts(element, options.preference, anchorBox, elementBox, bubbles, options.bounds);\n  };\n  var setClasses = function setClasses(element, decision) {\n    var classInfo = decision.classes;\n    remove$1(element, classInfo.off);\n    add$1(element, classInfo.on);\n  };\n  var setHeight = function setHeight(element, decision, options) {\n    var maxHeightFunction = options.maxHeightFunction;\n    maxHeightFunction(element, decision.maxHeight);\n  };\n  var setWidth = function setWidth(element, decision, options) {\n    var maxWidthFunction = options.maxWidthFunction;\n    maxWidthFunction(element, decision.maxWidth);\n  };\n  var position$2 = function position$2(element, decision, options) {\n    var positionCss = reposition(options.origin, decision);\n    options.transition.each(function (transition) {\n      applyTransitionCss(element, options.origin, positionCss, transition, decision, options.lastPlacement);\n    });\n    applyPositionCss(element, positionCss);\n  };\n  var setPlacement = function setPlacement(element, decision) {\n    setPlacement$1(element, decision.placement);\n  };\n  var setMaxHeight = function setMaxHeight(element, maxHeight) {\n    setMax$1(element, Math.floor(maxHeight));\n  };\n  var anchored = constant$1(function (element, available) {\n    setMaxHeight(element, available);\n    setAll(element, {\n      'overflow-x': 'hidden',\n      'overflow-y': 'auto'\n    });\n  });\n  var expandable$1 = constant$1(function (element, available) {\n    setMaxHeight(element, available);\n  });\n  var defaultOr = function defaultOr(options, key, dephault) {\n    return options[key] === undefined ? dephault : options[key];\n  };\n  var simple = function simple(anchor, element, bubble, layouts, lastPlacement, optBounds, overrideOptions, transition) {\n    var maxHeightFunction = defaultOr(overrideOptions, 'maxHeightFunction', anchored());\n    var maxWidthFunction = defaultOr(overrideOptions, 'maxWidthFunction', noop);\n    var anchorBox = anchor.anchorBox;\n    var origin = anchor.origin;\n    var options = {\n      bounds: viewport(origin, optBounds),\n      origin: origin,\n      preference: layouts,\n      maxHeightFunction: maxHeightFunction,\n      maxWidthFunction: maxWidthFunction,\n      lastPlacement: lastPlacement,\n      transition: transition\n    };\n    return go(anchorBox, element, bubble, options);\n  };\n  var go = function go(anchorBox, element, bubble, options) {\n    var decision = layout(anchorBox, element, bubble, options);\n    position$2(element, decision, options);\n    setPlacement(element, decision);\n    setClasses(element, decision);\n    setHeight(element, decision, options);\n    setWidth(element, decision, options);\n    return {\n      layout: decision.layout,\n      placement: decision.placement\n    };\n  };\n  var allAlignments = ['valignCentre', 'alignLeft', 'alignRight', 'alignCentre', 'top', 'bottom', 'left', 'right', 'inset'];\n  var nu$5 = function nu$5(xOffset, yOffset, classes) {\n    var insetModifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var insetXOffset = xOffset * insetModifier;\n    var insetYOffset = yOffset * insetModifier;\n    var getClasses = function getClasses(prop) {\n      return get$g(classes, prop).getOr([]);\n    };\n    var make = function make(xDelta, yDelta, alignmentsOn) {\n      var alignmentsOff = difference(allAlignments, alignmentsOn);\n      return {\n        offset: SugarPosition(xDelta, yDelta),\n        classesOn: bind$3(alignmentsOn, getClasses),\n        classesOff: bind$3(alignmentsOff, getClasses)\n      };\n    };\n    return {\n      southeast: function southeast() {\n        return make(-xOffset, yOffset, ['top', 'alignLeft']);\n      },\n      southwest: function southwest() {\n        return make(xOffset, yOffset, ['top', 'alignRight']);\n      },\n      south: function south() {\n        return make(-xOffset / 2, yOffset, ['top', 'alignCentre']);\n      },\n      northeast: function northeast() {\n        return make(-xOffset, -yOffset, ['bottom', 'alignLeft']);\n      },\n      northwest: function northwest() {\n        return make(xOffset, -yOffset, ['bottom', 'alignRight']);\n      },\n      north: function north() {\n        return make(-xOffset / 2, -yOffset, ['bottom', 'alignCentre']);\n      },\n      east: function east() {\n        return make(xOffset, -yOffset / 2, ['valignCentre', 'left']);\n      },\n      west: function west() {\n        return make(-xOffset, -yOffset / 2, ['valignCentre', 'right']);\n      },\n      insetNortheast: function insetNortheast() {\n        return make(insetXOffset, insetYOffset, ['top', 'alignLeft', 'inset']);\n      },\n      insetNorthwest: function insetNorthwest() {\n        return make(-insetXOffset, insetYOffset, ['top', 'alignRight', 'inset']);\n      },\n      insetNorth: function insetNorth() {\n        return make(-insetXOffset / 2, insetYOffset, ['top', 'alignCentre', 'inset']);\n      },\n      insetSoutheast: function insetSoutheast() {\n        return make(insetXOffset, -insetYOffset, ['bottom', 'alignLeft', 'inset']);\n      },\n      insetSouthwest: function insetSouthwest() {\n        return make(-insetXOffset, -insetYOffset, ['bottom', 'alignRight', 'inset']);\n      },\n      insetSouth: function insetSouth() {\n        return make(-insetXOffset / 2, -insetYOffset, ['bottom', 'alignCentre', 'inset']);\n      },\n      insetEast: function insetEast() {\n        return make(-insetXOffset, -insetYOffset / 2, ['valignCentre', 'right', 'inset']);\n      },\n      insetWest: function insetWest() {\n        return make(insetXOffset, -insetYOffset / 2, ['valignCentre', 'left', 'inset']);\n      }\n    };\n  };\n  var fallback = function fallback() {\n    return nu$5(0, 0, {});\n  };\n  var nu$4 = identity;\n  var onDirection = function onDirection(isLtr, isRtl) {\n    return function (element) {\n      return getDirection(element) === 'rtl' ? isRtl : isLtr;\n    };\n  };\n  var getDirection = function getDirection(element) {\n    return get$e(element, 'direction') === 'rtl' ? 'rtl' : 'ltr';\n  };\n  var AttributeValue;\n  (function (AttributeValue) {\n    AttributeValue['TopToBottom'] = 'toptobottom';\n    AttributeValue['BottomToTop'] = 'bottomtotop';\n  })(AttributeValue || (AttributeValue = {}));\n  var Attribute = 'data-alloy-vertical-dir';\n  var isBottomToTopDir = function isBottomToTopDir(el) {\n    return closest$2(el, function (current) {\n      return isElement$1(current) && get$f(current, 'data-alloy-vertical-dir') === AttributeValue.BottomToTop;\n    });\n  };\n  var schema$y = function schema$y() {\n    return optionObjOf('layouts', [required$1('onLtr'), required$1('onRtl'), option$3('onBottomLtr'), option$3('onBottomRtl')]);\n  };\n  var get$5 = function get$5(elem, info, defaultLtr, defaultRtl, defaultBottomLtr, defaultBottomRtl, dirElement) {\n    var isBottomToTop = dirElement.map(isBottomToTopDir).getOr(false);\n    var customLtr = info.layouts.map(function (ls) {\n      return ls.onLtr(elem);\n    });\n    var customRtl = info.layouts.map(function (ls) {\n      return ls.onRtl(elem);\n    });\n    var ltr = isBottomToTop ? info.layouts.bind(function (ls) {\n      return ls.onBottomLtr.map(function (f) {\n        return f(elem);\n      });\n    }).or(customLtr).getOr(defaultBottomLtr) : customLtr.getOr(defaultLtr);\n    var rtl = isBottomToTop ? info.layouts.bind(function (ls) {\n      return ls.onBottomRtl.map(function (f) {\n        return f(elem);\n      });\n    }).or(customRtl).getOr(defaultBottomRtl) : customRtl.getOr(defaultRtl);\n    var f = onDirection(ltr, rtl);\n    return f(elem);\n  };\n  var placement$4 = function placement$4(component, anchorInfo, origin) {\n    var hotspot = anchorInfo.hotspot;\n    var anchorBox = toBox(origin, hotspot.element);\n    var layouts = get$5(component.element, anchorInfo, belowOrAbove(), belowOrAboveRtl(), aboveOrBelow(), aboveOrBelowRtl(), Optional.some(anchorInfo.hotspot.element));\n    return Optional.some(nu$4({\n      anchorBox: anchorBox,\n      bubble: anchorInfo.bubble.getOr(fallback()),\n      overrides: anchorInfo.overrides,\n      layouts: layouts\n    }));\n  };\n  var HotspotAnchor = [required$1('hotspot'), option$3('bubble'), defaulted('overrides', {}), schema$y(), output$1('placement', placement$4)];\n  var placement$3 = function placement$3(component, anchorInfo, origin) {\n    var pos = translate$2(origin, anchorInfo.x, anchorInfo.y);\n    var anchorBox = bounds(pos.left, pos.top, anchorInfo.width, anchorInfo.height);\n    var layouts = get$5(component.element, anchorInfo, all$1(), allRtl$1(), all$1(), allRtl$1(), Optional.none());\n    return Optional.some(nu$4({\n      anchorBox: anchorBox,\n      bubble: anchorInfo.bubble,\n      overrides: anchorInfo.overrides,\n      layouts: layouts\n    }));\n  };\n  var MakeshiftAnchor = [required$1('x'), required$1('y'), defaulted('height', 0), defaulted('width', 0), defaulted('bubble', fallback()), defaulted('overrides', {}), schema$y(), output$1('placement', placement$3)];\n  var adt$7 = Adt.generate([{\n    screen: ['point']\n  }, {\n    absolute: ['point', 'scrollLeft', 'scrollTop']\n  }]);\n  var toFixed = function toFixed(pos) {\n    return pos.fold(identity, function (point, scrollLeft, scrollTop) {\n      return point.translate(-scrollLeft, -scrollTop);\n    });\n  };\n  var toAbsolute = function toAbsolute(pos) {\n    return pos.fold(identity, identity);\n  };\n  var sum = function sum(points) {\n    return foldl(points, function (b, a) {\n      return b.translate(a.left, a.top);\n    }, SugarPosition(0, 0));\n  };\n  var sumAsFixed = function sumAsFixed(positions) {\n    var points = map$2(positions, toFixed);\n    return sum(points);\n  };\n  var sumAsAbsolute = function sumAsAbsolute(positions) {\n    var points = map$2(positions, toAbsolute);\n    return sum(points);\n  };\n  var screen = adt$7.screen;\n  var absolute$1 = adt$7.absolute;\n  var getOffset = function getOffset(component, origin, anchorInfo) {\n    var win = defaultView(anchorInfo.root).dom;\n    var hasSameOwner = function hasSameOwner(frame) {\n      var frameOwner = owner$4(frame);\n      var compOwner = owner$4(component.element);\n      return eq(frameOwner, compOwner);\n    };\n    return Optional.from(win.frameElement).map(SugarElement.fromDom).filter(hasSameOwner).map(absolute$3);\n  };\n  var getRootPoint = function getRootPoint(component, origin, anchorInfo) {\n    var doc = owner$4(component.element);\n    var outerScroll = get$b(doc);\n    var offset = getOffset(component, origin, anchorInfo).getOr(outerScroll);\n    return absolute$1(offset, outerScroll.left, outerScroll.top);\n  };\n  var getBox = function getBox(left, top, width, height) {\n    var point = screen(SugarPosition(left, top));\n    return Optional.some(pointed(point, width, height));\n  };\n  var calcNewAnchor = function calcNewAnchor(optBox, rootPoint, anchorInfo, origin, elem) {\n    return optBox.map(function (box) {\n      var points = [rootPoint, box.point];\n      var topLeft = cata$1(origin, function () {\n        return sumAsAbsolute(points);\n      }, function () {\n        return sumAsAbsolute(points);\n      }, function () {\n        return sumAsFixed(points);\n      });\n      var anchorBox = rect(topLeft.left, topLeft.top, box.width, box.height);\n      var layoutsLtr = anchorInfo.showAbove ? aboveOrBelow() : belowOrAbove();\n      var layoutsRtl = anchorInfo.showAbove ? aboveOrBelowRtl() : belowOrAboveRtl();\n      var layouts = get$5(elem, anchorInfo, layoutsLtr, layoutsRtl, layoutsLtr, layoutsRtl, Optional.none());\n      return nu$4({\n        anchorBox: anchorBox,\n        bubble: anchorInfo.bubble.getOr(fallback()),\n        overrides: anchorInfo.overrides,\n        layouts: layouts\n      });\n    });\n  };\n  var placement$2 = function placement$2(component, anchorInfo, origin) {\n    var rootPoint = getRootPoint(component, origin, anchorInfo);\n    return anchorInfo.node.filter(inBody).bind(function (target) {\n      var rect = target.dom.getBoundingClientRect();\n      var nodeBox = getBox(rect.left, rect.top, rect.width, rect.height);\n      var elem = anchorInfo.node.getOr(component.element);\n      return calcNewAnchor(nodeBox, rootPoint, anchorInfo, origin, elem);\n    });\n  };\n  var NodeAnchor = [required$1('node'), required$1('root'), option$3('bubble'), schema$y(), defaulted('overrides', {}), defaulted('showAbove', false), output$1('placement', placement$2)];\n  var zeroWidth = \"\\uFEFF\";\n  var nbsp = '\\xA0';\n  var create$3 = function create$3(start, soffset, finish, foffset) {\n    return {\n      start: start,\n      soffset: soffset,\n      finish: finish,\n      foffset: foffset\n    };\n  };\n  var SimRange = {\n    create: create$3\n  };\n  var adt$6 = Adt.generate([{\n    before: ['element']\n  }, {\n    on: ['element', 'offset']\n  }, {\n    after: ['element']\n  }]);\n  var cata = function cata(subject, onBefore, onOn, onAfter) {\n    return subject.fold(onBefore, onOn, onAfter);\n  };\n  var getStart$1 = function getStart$1(situ) {\n    return situ.fold(identity, identity, identity);\n  };\n  var before = adt$6.before;\n  var on$1 = adt$6.on;\n  var after$1 = adt$6.after;\n  var Situ = {\n    before: before,\n    on: on$1,\n    after: after$1,\n    cata: cata,\n    getStart: getStart$1\n  };\n  var adt$5 = Adt.generate([{\n    domRange: ['rng']\n  }, {\n    relative: ['startSitu', 'finishSitu']\n  }, {\n    exact: ['start', 'soffset', 'finish', 'foffset']\n  }]);\n  var exactFromRange = function exactFromRange(simRange) {\n    return adt$5.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n  };\n  var getStart = function getStart(selection) {\n    return selection.match({\n      domRange: function domRange(rng) {\n        return SugarElement.fromDom(rng.startContainer);\n      },\n      relative: function relative(startSitu, _finishSitu) {\n        return Situ.getStart(startSitu);\n      },\n      exact: function exact(start, _soffset, _finish, _foffset) {\n        return start;\n      }\n    });\n  };\n  var domRange = adt$5.domRange;\n  var relative = adt$5.relative;\n  var exact = adt$5.exact;\n  var getWin = function getWin(selection) {\n    var start = getStart(selection);\n    return defaultView(start);\n  };\n  var range$1 = SimRange.create;\n  var SimSelection = {\n    domRange: domRange,\n    relative: relative,\n    exact: exact,\n    exactFromRange: exactFromRange,\n    getWin: getWin,\n    range: range$1\n  };\n  var setStart = function setStart(rng, situ) {\n    situ.fold(function (e) {\n      rng.setStartBefore(e.dom);\n    }, function (e, o) {\n      rng.setStart(e.dom, o);\n    }, function (e) {\n      rng.setStartAfter(e.dom);\n    });\n  };\n  var setFinish = function setFinish(rng, situ) {\n    situ.fold(function (e) {\n      rng.setEndBefore(e.dom);\n    }, function (e, o) {\n      rng.setEnd(e.dom, o);\n    }, function (e) {\n      rng.setEndAfter(e.dom);\n    });\n  };\n  var relativeToNative = function relativeToNative(win, startSitu, finishSitu) {\n    var range = win.document.createRange();\n    setStart(range, startSitu);\n    setFinish(range, finishSitu);\n    return range;\n  };\n  var exactToNative = function exactToNative(win, start, soffset, finish, foffset) {\n    var rng = win.document.createRange();\n    rng.setStart(start.dom, soffset);\n    rng.setEnd(finish.dom, foffset);\n    return rng;\n  };\n  var toRect = function toRect(rect) {\n    return {\n      left: rect.left,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      width: rect.width,\n      height: rect.height\n    };\n  };\n  var getFirstRect$1 = function getFirstRect$1(rng) {\n    var rects = rng.getClientRects();\n    var rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();\n    return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();\n  };\n  var getBounds$2 = function getBounds$2(rng) {\n    var rect = rng.getBoundingClientRect();\n    return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();\n  };\n  var adt$4 = Adt.generate([{\n    ltr: ['start', 'soffset', 'finish', 'foffset']\n  }, {\n    rtl: ['start', 'soffset', 'finish', 'foffset']\n  }]);\n  var fromRange = function fromRange(win, type, range) {\n    return type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n  };\n  var getRanges = function getRanges(win, selection) {\n    return selection.match({\n      domRange: function domRange(rng) {\n        return {\n          ltr: constant$1(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: function relative(startSitu, finishSitu) {\n        return {\n          ltr: cached(function () {\n            return relativeToNative(win, startSitu, finishSitu);\n          }),\n          rtl: cached(function () {\n            return Optional.some(relativeToNative(win, finishSitu, startSitu));\n          })\n        };\n      },\n      exact: function exact(start, soffset, finish, foffset) {\n        return {\n          ltr: cached(function () {\n            return exactToNative(win, start, soffset, finish, foffset);\n          }),\n          rtl: cached(function () {\n            return Optional.some(exactToNative(win, finish, foffset, start, soffset));\n          })\n        };\n      }\n    });\n  };\n  var doDiagnose = function doDiagnose(win, ranges) {\n    var rng = ranges.ltr();\n    if (rng.collapsed) {\n      var reversed = ranges.rtl().filter(function (rev) {\n        return rev.collapsed === false;\n      });\n      return reversed.map(function (rev) {\n        return adt$4.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset);\n      }).getOrThunk(function () {\n        return fromRange(win, adt$4.ltr, rng);\n      });\n    } else {\n      return fromRange(win, adt$4.ltr, rng);\n    }\n  };\n  var diagnose = function diagnose(win, selection) {\n    var ranges = getRanges(win, selection);\n    return doDiagnose(win, ranges);\n  };\n  var asLtrRange = function asLtrRange(win, selection) {\n    var diagnosis = diagnose(win, selection);\n    return diagnosis.match({\n      ltr: function ltr(start, soffset, finish, foffset) {\n        var rng = win.document.createRange();\n        rng.setStart(start.dom, soffset);\n        rng.setEnd(finish.dom, foffset);\n        return rng;\n      },\n      rtl: function rtl(start, soffset, finish, foffset) {\n        var rng = win.document.createRange();\n        rng.setStart(finish.dom, foffset);\n        rng.setEnd(start.dom, soffset);\n        return rng;\n      }\n    });\n  };\n  adt$4.ltr;\n  adt$4.rtl;\n  var ancestors = function ancestors(scope, predicate, isRoot) {\n    return filter$2(parents(scope, isRoot), predicate);\n  };\n  var descendants = function descendants(scope, selector) {\n    return all$3(selector, scope);\n  };\n  var makeRange = function makeRange(start, soffset, finish, foffset) {\n    var doc = owner$4(start);\n    var rng = doc.dom.createRange();\n    rng.setStart(start.dom, soffset);\n    rng.setEnd(finish.dom, foffset);\n    return rng;\n  };\n  var after = function after(start, soffset, finish, foffset) {\n    var r = makeRange(start, soffset, finish, foffset);\n    var same = eq(start, finish) && soffset === foffset;\n    return r.collapsed && !same;\n  };\n  var getNativeSelection = function getNativeSelection(win) {\n    return Optional.from(win.getSelection());\n  };\n  var readRange = function readRange(selection) {\n    if (selection.rangeCount > 0) {\n      var firstRng = selection.getRangeAt(0);\n      var lastRng = selection.getRangeAt(selection.rangeCount - 1);\n      return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));\n    } else {\n      return Optional.none();\n    }\n  };\n  var doGetExact = function doGetExact(selection) {\n    if (selection.anchorNode === null || selection.focusNode === null) {\n      return readRange(selection);\n    } else {\n      var _anchor = SugarElement.fromDom(selection.anchorNode);\n      var _focus = SugarElement.fromDom(selection.focusNode);\n      return after(_anchor, selection.anchorOffset, _focus, selection.focusOffset) ? Optional.some(SimRange.create(_anchor, selection.anchorOffset, _focus, selection.focusOffset)) : readRange(selection);\n    }\n  };\n  var getExact = function getExact(win) {\n    return getNativeSelection(win).filter(function (sel) {\n      return sel.rangeCount > 0;\n    }).bind(doGetExact);\n  };\n  var getFirstRect = function getFirstRect(win, selection) {\n    var rng = asLtrRange(win, selection);\n    return getFirstRect$1(rng);\n  };\n  var getBounds$1 = function getBounds$1(win, selection) {\n    var rng = asLtrRange(win, selection);\n    return getBounds$2(rng);\n  };\n  var NodeValue = function NodeValue(is, name) {\n    var get = function get(element) {\n      if (!is(element)) {\n        throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n      }\n      return getOption(element).getOr('');\n    };\n    var getOption = function getOption(element) {\n      return is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n    };\n    var set = function set(element, value) {\n      if (!is(element)) {\n        throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n      }\n      element.dom.nodeValue = value;\n    };\n    return {\n      get: get,\n      getOption: getOption,\n      set: set\n    };\n  };\n  var api = NodeValue(isText, 'text');\n  var get$4 = function get$4(element) {\n    return api.get(element);\n  };\n  var point = function point(element, offset) {\n    return {\n      element: element,\n      offset: offset\n    };\n  };\n  var descendOnce$1 = function descendOnce$1(element, offset) {\n    var children$1 = children(element);\n    if (children$1.length === 0) {\n      return point(element, offset);\n    } else if (offset < children$1.length) {\n      return point(children$1[offset], 0);\n    } else {\n      var _last = children$1[children$1.length - 1];\n      var len = isText(_last) ? get$4(_last).length : children(_last).length;\n      return point(_last, len);\n    }\n  };\n  var descendOnce = function descendOnce(element, offset) {\n    return isText(element) ? point(element, offset) : descendOnce$1(element, offset);\n  };\n  var isSimRange = function isSimRange(detail) {\n    return detail.foffset !== undefined;\n  };\n  var getAnchorSelection = function getAnchorSelection(win, anchorInfo) {\n    var getSelection = anchorInfo.getSelection.getOrThunk(function () {\n      return function () {\n        return getExact(win);\n      };\n    });\n    return getSelection().map(function (sel) {\n      if (isSimRange(sel)) {\n        var modStart = descendOnce(sel.start, sel.soffset);\n        var modFinish = descendOnce(sel.finish, sel.foffset);\n        return SimSelection.range(modStart.element, modStart.offset, modFinish.element, modFinish.offset);\n      } else {\n        return sel;\n      }\n    });\n  };\n  var placement$1 = function placement$1(component, anchorInfo, origin) {\n    var win = defaultView(anchorInfo.root).dom;\n    var rootPoint = getRootPoint(component, origin, anchorInfo);\n    var selectionBox = getAnchorSelection(win, anchorInfo).bind(function (sel) {\n      if (isSimRange(sel)) {\n        var optRect = getBounds$1(win, SimSelection.exactFromRange(sel)).orThunk(function () {\n          var zeroWidth$1 = SugarElement.fromText(zeroWidth);\n          before$1(sel.start, zeroWidth$1);\n          var rect = getFirstRect(win, SimSelection.exact(zeroWidth$1, 0, zeroWidth$1, 1));\n          remove$5(zeroWidth$1);\n          return rect;\n        });\n        return optRect.bind(function (rawRect) {\n          return getBox(rawRect.left, rawRect.top, rawRect.width, rawRect.height);\n        });\n      } else {\n        var selectionRect = map$1(sel, function (cell) {\n          return cell.dom.getBoundingClientRect();\n        });\n        var _bounds = {\n          left: Math.min(selectionRect.firstCell.left, selectionRect.lastCell.left),\n          right: Math.max(selectionRect.firstCell.right, selectionRect.lastCell.right),\n          top: Math.min(selectionRect.firstCell.top, selectionRect.lastCell.top),\n          bottom: Math.max(selectionRect.firstCell.bottom, selectionRect.lastCell.bottom)\n        };\n        return getBox(_bounds.left, _bounds.top, _bounds.right - _bounds.left, _bounds.bottom - _bounds.top);\n      }\n    });\n    var targetElement = getAnchorSelection(win, anchorInfo).bind(function (sel) {\n      if (isSimRange(sel)) {\n        return isElement$1(sel.start) ? Optional.some(sel.start) : parentElement(sel.start);\n      } else {\n        return Optional.some(sel.firstCell);\n      }\n    });\n    var elem = targetElement.getOr(component.element);\n    return calcNewAnchor(selectionBox, rootPoint, anchorInfo, origin, elem);\n  };\n  var SelectionAnchor = [option$3('getSelection'), required$1('root'), option$3('bubble'), schema$y(), defaulted('overrides', {}), defaulted('showAbove', false), output$1('placement', placement$1)];\n  var labelPrefix$1 = 'link-layout';\n  var eastX = function eastX(anchor) {\n    return anchor.x + anchor.width;\n  };\n  var westX = function westX(anchor, element) {\n    return anchor.x - element.width;\n  };\n  var northY$1 = function northY$1(anchor, element) {\n    return anchor.y - element.height + anchor.height;\n  };\n  var southY$1 = function southY$1(anchor) {\n    return anchor.y;\n  };\n  var southeast$1 = function southeast$1(anchor, element, bubbles) {\n    return nu$6(eastX(anchor), southY$1(anchor), bubbles.southeast(), southeast$3(), 'southeast', boundsRestriction(anchor, {\n      left: 0,\n      top: 2\n    }), labelPrefix$1);\n  };\n  var southwest$1 = function southwest$1(anchor, element, bubbles) {\n    return nu$6(westX(anchor, element), southY$1(anchor), bubbles.southwest(), southwest$3(), 'southwest', boundsRestriction(anchor, {\n      right: 1,\n      top: 2\n    }), labelPrefix$1);\n  };\n  var northeast$1 = function northeast$1(anchor, element, bubbles) {\n    return nu$6(eastX(anchor), northY$1(anchor, element), bubbles.northeast(), northeast$3(), 'northeast', boundsRestriction(anchor, {\n      left: 0,\n      bottom: 3\n    }), labelPrefix$1);\n  };\n  var northwest$1 = function northwest$1(anchor, element, bubbles) {\n    return nu$6(westX(anchor, element), northY$1(anchor, element), bubbles.northwest(), northwest$3(), 'northwest', boundsRestriction(anchor, {\n      right: 1,\n      bottom: 3\n    }), labelPrefix$1);\n  };\n  var all = function all() {\n    return [southeast$1, southwest$1, northeast$1, northwest$1];\n  };\n  var allRtl = function allRtl() {\n    return [southwest$1, southeast$1, northwest$1, northeast$1];\n  };\n  var placement = function placement(component, submenuInfo, origin) {\n    var anchorBox = toBox(origin, submenuInfo.item.element);\n    var layouts = get$5(component.element, submenuInfo, all(), allRtl(), all(), allRtl(), Optional.none());\n    return Optional.some(nu$4({\n      anchorBox: anchorBox,\n      bubble: fallback(),\n      overrides: submenuInfo.overrides,\n      layouts: layouts\n    }));\n  };\n  var SubmenuAnchor = [required$1('item'), schema$y(), defaulted('overrides', {}), output$1('placement', placement)];\n  var AnchorSchema = choose$1('type', {\n    selection: SelectionAnchor,\n    node: NodeAnchor,\n    hotspot: HotspotAnchor,\n    submenu: SubmenuAnchor,\n    makeshift: MakeshiftAnchor\n  });\n  var TransitionSchema = [requiredArrayOf('classes', string), defaultedStringEnum('mode', 'all', ['all', 'layout', 'placement'])];\n  var PositionSchema = [defaulted('useFixed', never), option$3('getBounds')];\n  var PlacementSchema = [requiredOf('anchor', AnchorSchema), optionObjOf('transition', TransitionSchema)];\n  var getFixedOrigin = function getFixedOrigin() {\n    var html = document.documentElement;\n    return fixed$1(0, 0, html.clientWidth, html.clientHeight);\n  };\n  var getRelativeOrigin = function getRelativeOrigin(component) {\n    var position = absolute$3(component.element);\n    var bounds = component.element.dom.getBoundingClientRect();\n    return relative$1(position.left, position.top, bounds.width, bounds.height);\n  };\n  var place = function place(origin, anchoring, optBounds, placee, lastPlace, transition) {\n    var anchor = box(anchoring.anchorBox, origin);\n    return simple(anchor, placee.element, anchoring.bubble, anchoring.layouts, lastPlace, optBounds, anchoring.overrides, transition);\n  };\n  var position$1 = function position$1(component, posConfig, posState, placee, placementSpec) {\n    var optWithinBounds = Optional.none();\n    positionWithinBounds(component, posConfig, posState, placee, placementSpec, optWithinBounds);\n  };\n  var positionWithinBounds = function positionWithinBounds(component, posConfig, posState, placee, placementSpec, optWithinBounds) {\n    var placeeDetail = asRawOrDie$1('placement.info', objOf(PlacementSchema), placementSpec);\n    var anchorage = placeeDetail.anchor;\n    var element = placee.element;\n    var placeeState = posState.get(placee.uid);\n    preserve$1(function () {\n      set$8(element, 'position', 'fixed');\n      var oldVisibility = getRaw(element, 'visibility');\n      set$8(element, 'visibility', 'hidden');\n      var origin = posConfig.useFixed() ? getFixedOrigin() : getRelativeOrigin(component);\n      anchorage.placement(component, anchorage, origin).each(function (anchoring) {\n        var optBounds = optWithinBounds.orThunk(function () {\n          return posConfig.getBounds.map(apply$1);\n        });\n        var newState = place(origin, anchoring, optBounds, placee, placeeState, placeeDetail.transition);\n        posState.set(placee.uid, newState);\n      });\n      oldVisibility.fold(function () {\n        remove$6(element, 'visibility');\n      }, function (vis) {\n        set$8(element, 'visibility', vis);\n      });\n      if (getRaw(element, 'left').isNone() && getRaw(element, 'top').isNone() && getRaw(element, 'right').isNone() && getRaw(element, 'bottom').isNone() && is$1(getRaw(element, 'position'), 'fixed')) {\n        remove$6(element, 'position');\n      }\n    }, element);\n  };\n  var getMode = function getMode(component, pConfig, _pState) {\n    return pConfig.useFixed() ? 'fixed' : 'absolute';\n  };\n  var reset$1 = function reset$1(component, pConfig, posState, placee) {\n    var element = placee.element;\n    each$1(['position', 'left', 'right', 'top', 'bottom'], function (prop) {\n      return remove$6(element, prop);\n    });\n    reset$2(element);\n    posState.clear(placee.uid);\n  };\n  var PositionApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    position: position$1,\n    positionWithinBounds: positionWithinBounds,\n    getMode: getMode,\n    reset: reset$1\n  });\n  var init$g = function init$g() {\n    var state = {};\n    var set = function set(id, data) {\n      state[id] = data;\n    };\n    var get = function get(id) {\n      return get$g(state, id);\n    };\n    var clear = function clear(id) {\n      if (isNonNullable(id)) {\n        delete state[id];\n      } else {\n        state = {};\n      }\n    };\n    return nu$8({\n      readState: function readState() {\n        return state;\n      },\n      clear: clear,\n      set: set,\n      get: get\n    });\n  };\n  var PositioningState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    init: init$g\n  });\n  var Positioning = create$4({\n    fields: PositionSchema,\n    name: 'positioning',\n    active: ActivePosition,\n    apis: PositionApis,\n    state: PositioningState\n  });\n  var isConnected = function isConnected(comp) {\n    return comp.getSystem().isConnected();\n  };\n  var fireDetaching = function fireDetaching(component) {\n    emit(component, detachedFromDom());\n    var children = component.components();\n    each$1(children, fireDetaching);\n  };\n  var fireAttaching = function fireAttaching(component) {\n    var children = component.components();\n    each$1(children, fireAttaching);\n    emit(component, attachedToDom());\n  };\n  var virtualAttach = function virtualAttach(parent, child) {\n    parent.getSystem().addToWorld(child);\n    if (inBody(parent.element)) {\n      fireAttaching(child);\n    }\n  };\n  var virtualDetach = function virtualDetach(comp) {\n    fireDetaching(comp);\n    comp.getSystem().removeFromWorld(comp);\n  };\n  var attach$1 = function attach$1(parent, child) {\n    append$2(parent.element, child.element);\n  };\n  var detachChildren$1 = function detachChildren$1(component) {\n    each$1(component.components(), function (childComp) {\n      return remove$5(childComp.element);\n    });\n    empty(component.element);\n    component.syncComponents();\n  };\n  var replaceChildren = function replaceChildren(component, newSpecs, buildNewChildren) {\n    var subs = component.components();\n    detachChildren$1(component);\n    var newChildren = buildNewChildren(newSpecs);\n    var deleted = difference(subs, newChildren);\n    each$1(deleted, function (comp) {\n      fireDetaching(comp);\n      component.getSystem().removeFromWorld(comp);\n    });\n    each$1(newChildren, function (childComp) {\n      if (!isConnected(childComp)) {\n        component.getSystem().addToWorld(childComp);\n        attach$1(component, childComp);\n        if (inBody(component.element)) {\n          fireAttaching(childComp);\n        }\n      } else {\n        attach$1(component, childComp);\n      }\n    });\n    component.syncComponents();\n  };\n  var virtualReplaceChildren = function virtualReplaceChildren(component, newSpecs, buildNewChildren) {\n    var subs = component.components();\n    var existingComps = bind$3(newSpecs, function (spec) {\n      return getPremade(spec).toArray();\n    });\n    each$1(subs, function (childComp) {\n      if (!contains$2(existingComps, childComp)) {\n        virtualDetach(childComp);\n      }\n    });\n    var newChildren = buildNewChildren(newSpecs);\n    var deleted = difference(subs, newChildren);\n    each$1(deleted, function (deletedComp) {\n      if (isConnected(deletedComp)) {\n        virtualDetach(deletedComp);\n      }\n    });\n    each$1(newChildren, function (childComp) {\n      if (!isConnected(childComp)) {\n        virtualAttach(component, childComp);\n      }\n    });\n    component.syncComponents();\n  };\n  var attach = function attach(parent, child) {\n    attachWith(parent, child, append$2);\n  };\n  var attachWith = function attachWith(parent, child, insertion) {\n    parent.getSystem().addToWorld(child);\n    insertion(parent.element, child.element);\n    if (inBody(parent.element)) {\n      fireAttaching(child);\n    }\n    parent.syncComponents();\n  };\n  var doDetach = function doDetach(component) {\n    fireDetaching(component);\n    remove$5(component.element);\n    component.getSystem().removeFromWorld(component);\n  };\n  var detach = function detach(component) {\n    var parent$1 = parent(component.element).bind(function (p) {\n      return component.getSystem().getByDom(p).toOptional();\n    });\n    doDetach(component);\n    parent$1.each(function (p) {\n      p.syncComponents();\n    });\n  };\n  var detachChildren = function detachChildren(component) {\n    var subs = component.components();\n    each$1(subs, doDetach);\n    empty(component.element);\n    component.syncComponents();\n  };\n  var attachSystem = function attachSystem(element, guiSystem) {\n    attachSystemWith(element, guiSystem, append$2);\n  };\n  var attachSystemAfter = function attachSystemAfter(element, guiSystem) {\n    attachSystemWith(element, guiSystem, after$2);\n  };\n  var attachSystemWith = function attachSystemWith(element, guiSystem, inserter) {\n    inserter(element, guiSystem.element);\n    var children$1 = children(guiSystem.element);\n    each$1(children$1, function (child) {\n      guiSystem.getByDom(child).each(fireAttaching);\n    });\n  };\n  var detachSystem = function detachSystem(guiSystem) {\n    var children$1 = children(guiSystem.element);\n    each$1(children$1, function (child) {\n      guiSystem.getByDom(child).each(fireDetaching);\n    });\n    remove$5(guiSystem.element);\n  };\n  var rebuild = function rebuild(sandbox, sConfig, sState, data) {\n    sState.get().each(function (_data) {\n      detachChildren(sandbox);\n    });\n    var point = sConfig.getAttachPoint(sandbox);\n    attach(point, sandbox);\n    var built = sandbox.getSystem().build(data);\n    attach(sandbox, built);\n    sState.set(built);\n    return built;\n  };\n  var open$1 = function open$1(sandbox, sConfig, sState, data) {\n    var newState = rebuild(sandbox, sConfig, sState, data);\n    sConfig.onOpen(sandbox, newState);\n    return newState;\n  };\n  var setContent = function setContent(sandbox, sConfig, sState, data) {\n    return sState.get().map(function () {\n      return rebuild(sandbox, sConfig, sState, data);\n    });\n  };\n  var openWhileCloaked = function openWhileCloaked(sandbox, sConfig, sState, data, transaction) {\n    cloak(sandbox, sConfig);\n    open$1(sandbox, sConfig, sState, data);\n    transaction();\n    decloak(sandbox, sConfig);\n  };\n  var close$1 = function close$1(sandbox, sConfig, sState) {\n    sState.get().each(function (data) {\n      detachChildren(sandbox);\n      detach(sandbox);\n      sConfig.onClose(sandbox, data);\n      sState.clear();\n    });\n  };\n  var isOpen$1 = function isOpen$1(_sandbox, _sConfig, sState) {\n    return sState.isOpen();\n  };\n  var isPartOf = function isPartOf(sandbox, sConfig, sState, queryElem) {\n    return isOpen$1(sandbox, sConfig, sState) && sState.get().exists(function (data) {\n      return sConfig.isPartOf(sandbox, data, queryElem);\n    });\n  };\n  var getState$2 = function getState$2(_sandbox, _sConfig, sState) {\n    return sState.get();\n  };\n  var store = function store(sandbox, cssKey, attr, newValue) {\n    getRaw(sandbox.element, cssKey).fold(function () {\n      remove$7(sandbox.element, attr);\n    }, function (v) {\n      set$9(sandbox.element, attr, v);\n    });\n    set$8(sandbox.element, cssKey, newValue);\n  };\n  var restore = function restore(sandbox, cssKey, attr) {\n    getOpt(sandbox.element, attr).fold(function () {\n      return remove$6(sandbox.element, cssKey);\n    }, function (oldValue) {\n      return set$8(sandbox.element, cssKey, oldValue);\n    });\n  };\n  var cloak = function cloak(sandbox, sConfig, _sState) {\n    var sink = sConfig.getAttachPoint(sandbox);\n    set$8(sandbox.element, 'position', Positioning.getMode(sink));\n    store(sandbox, 'visibility', sConfig.cloakVisibilityAttr, 'hidden');\n  };\n  var hasPosition = function hasPosition(element) {\n    return exists(['top', 'left', 'right', 'bottom'], function (pos) {\n      return getRaw(element, pos).isSome();\n    });\n  };\n  var decloak = function decloak(sandbox, sConfig, _sState) {\n    if (!hasPosition(sandbox.element)) {\n      remove$6(sandbox.element, 'position');\n    }\n    restore(sandbox, 'visibility', sConfig.cloakVisibilityAttr);\n  };\n  var SandboxApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    cloak: cloak,\n    decloak: decloak,\n    open: open$1,\n    openWhileCloaked: openWhileCloaked,\n    close: close$1,\n    isOpen: isOpen$1,\n    isPartOf: isPartOf,\n    getState: getState$2,\n    setContent: setContent\n  });\n  var events$g = function events$g(sandboxConfig, sandboxState) {\n    return derive$2([run$1(sandboxClose(), function (sandbox, _simulatedEvent) {\n      close$1(sandbox, sandboxConfig, sandboxState);\n    })]);\n  };\n  var ActiveSandbox = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    events: events$g\n  });\n  var SandboxSchema = [onHandler('onOpen'), onHandler('onClose'), required$1('isPartOf'), required$1('getAttachPoint'), defaulted('cloakVisibilityAttr', 'data-precloak-visibility')];\n  var init$f = function init$f() {\n    var contents = value$2();\n    var readState = constant$1('not-implemented');\n    return nu$8({\n      readState: readState,\n      isOpen: contents.isSet,\n      clear: contents.clear,\n      set: contents.set,\n      get: contents.get\n    });\n  };\n  var SandboxState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    init: init$f\n  });\n  var Sandboxing = create$4({\n    fields: SandboxSchema,\n    name: 'sandboxing',\n    active: ActiveSandbox,\n    apis: SandboxApis,\n    state: SandboxState\n  });\n  var dismissPopups = constant$1('dismiss.popups');\n  var repositionPopups = constant$1('reposition.popups');\n  var mouseReleased = constant$1('mouse.released');\n  var schema$x = objOfOnly([defaulted('isExtraPart', never), optionObjOf('fireEventInstead', [defaulted('event', dismissRequested())])]);\n  var receivingChannel$1 = function receivingChannel$1(rawSpec) {\n    var detail = asRawOrDie$1('Dismissal', schema$x, rawSpec);\n    return _defineProperty({}, dismissPopups(), {\n      schema: objOfOnly([required$1('target')]),\n      onReceive: function onReceive(sandbox, data) {\n        if (Sandboxing.isOpen(sandbox)) {\n          var isPart = Sandboxing.isPartOf(sandbox, data.target) || detail.isExtraPart(sandbox, data.target);\n          if (!isPart) {\n            detail.fireEventInstead.fold(function () {\n              return Sandboxing.close(sandbox);\n            }, function (fe) {\n              return emit(sandbox, fe.event);\n            });\n          }\n        }\n      }\n    });\n  };\n  var schema$w = objOfOnly([optionObjOf('fireEventInstead', [defaulted('event', repositionRequested())]), requiredFunction('doReposition')]);\n  var receivingChannel = function receivingChannel(rawSpec) {\n    var detail = asRawOrDie$1('Reposition', schema$w, rawSpec);\n    return _defineProperty({}, repositionPopups(), {\n      onReceive: function onReceive(sandbox) {\n        if (Sandboxing.isOpen(sandbox)) {\n          detail.fireEventInstead.fold(function () {\n            return detail.doReposition(sandbox);\n          }, function (fe) {\n            return emit(sandbox, fe.event);\n          });\n        }\n      }\n    });\n  };\n  var onLoad$5 = function onLoad$5(component, repConfig, repState) {\n    repConfig.store.manager.onLoad(component, repConfig, repState);\n  };\n  var onUnload$2 = function onUnload$2(component, repConfig, repState) {\n    repConfig.store.manager.onUnload(component, repConfig, repState);\n  };\n  var setValue$3 = function setValue$3(component, repConfig, repState, data) {\n    repConfig.store.manager.setValue(component, repConfig, repState, data);\n  };\n  var getValue$3 = function getValue$3(component, repConfig, repState) {\n    return repConfig.store.manager.getValue(component, repConfig, repState);\n  };\n  var getState$1 = function getState$1(component, repConfig, repState) {\n    return repState;\n  };\n  var RepresentApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    onLoad: onLoad$5,\n    onUnload: onUnload$2,\n    setValue: setValue$3,\n    getValue: getValue$3,\n    getState: getState$1\n  });\n  var events$f = function events$f(repConfig, repState) {\n    var es = repConfig.resetOnDom ? [runOnAttached(function (comp, _se) {\n      onLoad$5(comp, repConfig, repState);\n    }), runOnDetached(function (comp, _se) {\n      onUnload$2(comp, repConfig, repState);\n    })] : [loadEvent(repConfig, repState, onLoad$5)];\n    return derive$2(es);\n  };\n  var ActiveRepresenting = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    events: events$f\n  });\n  var memory$1 = function memory$1() {\n    var data = Cell(null);\n    var readState = function readState() {\n      return {\n        mode: 'memory',\n        value: data.get()\n      };\n    };\n    var isNotSet = function isNotSet() {\n      return data.get() === null;\n    };\n    var clear = function clear() {\n      data.set(null);\n    };\n    return nu$8({\n      set: data.set,\n      get: data.get,\n      isNotSet: isNotSet,\n      clear: clear,\n      readState: readState\n    });\n  };\n  var manual = function manual() {\n    var readState = noop;\n    return nu$8({\n      readState: readState\n    });\n  };\n  var dataset = function dataset() {\n    var dataByValue = Cell({});\n    var dataByText = Cell({});\n    var readState = function readState() {\n      return {\n        mode: 'dataset',\n        dataByValue: dataByValue.get(),\n        dataByText: dataByText.get()\n      };\n    };\n    var clear = function clear() {\n      dataByValue.set({});\n      dataByText.set({});\n    };\n    var lookup = function lookup(itemString) {\n      return get$g(dataByValue.get(), itemString).orThunk(function () {\n        return get$g(dataByText.get(), itemString);\n      });\n    };\n    var update = function update(items) {\n      var currentDataByValue = dataByValue.get();\n      var currentDataByText = dataByText.get();\n      var newDataByValue = {};\n      var newDataByText = {};\n      each$1(items, function (item) {\n        newDataByValue[item.value] = item;\n        get$g(item, 'meta').each(function (meta) {\n          get$g(meta, 'text').each(function (text) {\n            newDataByText[text] = item;\n          });\n        });\n      });\n      dataByValue.set(_objectSpread({}, currentDataByValue, newDataByValue));\n      dataByText.set(_objectSpread({}, currentDataByText, newDataByText));\n    };\n    return nu$8({\n      readState: readState,\n      lookup: lookup,\n      update: update,\n      clear: clear\n    });\n  };\n  var init$e = function init$e(spec) {\n    return spec.store.manager.state(spec);\n  };\n  var RepresentState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    memory: memory$1,\n    dataset: dataset,\n    manual: manual,\n    init: init$e\n  });\n  var setValue$2 = function setValue$2(component, repConfig, repState, data) {\n    var store = repConfig.store;\n    repState.update([data]);\n    store.setValue(component, data);\n    repConfig.onSetValue(component, data);\n  };\n  var getValue$2 = function getValue$2(component, repConfig, repState) {\n    var store = repConfig.store;\n    var key = store.getDataKey(component);\n    return repState.lookup(key).getOrThunk(function () {\n      return store.getFallbackEntry(key);\n    });\n  };\n  var onLoad$4 = function onLoad$4(component, repConfig, repState) {\n    var store = repConfig.store;\n    store.initialValue.each(function (data) {\n      setValue$2(component, repConfig, repState, data);\n    });\n  };\n  var onUnload$1 = function onUnload$1(component, repConfig, repState) {\n    repState.clear();\n  };\n  var DatasetStore = [option$3('initialValue'), required$1('getFallbackEntry'), required$1('getDataKey'), required$1('setValue'), output$1('manager', {\n    setValue: setValue$2,\n    getValue: getValue$2,\n    onLoad: onLoad$4,\n    onUnload: onUnload$1,\n    state: dataset\n  })];\n  var getValue$1 = function getValue$1(component, repConfig, _repState) {\n    return repConfig.store.getValue(component);\n  };\n  var setValue$1 = function setValue$1(component, repConfig, _repState, data) {\n    repConfig.store.setValue(component, data);\n    repConfig.onSetValue(component, data);\n  };\n  var onLoad$3 = function onLoad$3(component, repConfig, _repState) {\n    repConfig.store.initialValue.each(function (data) {\n      repConfig.store.setValue(component, data);\n    });\n  };\n  var ManualStore = [required$1('getValue'), defaulted('setValue', noop), option$3('initialValue'), output$1('manager', {\n    setValue: setValue$1,\n    getValue: getValue$1,\n    onLoad: onLoad$3,\n    onUnload: noop,\n    state: NoState.init\n  })];\n  var setValue = function setValue(component, repConfig, repState, data) {\n    repState.set(data);\n    repConfig.onSetValue(component, data);\n  };\n  var getValue = function getValue(component, repConfig, repState) {\n    return repState.get();\n  };\n  var onLoad$2 = function onLoad$2(component, repConfig, repState) {\n    repConfig.store.initialValue.each(function (initVal) {\n      if (repState.isNotSet()) {\n        repState.set(initVal);\n      }\n    });\n  };\n  var onUnload = function onUnload(component, repConfig, repState) {\n    repState.clear();\n  };\n  var MemoryStore = [option$3('initialValue'), output$1('manager', {\n    setValue: setValue,\n    getValue: getValue,\n    onLoad: onLoad$2,\n    onUnload: onUnload,\n    state: memory$1\n  })];\n  var RepresentSchema = [defaultedOf('store', {\n    mode: 'memory'\n  }, choose$1('mode', {\n    memory: MemoryStore,\n    manual: ManualStore,\n    dataset: DatasetStore\n  })), onHandler('onSetValue'), defaulted('resetOnDom', false)];\n  var Representing = create$4({\n    fields: RepresentSchema,\n    name: 'representing',\n    active: ActiveRepresenting,\n    apis: RepresentApis,\n    extra: {\n      setValueFrom: function setValueFrom(component, source) {\n        var value = Representing.getValue(source);\n        Representing.setValue(component, value);\n      }\n    },\n    state: RepresentState\n  });\n  var field = function field(name, forbidden) {\n    return defaultedObjOf(name, {}, map$2(forbidden, function (f) {\n      return forbid(f.name(), 'Cannot configure ' + f.name() + ' for ' + name);\n    }).concat([customField('dump', identity)]));\n  };\n  var get$3 = function get$3(data) {\n    return data.dump;\n  };\n  var augment = function augment(data, original) {\n    return _objectSpread({}, derive$1(original), data.dump);\n  };\n  var SketchBehaviours = {\n    field: field,\n    augment: augment,\n    get: get$3\n  };\n  var _placeholder = 'placeholder';\n  var adt$3 = Adt.generate([{\n    single: ['required', 'valueThunk']\n  }, {\n    multiple: ['required', 'valueThunks']\n  }]);\n  var isSubstituted = function isSubstituted(spec) {\n    return has$2(spec, 'uiType');\n  };\n  var subPlaceholder = function subPlaceholder(owner, detail, compSpec, placeholders) {\n    if (owner.exists(function (o) {\n      return o !== compSpec.owner;\n    })) {\n      return adt$3.single(true, constant$1(compSpec));\n    }\n    return get$g(placeholders, compSpec.name).fold(function () {\n      throw new Error('Unknown placeholder component: ' + compSpec.name + '\\nKnown: [' + keys(placeholders) + ']\\nNamespace: ' + owner.getOr('none') + '\\nSpec: ' + JSON.stringify(compSpec, null, 2));\n    }, function (newSpec) {\n      return newSpec.replace();\n    });\n  };\n  var scan = function scan(owner, detail, compSpec, placeholders) {\n    if (isSubstituted(compSpec) && compSpec.uiType === _placeholder) {\n      return subPlaceholder(owner, detail, compSpec, placeholders);\n    } else {\n      return adt$3.single(false, constant$1(compSpec));\n    }\n  };\n  var substitute = function substitute(owner, detail, compSpec, placeholders) {\n    var base = scan(owner, detail, compSpec, placeholders);\n    return base.fold(function (req, valueThunk) {\n      var value = isSubstituted(compSpec) ? valueThunk(detail, compSpec.config, compSpec.validated) : valueThunk(detail);\n      var childSpecs = get$g(value, 'components').getOr([]);\n      var substituted = bind$3(childSpecs, function (c) {\n        return substitute(owner, detail, c, placeholders);\n      });\n      return [_objectSpread({}, value, {\n        components: substituted\n      })];\n    }, function (req, valuesThunk) {\n      if (isSubstituted(compSpec)) {\n        var _values = valuesThunk(detail, compSpec.config, compSpec.validated);\n        var preprocessor = compSpec.validated.preprocess.getOr(identity);\n        return preprocessor(_values);\n      } else {\n        return valuesThunk(detail);\n      }\n    });\n  };\n  var substituteAll = function substituteAll(owner, detail, components, placeholders) {\n    return bind$3(components, function (c) {\n      return substitute(owner, detail, c, placeholders);\n    });\n  };\n  var oneReplace = function oneReplace(label, replacements) {\n    var called = false;\n    var used = function used() {\n      return called;\n    };\n    var replace = function replace() {\n      if (called) {\n        throw new Error('Trying to use the same placeholder more than once: ' + label);\n      }\n      called = true;\n      return replacements;\n    };\n    var required = function required() {\n      return replacements.fold(function (req, _) {\n        return req;\n      }, function (req, _) {\n        return req;\n      });\n    };\n    return {\n      name: constant$1(label),\n      required: required,\n      used: used,\n      replace: replace\n    };\n  };\n  var substitutePlaces = function substitutePlaces(owner, detail, components, placeholders) {\n    var ps = map$1(placeholders, function (ph, name) {\n      return oneReplace(name, ph);\n    });\n    var outcome = substituteAll(owner, detail, components, ps);\n    each(ps, function (p) {\n      if (p.used() === false && p.required()) {\n        throw new Error('Placeholder: ' + p.name() + ' was not found in components list\\nNamespace: ' + owner.getOr('none') + '\\nComponents: ' + JSON.stringify(detail.components, null, 2));\n      }\n    });\n    return outcome;\n  };\n  var single$2 = adt$3.single;\n  var multiple = adt$3.multiple;\n  var placeholder = constant$1(_placeholder);\n  var adt$2 = Adt.generate([{\n    required: ['data']\n  }, {\n    external: ['data']\n  }, {\n    optional: ['data']\n  }, {\n    group: ['data']\n  }]);\n  var fFactory = defaulted('factory', {\n    sketch: identity\n  });\n  var fSchema = defaulted('schema', []);\n  var fName = required$1('name');\n  var fPname = field$1('pname', 'pname', defaultedThunk(function (typeSpec) {\n    return '<alloy.' + generate$6(typeSpec.name) + '>';\n  }), anyValue());\n  var fGroupSchema = customField('schema', function () {\n    return [option$3('preprocess')];\n  });\n  var fDefaults = defaulted('defaults', constant$1({}));\n  var fOverrides = defaulted('overrides', constant$1({}));\n  var requiredSpec = objOf([fFactory, fSchema, fName, fPname, fDefaults, fOverrides]);\n  var externalSpec = objOf([fFactory, fSchema, fName, fDefaults, fOverrides]);\n  var optionalSpec = objOf([fFactory, fSchema, fName, fPname, fDefaults, fOverrides]);\n  var groupSpec = objOf([fFactory, fGroupSchema, fName, required$1('unit'), fPname, fDefaults, fOverrides]);\n  var asNamedPart = function asNamedPart(part) {\n    return part.fold(Optional.some, Optional.none, Optional.some, Optional.some);\n  };\n  var name$2 = function name$2(part) {\n    var get = function get(data) {\n      return data.name;\n    };\n    return part.fold(get, get, get, get);\n  };\n  var asCommon = function asCommon(part) {\n    return part.fold(identity, identity, identity, identity);\n  };\n  var convert = function convert(adtConstructor, partSchema) {\n    return function (spec) {\n      var data = asRawOrDie$1('Converting part type', partSchema, spec);\n      return adtConstructor(data);\n    };\n  };\n  var required = convert(adt$2.required, requiredSpec);\n  var external = convert(adt$2.external, externalSpec);\n  var optional = convert(adt$2.optional, optionalSpec);\n  var group = convert(adt$2.group, groupSpec);\n  var original = constant$1('entirety');\n  var PartType = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    required: required,\n    external: external,\n    optional: optional,\n    group: group,\n    asNamedPart: asNamedPart,\n    name: name$2,\n    asCommon: asCommon,\n    original: original\n  });\n  var combine = function combine(detail, data, partSpec, partValidated) {\n    return deepMerge(data.defaults(detail, partSpec, partValidated), partSpec, {\n      uid: detail.partUids[data.name]\n    }, data.overrides(detail, partSpec, partValidated));\n  };\n  var subs = function subs(owner, detail, parts) {\n    var internals = {};\n    var externals = {};\n    each$1(parts, function (part) {\n      part.fold(function (data) {\n        internals[data.pname] = single$2(true, function (detail, partSpec, partValidated) {\n          return data.factory.sketch(combine(detail, data, partSpec, partValidated));\n        });\n      }, function (data) {\n        var partSpec = detail.parts[data.name];\n        externals[data.name] = constant$1(data.factory.sketch(combine(detail, data, partSpec[original()]), partSpec));\n      }, function (data) {\n        internals[data.pname] = single$2(false, function (detail, partSpec, partValidated) {\n          return data.factory.sketch(combine(detail, data, partSpec, partValidated));\n        });\n      }, function (data) {\n        internals[data.pname] = multiple(true, function (detail, _partSpec, _partValidated) {\n          var units = detail[data.name];\n          return map$2(units, function (u) {\n            return data.factory.sketch(deepMerge(data.defaults(detail, u, _partValidated), u, data.overrides(detail, u)));\n          });\n        });\n      });\n    });\n    return {\n      internals: constant$1(internals),\n      externals: constant$1(externals)\n    };\n  };\n  var generate$3 = function generate$3(owner, parts) {\n    var r = {};\n    each$1(parts, function (part) {\n      asNamedPart(part).each(function (np) {\n        var g = doGenerateOne(owner, np.pname);\n        r[np.name] = function (config) {\n          var validated = asRawOrDie$1('Part: ' + np.name + ' in ' + owner, objOf(np.schema), config);\n          return _objectSpread({}, g, {\n            config: config,\n            validated: validated\n          });\n        };\n      });\n    });\n    return r;\n  };\n  var doGenerateOne = function doGenerateOne(owner, pname) {\n    return {\n      uiType: placeholder(),\n      owner: owner,\n      name: pname\n    };\n  };\n  var generateOne$1 = function generateOne$1(owner, pname, config) {\n    return {\n      uiType: placeholder(),\n      owner: owner,\n      name: pname,\n      config: config,\n      validated: {}\n    };\n  };\n  var schemas = function schemas(parts) {\n    return bind$3(parts, function (part) {\n      return part.fold(Optional.none, Optional.some, Optional.none, Optional.none).map(function (data) {\n        return requiredObjOf(data.name, data.schema.concat([snapshot(original())]));\n      }).toArray();\n    });\n  };\n  var names = function names(parts) {\n    return map$2(parts, name$2);\n  };\n  var substitutes = function substitutes(owner, detail, parts) {\n    return subs(owner, detail, parts);\n  };\n  var components$1 = function components$1(owner, detail, internals) {\n    return substitutePlaces(Optional.some(owner), detail, detail.components, internals);\n  };\n  var getPart = function getPart(component, detail, partKey) {\n    var uid = detail.partUids[partKey];\n    return component.getSystem().getByUid(uid).toOptional();\n  };\n  var getPartOrDie = function getPartOrDie(component, detail, partKey) {\n    return getPart(component, detail, partKey).getOrDie('Could not find part: ' + partKey);\n  };\n  var getParts = function getParts(component, detail, partKeys) {\n    var r = {};\n    var uids = detail.partUids;\n    var system = component.getSystem();\n    each$1(partKeys, function (pk) {\n      r[pk] = constant$1(system.getByUid(uids[pk]));\n    });\n    return r;\n  };\n  var getAllParts = function getAllParts(component, detail) {\n    var system = component.getSystem();\n    return map$1(detail.partUids, function (pUid, _k) {\n      return constant$1(system.getByUid(pUid));\n    });\n  };\n  var getAllPartNames = function getAllPartNames(detail) {\n    return keys(detail.partUids);\n  };\n  var getPartsOrDie = function getPartsOrDie(component, detail, partKeys) {\n    var r = {};\n    var uids = detail.partUids;\n    var system = component.getSystem();\n    each$1(partKeys, function (pk) {\n      r[pk] = constant$1(system.getByUid(uids[pk]).getOrDie());\n    });\n    return r;\n  };\n  var defaultUids = function defaultUids(baseUid, partTypes) {\n    var partNames = names(partTypes);\n    return wrapAll(map$2(partNames, function (pn) {\n      return {\n        key: pn,\n        value: baseUid + '-' + pn\n      };\n    }));\n  };\n  var defaultUidsSchema = function defaultUidsSchema(partTypes) {\n    return field$1('partUids', 'partUids', mergeWithThunk(function (spec) {\n      return defaultUids(spec.uid, partTypes);\n    }), anyValue());\n  };\n  var AlloyParts = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$3,\n    generateOne: generateOne$1,\n    schemas: schemas,\n    names: names,\n    substitutes: substitutes,\n    components: components$1,\n    defaultUids: defaultUids,\n    defaultUidsSchema: defaultUidsSchema,\n    getAllParts: getAllParts,\n    getAllPartNames: getAllPartNames,\n    getPart: getPart,\n    getPartOrDie: getPartOrDie,\n    getParts: getParts,\n    getPartsOrDie: getPartsOrDie\n  });\n  var base = function base(partSchemas, partUidsSchemas) {\n    var ps = partSchemas.length > 0 ? [requiredObjOf('parts', partSchemas)] : [];\n    return ps.concat([required$1('uid'), defaulted('dom', {}), defaulted('components', []), snapshot('originalSpec'), defaulted('debug.sketcher', {})]).concat(partUidsSchemas);\n  };\n  var asRawOrDie = function asRawOrDie(label, schema, spec, partSchemas, partUidsSchemas) {\n    var baseS = base(partSchemas, partUidsSchemas);\n    return asRawOrDie$1(label + ' [SpecSchema]', objOfOnly(baseS.concat(schema)), spec);\n  };\n  var single$1 = function single$1(owner, schema, factory, spec) {\n    var specWithUid = supplyUid(spec);\n    var detail = asRawOrDie(owner, schema, specWithUid, [], []);\n    return factory(detail, specWithUid);\n  };\n  var composite$1 = function composite$1(owner, schema, partTypes, factory, spec) {\n    var specWithUid = supplyUid(spec);\n    var partSchemas = schemas(partTypes);\n    var partUidsSchema = defaultUidsSchema(partTypes);\n    var detail = asRawOrDie(owner, schema, specWithUid, partSchemas, [partUidsSchema]);\n    var subs = substitutes(owner, detail, partTypes);\n    var components = components$1(owner, detail, subs.internals());\n    return factory(detail, components, specWithUid, subs.externals());\n  };\n  var hasUid = function hasUid(spec) {\n    return has$2(spec, 'uid');\n  };\n  var supplyUid = function supplyUid(spec) {\n    return hasUid(spec) ? spec : _objectSpread({}, spec, {\n      uid: generate$5('uid')\n    });\n  };\n  var isSketchSpec = function isSketchSpec(spec) {\n    return spec.uid !== undefined;\n  };\n  var singleSchema = objOfOnly([required$1('name'), required$1('factory'), required$1('configFields'), defaulted('apis', {}), defaulted('extraApis', {})]);\n  var compositeSchema = objOfOnly([required$1('name'), required$1('factory'), required$1('configFields'), required$1('partFields'), defaulted('apis', {}), defaulted('extraApis', {})]);\n  var single = function single(rawConfig) {\n    var config = asRawOrDie$1('Sketcher for ' + rawConfig.name, singleSchema, rawConfig);\n    var sketch = function sketch(spec) {\n      return single$1(config.name, config.configFields, config.factory, spec);\n    };\n    var apis = map$1(config.apis, makeApi);\n    var extraApis = map$1(config.extraApis, function (f, k) {\n      return markAsExtraApi(f, k);\n    });\n    return _objectSpread({\n      name: config.name,\n      configFields: config.configFields,\n      sketch: sketch\n    }, apis, extraApis);\n  };\n  var composite = function composite(rawConfig) {\n    var config = asRawOrDie$1('Sketcher for ' + rawConfig.name, compositeSchema, rawConfig);\n    var sketch = function sketch(spec) {\n      return composite$1(config.name, config.configFields, config.partFields, config.factory, spec);\n    };\n    var parts = generate$3(config.name, config.partFields);\n    var apis = map$1(config.apis, makeApi);\n    var extraApis = map$1(config.extraApis, function (f, k) {\n      return markAsExtraApi(f, k);\n    });\n    return _objectSpread({\n      name: config.name,\n      partFields: config.partFields,\n      configFields: config.configFields,\n      sketch: sketch,\n      parts: parts\n    }, apis, extraApis);\n  };\n  var inside = function inside(target) {\n    return isTag('input')(target) && get$f(target, 'type') !== 'radio' || isTag('textarea')(target);\n  };\n  var getCurrent = function getCurrent(component, composeConfig, _composeState) {\n    return composeConfig.find(component);\n  };\n  var ComposeApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getCurrent: getCurrent\n  });\n  var ComposeSchema = [required$1('find')];\n  var Composing = create$4({\n    fields: ComposeSchema,\n    name: 'composing',\n    apis: ComposeApis\n  });\n  var nativeDisabled = ['input', 'button', 'textarea', 'select'];\n  var onLoad$1 = function onLoad$1(component, disableConfig, disableState) {\n    var f = disableConfig.disabled() ? disable : enable;\n    f(component, disableConfig);\n  };\n  var hasNative = function hasNative(component, config) {\n    return config.useNative === true && contains$2(nativeDisabled, name$3(component.element));\n  };\n  var nativeIsDisabled = function nativeIsDisabled(component) {\n    return has$1(component.element, 'disabled');\n  };\n  var nativeDisable = function nativeDisable(component) {\n    set$9(component.element, 'disabled', 'disabled');\n  };\n  var nativeEnable = function nativeEnable(component) {\n    remove$7(component.element, 'disabled');\n  };\n  var ariaIsDisabled = function ariaIsDisabled(component) {\n    return get$f(component.element, 'aria-disabled') === 'true';\n  };\n  var ariaDisable = function ariaDisable(component) {\n    set$9(component.element, 'aria-disabled', 'true');\n  };\n  var ariaEnable = function ariaEnable(component) {\n    set$9(component.element, 'aria-disabled', 'false');\n  };\n  var disable = function disable(component, disableConfig, _disableState) {\n    disableConfig.disableClass.each(function (disableClass) {\n      add$2(component.element, disableClass);\n    });\n    var f = hasNative(component, disableConfig) ? nativeDisable : ariaDisable;\n    f(component);\n    disableConfig.onDisabled(component);\n  };\n  var enable = function enable(component, disableConfig, _disableState) {\n    disableConfig.disableClass.each(function (disableClass) {\n      remove$2(component.element, disableClass);\n    });\n    var f = hasNative(component, disableConfig) ? nativeEnable : ariaEnable;\n    f(component);\n    disableConfig.onEnabled(component);\n  };\n  var isDisabled = function isDisabled(component, disableConfig) {\n    return hasNative(component, disableConfig) ? nativeIsDisabled(component) : ariaIsDisabled(component);\n  };\n  var set$4 = function set$4(component, disableConfig, disableState, disabled) {\n    var f = disabled ? disable : enable;\n    f(component, disableConfig);\n  };\n  var DisableApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    enable: enable,\n    disable: disable,\n    isDisabled: isDisabled,\n    onLoad: onLoad$1,\n    set: set$4\n  });\n  var exhibit$5 = function exhibit$5(base, disableConfig) {\n    return nu$7({\n      classes: disableConfig.disabled() ? disableConfig.disableClass.toArray() : []\n    });\n  };\n  var events$e = function events$e(disableConfig, disableState) {\n    return derive$2([abort(execute$5(), function (component, _simulatedEvent) {\n      return isDisabled(component, disableConfig);\n    }), loadEvent(disableConfig, disableState, onLoad$1)]);\n  };\n  var ActiveDisable = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    exhibit: exhibit$5,\n    events: events$e\n  });\n  var DisableSchema = [defaultedFunction('disabled', never), defaulted('useNative', true), option$3('disableClass'), onHandler('onDisabled'), onHandler('onEnabled')];\n  var Disabling = create$4({\n    fields: DisableSchema,\n    name: 'disabling',\n    active: ActiveDisable,\n    apis: DisableApis\n  });\n  var dehighlightAllExcept = function dehighlightAllExcept(component, hConfig, hState, skip) {\n    var highlighted = descendants(component.element, '.' + hConfig.highlightClass);\n    each$1(highlighted, function (h) {\n      var shouldSkip = exists(skip, function (skipComp) {\n        return eq(skipComp.element, h);\n      });\n      if (!shouldSkip) {\n        remove$2(h, hConfig.highlightClass);\n        component.getSystem().getByDom(h).each(function (target) {\n          hConfig.onDehighlight(component, target);\n          emit(target, dehighlight$1());\n        });\n      }\n    });\n  };\n  var dehighlightAll = function dehighlightAll(component, hConfig, hState) {\n    return dehighlightAllExcept(component, hConfig, hState, []);\n  };\n  var dehighlight = function dehighlight(component, hConfig, hState, target) {\n    if (isHighlighted(component, hConfig, hState, target)) {\n      remove$2(target.element, hConfig.highlightClass);\n      hConfig.onDehighlight(component, target);\n      emit(target, dehighlight$1());\n    }\n  };\n  var highlight = function highlight(component, hConfig, hState, target) {\n    dehighlightAllExcept(component, hConfig, hState, [target]);\n    if (!isHighlighted(component, hConfig, hState, target)) {\n      add$2(target.element, hConfig.highlightClass);\n      hConfig.onHighlight(component, target);\n      emit(target, highlight$1());\n    }\n  };\n  var highlightFirst = function highlightFirst(component, hConfig, hState) {\n    getFirst(component, hConfig).each(function (firstComp) {\n      highlight(component, hConfig, hState, firstComp);\n    });\n  };\n  var highlightLast = function highlightLast(component, hConfig, hState) {\n    getLast(component, hConfig).each(function (lastComp) {\n      highlight(component, hConfig, hState, lastComp);\n    });\n  };\n  var highlightAt = function highlightAt(component, hConfig, hState, index) {\n    getByIndex(component, hConfig, hState, index).fold(function (err) {\n      throw err;\n    }, function (firstComp) {\n      highlight(component, hConfig, hState, firstComp);\n    });\n  };\n  var highlightBy = function highlightBy(component, hConfig, hState, predicate) {\n    var candidates = getCandidates(component, hConfig);\n    var targetComp = find$5(candidates, predicate);\n    targetComp.each(function (c) {\n      highlight(component, hConfig, hState, c);\n    });\n  };\n  var isHighlighted = function isHighlighted(component, hConfig, hState, queryTarget) {\n    return has(queryTarget.element, hConfig.highlightClass);\n  };\n  var getHighlighted = function getHighlighted(component, hConfig, _hState) {\n    return descendant(component.element, '.' + hConfig.highlightClass).bind(function (e) {\n      return component.getSystem().getByDom(e).toOptional();\n    });\n  };\n  var getByIndex = function getByIndex(component, hConfig, hState, index) {\n    var items = descendants(component.element, '.' + hConfig.itemClass);\n    return Optional.from(items[index]).fold(function () {\n      return Result.error(new Error('No element found with index ' + index));\n    }, component.getSystem().getByDom);\n  };\n  var getFirst = function getFirst(component, hConfig, _hState) {\n    return descendant(component.element, '.' + hConfig.itemClass).bind(function (e) {\n      return component.getSystem().getByDom(e).toOptional();\n    });\n  };\n  var getLast = function getLast(component, hConfig, _hState) {\n    var items = descendants(component.element, '.' + hConfig.itemClass);\n    var last = items.length > 0 ? Optional.some(items[items.length - 1]) : Optional.none();\n    return last.bind(function (c) {\n      return component.getSystem().getByDom(c).toOptional();\n    });\n  };\n  var getDelta$2 = function getDelta$2(component, hConfig, hState, delta) {\n    var items = descendants(component.element, '.' + hConfig.itemClass);\n    var current = findIndex$1(items, function (item) {\n      return has(item, hConfig.highlightClass);\n    });\n    return current.bind(function (selected) {\n      var dest = cycleBy(selected, delta, 0, items.length - 1);\n      return component.getSystem().getByDom(items[dest]).toOptional();\n    });\n  };\n  var getPrevious = function getPrevious(component, hConfig, hState) {\n    return getDelta$2(component, hConfig, hState, -1);\n  };\n  var getNext = function getNext(component, hConfig, hState) {\n    return getDelta$2(component, hConfig, hState, +1);\n  };\n  var getCandidates = function getCandidates(component, hConfig, _hState) {\n    var items = descendants(component.element, '.' + hConfig.itemClass);\n    return cat(map$2(items, function (i) {\n      return component.getSystem().getByDom(i).toOptional();\n    }));\n  };\n  var HighlightApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    dehighlightAll: dehighlightAll,\n    dehighlight: dehighlight,\n    highlight: highlight,\n    highlightFirst: highlightFirst,\n    highlightLast: highlightLast,\n    highlightAt: highlightAt,\n    highlightBy: highlightBy,\n    isHighlighted: isHighlighted,\n    getHighlighted: getHighlighted,\n    getFirst: getFirst,\n    getLast: getLast,\n    getPrevious: getPrevious,\n    getNext: getNext,\n    getCandidates: getCandidates\n  });\n  var HighlightSchema = [required$1('highlightClass'), required$1('itemClass'), onHandler('onHighlight'), onHandler('onDehighlight')];\n  var Highlighting = create$4({\n    fields: HighlightSchema,\n    name: 'highlighting',\n    apis: HighlightApis\n  });\n  var BACKSPACE = [8];\n  var TAB = [9];\n  var ENTER = [13];\n  var ESCAPE = [27];\n  var SPACE = [32];\n  var LEFT = [37];\n  var UP = [38];\n  var RIGHT = [39];\n  var DOWN = [40];\n  var cyclePrev = function cyclePrev(values, index, predicate) {\n    var before = reverse(values.slice(0, index));\n    var after = reverse(values.slice(index + 1));\n    return find$5(before.concat(after), predicate);\n  };\n  var tryPrev = function tryPrev(values, index, predicate) {\n    var before = reverse(values.slice(0, index));\n    return find$5(before, predicate);\n  };\n  var cycleNext = function cycleNext(values, index, predicate) {\n    var before = values.slice(0, index);\n    var after = values.slice(index + 1);\n    return find$5(after.concat(before), predicate);\n  };\n  var tryNext = function tryNext(values, index, predicate) {\n    var after = values.slice(index + 1);\n    return find$5(after, predicate);\n  };\n  var inSet = function inSet(keys) {\n    return function (event) {\n      var raw = event.raw;\n      return contains$2(keys, raw.which);\n    };\n  };\n  var and = function and(preds) {\n    return function (event) {\n      return forall(preds, function (pred) {\n        return pred(event);\n      });\n    };\n  };\n  var isShift = function isShift(event) {\n    var raw = event.raw;\n    return raw.shiftKey === true;\n  };\n  var isControl = function isControl(event) {\n    var raw = event.raw;\n    return raw.ctrlKey === true;\n  };\n  var isNotShift = not(isShift);\n  var rule = function rule(matches, action) {\n    return {\n      matches: matches,\n      classification: action\n    };\n  };\n  var choose = function choose(transitions, event) {\n    var transition = find$5(transitions, function (t) {\n      return t.matches(event);\n    });\n    return transition.map(function (t) {\n      return t.classification;\n    });\n  };\n  var reportFocusShifting = function reportFocusShifting(component, prevFocus, newFocus) {\n    var noChange = prevFocus.exists(function (p) {\n      return newFocus.exists(function (n) {\n        return eq(n, p);\n      });\n    });\n    if (!noChange) {\n      emitWith(component, focusShifted(), {\n        prevFocus: prevFocus,\n        newFocus: newFocus\n      });\n    }\n  };\n  var dom$2 = function dom$2() {\n    var get = function get(component) {\n      return search(component.element);\n    };\n    var set = function set(component, focusee) {\n      var prevFocus = get(component);\n      component.getSystem().triggerFocus(focusee, component.element);\n      var newFocus = get(component);\n      reportFocusShifting(component, prevFocus, newFocus);\n    };\n    return {\n      get: get,\n      set: set\n    };\n  };\n  var highlights = function highlights() {\n    var get = function get(component) {\n      return Highlighting.getHighlighted(component).map(function (item) {\n        return item.element;\n      });\n    };\n    var set = function set(component, element) {\n      var prevFocus = get(component);\n      component.getSystem().getByDom(element).fold(noop, function (item) {\n        Highlighting.highlight(component, item);\n      });\n      var newFocus = get(component);\n      reportFocusShifting(component, prevFocus, newFocus);\n    };\n    return {\n      get: get,\n      set: set\n    };\n  };\n  var FocusInsideModes;\n  (function (FocusInsideModes) {\n    FocusInsideModes['OnFocusMode'] = 'onFocus';\n    FocusInsideModes['OnEnterOrSpaceMode'] = 'onEnterOrSpace';\n    FocusInsideModes['OnApiMode'] = 'onApi';\n  })(FocusInsideModes || (FocusInsideModes = {}));\n  var typical = function typical(infoSchema, stateInit, getKeydownRules, getKeyupRules, optFocusIn) {\n    var schema = function schema() {\n      return infoSchema.concat([defaulted('focusManager', dom$2()), defaultedOf('focusInside', 'onFocus', valueOf(function (val) {\n        return contains$2(['onFocus', 'onEnterOrSpace', 'onApi'], val) ? Result.value(val) : Result.error('Invalid value for focusInside');\n      })), output$1('handler', me), output$1('state', stateInit), output$1('sendFocusIn', optFocusIn)]);\n    };\n    var processKey = function processKey(component, simulatedEvent, getRules, keyingConfig, keyingState) {\n      var rules = getRules(component, simulatedEvent, keyingConfig, keyingState);\n      return choose(rules, simulatedEvent.event).bind(function (rule) {\n        return rule(component, simulatedEvent, keyingConfig, keyingState);\n      });\n    };\n    var toEvents = function toEvents(keyingConfig, keyingState) {\n      var onFocusHandler = keyingConfig.focusInside !== FocusInsideModes.OnFocusMode ? Optional.none() : optFocusIn(keyingConfig).map(function (focusIn) {\n        return run$1(focus$4(), function (component, simulatedEvent) {\n          focusIn(component, keyingConfig, keyingState);\n          simulatedEvent.stop();\n        });\n      });\n      var tryGoInsideComponent = function tryGoInsideComponent(component, simulatedEvent) {\n        var isEnterOrSpace = inSet(SPACE.concat(ENTER))(simulatedEvent.event);\n        if (keyingConfig.focusInside === FocusInsideModes.OnEnterOrSpaceMode && isEnterOrSpace && isSource(component, simulatedEvent)) {\n          optFocusIn(keyingConfig).each(function (focusIn) {\n            focusIn(component, keyingConfig, keyingState);\n            simulatedEvent.stop();\n          });\n        }\n      };\n      var keyboardEvents = [run$1(keydown(), function (component, simulatedEvent) {\n        processKey(component, simulatedEvent, getKeydownRules, keyingConfig, keyingState).fold(function () {\n          tryGoInsideComponent(component, simulatedEvent);\n        }, function (_) {\n          simulatedEvent.stop();\n        });\n      }), run$1(keyup(), function (component, simulatedEvent) {\n        processKey(component, simulatedEvent, getKeyupRules, keyingConfig, keyingState).each(function (_) {\n          simulatedEvent.stop();\n        });\n      })];\n      return derive$2(onFocusHandler.toArray().concat(keyboardEvents));\n    };\n    var me = {\n      schema: schema,\n      processKey: processKey,\n      toEvents: toEvents\n    };\n    return me;\n  };\n  var create$2 = function create$2(cyclicField) {\n    var schema = [option$3('onEscape'), option$3('onEnter'), defaulted('selector', '[data-alloy-tabstop=\"true\"]:not(:disabled)'), defaulted('firstTabstop', 0), defaulted('useTabstopAt', always), option$3('visibilitySelector')].concat([cyclicField]);\n    var isVisible = function isVisible(tabbingConfig, element) {\n      var target = tabbingConfig.visibilitySelector.bind(function (sel) {\n        return closest$1(element, sel);\n      }).getOr(element);\n      return get$d(target) > 0;\n    };\n    var findInitial = function findInitial(component, tabbingConfig) {\n      var tabstops = descendants(component.element, tabbingConfig.selector);\n      var visibles = filter$2(tabstops, function (elem) {\n        return isVisible(tabbingConfig, elem);\n      });\n      return Optional.from(visibles[tabbingConfig.firstTabstop]);\n    };\n    var findCurrent = function findCurrent(component, tabbingConfig) {\n      return tabbingConfig.focusManager.get(component).bind(function (elem) {\n        return closest$1(elem, tabbingConfig.selector);\n      });\n    };\n    var isTabstop = function isTabstop(tabbingConfig, element) {\n      return isVisible(tabbingConfig, element) && tabbingConfig.useTabstopAt(element);\n    };\n    var focusIn = function focusIn(component, tabbingConfig, _tabbingState) {\n      findInitial(component, tabbingConfig).each(function (target) {\n        tabbingConfig.focusManager.set(component, target);\n      });\n    };\n    var goFromTabstop = function goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle) {\n      return cycle(tabstops, stopIndex, function (elem) {\n        return isTabstop(tabbingConfig, elem);\n      }).fold(function () {\n        return tabbingConfig.cyclic ? Optional.some(true) : Optional.none();\n      }, function (target) {\n        tabbingConfig.focusManager.set(component, target);\n        return Optional.some(true);\n      });\n    };\n    var go = function go(component, _simulatedEvent, tabbingConfig, cycle) {\n      var tabstops = descendants(component.element, tabbingConfig.selector);\n      return findCurrent(component, tabbingConfig).bind(function (tabstop) {\n        var optStopIndex = findIndex$1(tabstops, curry(eq, tabstop));\n        return optStopIndex.bind(function (stopIndex) {\n          return goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle);\n        });\n      });\n    };\n    var goBackwards = function goBackwards(component, simulatedEvent, tabbingConfig) {\n      var navigate = tabbingConfig.cyclic ? cyclePrev : tryPrev;\n      return go(component, simulatedEvent, tabbingConfig, navigate);\n    };\n    var goForwards = function goForwards(component, simulatedEvent, tabbingConfig) {\n      var navigate = tabbingConfig.cyclic ? cycleNext : tryNext;\n      return go(component, simulatedEvent, tabbingConfig, navigate);\n    };\n    var isFirstChild = function isFirstChild(elem) {\n      return parentNode(elem).bind(firstChild).exists(function (child) {\n        return eq(child, elem);\n      });\n    };\n    var goFromPseudoTabstop = function goFromPseudoTabstop(component, simulatedEvent, tabbingConfig) {\n      return findCurrent(component, tabbingConfig).filter(function (elem) {\n        return !tabbingConfig.useTabstopAt(elem);\n      }).bind(function (elem) {\n        return (isFirstChild(elem) ? goBackwards : goForwards)(component, simulatedEvent, tabbingConfig);\n      });\n    };\n    var execute = function execute(component, simulatedEvent, tabbingConfig) {\n      return tabbingConfig.onEnter.bind(function (f) {\n        return f(component, simulatedEvent);\n      });\n    };\n    var exit = function exit(component, simulatedEvent, tabbingConfig) {\n      return tabbingConfig.onEscape.bind(function (f) {\n        return f(component, simulatedEvent);\n      });\n    };\n    var getKeydownRules = constant$1([rule(and([isShift, inSet(TAB)]), goBackwards), rule(inSet(TAB), goForwards), rule(and([isNotShift, inSet(ENTER)]), execute)]);\n    var getKeyupRules = constant$1([rule(inSet(ESCAPE), exit), rule(inSet(TAB), goFromPseudoTabstop)]);\n    return typical(schema, NoState.init, getKeydownRules, getKeyupRules, function () {\n      return Optional.some(focusIn);\n    });\n  };\n  var AcyclicType = create$2(customField('cyclic', never));\n  var CyclicType = create$2(customField('cyclic', always));\n  var doDefaultExecute = function doDefaultExecute(component, _simulatedEvent, focused) {\n    dispatch(component, focused, execute$5());\n    return Optional.some(true);\n  };\n  var defaultExecute = function defaultExecute(component, simulatedEvent, focused) {\n    var isComplex = inside(focused) && inSet(SPACE)(simulatedEvent.event);\n    return isComplex ? Optional.none() : doDefaultExecute(component, simulatedEvent, focused);\n  };\n  var stopEventForFirefox = function stopEventForFirefox(_component, _simulatedEvent) {\n    return Optional.some(true);\n  };\n  var schema$v = [defaulted('execute', defaultExecute), defaulted('useSpace', false), defaulted('useEnter', true), defaulted('useControlEnter', false), defaulted('useDown', false)];\n  var execute$4 = function execute$4(component, simulatedEvent, executeConfig) {\n    return executeConfig.execute(component, simulatedEvent, component.element);\n  };\n  var getKeydownRules$5 = function getKeydownRules$5(component, _simulatedEvent, executeConfig, _executeState) {\n    var spaceExec = executeConfig.useSpace && !inside(component.element) ? SPACE : [];\n    var enterExec = executeConfig.useEnter ? ENTER : [];\n    var downExec = executeConfig.useDown ? DOWN : [];\n    var execKeys = spaceExec.concat(enterExec).concat(downExec);\n    return [rule(inSet(execKeys), execute$4)].concat(executeConfig.useControlEnter ? [rule(and([isControl, inSet(ENTER)]), execute$4)] : []);\n  };\n  var getKeyupRules$5 = function getKeyupRules$5(component, _simulatedEvent, executeConfig, _executeState) {\n    return executeConfig.useSpace && !inside(component.element) ? [rule(inSet(SPACE), stopEventForFirefox)] : [];\n  };\n  var ExecutionType = typical(schema$v, NoState.init, getKeydownRules$5, getKeyupRules$5, function () {\n    return Optional.none();\n  });\n  var flatgrid$1 = function flatgrid$1() {\n    var dimensions = value$2();\n    var setGridSize = function setGridSize(numRows, numColumns) {\n      dimensions.set({\n        numRows: numRows,\n        numColumns: numColumns\n      });\n    };\n    var getNumRows = function getNumRows() {\n      return dimensions.get().map(function (d) {\n        return d.numRows;\n      });\n    };\n    var getNumColumns = function getNumColumns() {\n      return dimensions.get().map(function (d) {\n        return d.numColumns;\n      });\n    };\n    return nu$8({\n      readState: function readState() {\n        return dimensions.get().map(function (d) {\n          return {\n            numRows: String(d.numRows),\n            numColumns: String(d.numColumns)\n          };\n        }).getOr({\n          numRows: '?',\n          numColumns: '?'\n        });\n      },\n      setGridSize: setGridSize,\n      getNumRows: getNumRows,\n      getNumColumns: getNumColumns\n    });\n  };\n  var init$d = function init$d(spec) {\n    return spec.state(spec);\n  };\n  var KeyingState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    flatgrid: flatgrid$1,\n    init: init$d\n  });\n  var useH = function useH(movement) {\n    return function (component, simulatedEvent, config, state) {\n      var move = movement(component.element);\n      return use(move, component, simulatedEvent, config, state);\n    };\n  };\n  var west$1 = function west$1(moveLeft, moveRight) {\n    var movement = onDirection(moveLeft, moveRight);\n    return useH(movement);\n  };\n  var east$1 = function east$1(moveLeft, moveRight) {\n    var movement = onDirection(moveRight, moveLeft);\n    return useH(movement);\n  };\n  var useV = function useV(move) {\n    return function (component, simulatedEvent, config, state) {\n      return use(move, component, simulatedEvent, config, state);\n    };\n  };\n  var use = function use(move, component, simulatedEvent, config, state) {\n    var outcome = config.focusManager.get(component).bind(function (focused) {\n      return move(component.element, focused, config, state);\n    });\n    return outcome.map(function (newFocus) {\n      config.focusManager.set(component, newFocus);\n      return true;\n    });\n  };\n  var north$1 = useV;\n  var south$1 = useV;\n  var move$1 = useV;\n  var isHidden$1 = function isHidden$1(dom) {\n    return dom.offsetWidth <= 0 && dom.offsetHeight <= 0;\n  };\n  var isVisible = function isVisible(element) {\n    return !isHidden$1(element.dom);\n  };\n  var locate = function locate(candidates, predicate) {\n    return findIndex$1(candidates, predicate).map(function (index) {\n      return {\n        index: index,\n        candidates: candidates\n      };\n    });\n  };\n  var locateVisible = function locateVisible(container, current, selector) {\n    var predicate = function predicate(x) {\n      return eq(x, current);\n    };\n    var candidates = descendants(container, selector);\n    var visible = filter$2(candidates, isVisible);\n    return locate(visible, predicate);\n  };\n  var findIndex = function findIndex(elements, target) {\n    return findIndex$1(elements, function (elem) {\n      return eq(target, elem);\n    });\n  };\n  var withGrid = function withGrid(values, index, numCols, f) {\n    var oldRow = Math.floor(index / numCols);\n    var oldColumn = index % numCols;\n    return f(oldRow, oldColumn).bind(function (address) {\n      var newIndex = address.row * numCols + address.column;\n      return newIndex >= 0 && newIndex < values.length ? Optional.some(values[newIndex]) : Optional.none();\n    });\n  };\n  var cycleHorizontal$1 = function cycleHorizontal$1(values, index, numRows, numCols, delta) {\n    return withGrid(values, index, numCols, function (oldRow, oldColumn) {\n      var onLastRow = oldRow === numRows - 1;\n      var colsInRow = onLastRow ? values.length - oldRow * numCols : numCols;\n      var newColumn = cycleBy(oldColumn, delta, 0, colsInRow - 1);\n      return Optional.some({\n        row: oldRow,\n        column: newColumn\n      });\n    });\n  };\n  var cycleVertical$1 = function cycleVertical$1(values, index, numRows, numCols, delta) {\n    return withGrid(values, index, numCols, function (oldRow, oldColumn) {\n      var newRow = cycleBy(oldRow, delta, 0, numRows - 1);\n      var onLastRow = newRow === numRows - 1;\n      var colsInRow = onLastRow ? values.length - newRow * numCols : numCols;\n      var newCol = clamp(oldColumn, 0, colsInRow - 1);\n      return Optional.some({\n        row: newRow,\n        column: newCol\n      });\n    });\n  };\n  var cycleRight$1 = function cycleRight$1(values, index, numRows, numCols) {\n    return cycleHorizontal$1(values, index, numRows, numCols, +1);\n  };\n  var cycleLeft$1 = function cycleLeft$1(values, index, numRows, numCols) {\n    return cycleHorizontal$1(values, index, numRows, numCols, -1);\n  };\n  var cycleUp$1 = function cycleUp$1(values, index, numRows, numCols) {\n    return cycleVertical$1(values, index, numRows, numCols, -1);\n  };\n  var cycleDown$1 = function cycleDown$1(values, index, numRows, numCols) {\n    return cycleVertical$1(values, index, numRows, numCols, +1);\n  };\n  var schema$u = [required$1('selector'), defaulted('execute', defaultExecute), onKeyboardHandler('onEscape'), defaulted('captureTab', false), initSize()];\n  var focusIn$3 = function focusIn$3(component, gridConfig, _gridState) {\n    descendant(component.element, gridConfig.selector).each(function (first) {\n      gridConfig.focusManager.set(component, first);\n    });\n  };\n  var findCurrent$1 = function findCurrent$1(component, gridConfig) {\n    return gridConfig.focusManager.get(component).bind(function (elem) {\n      return closest$1(elem, gridConfig.selector);\n    });\n  };\n  var execute$3 = function execute$3(component, simulatedEvent, gridConfig, _gridState) {\n    return findCurrent$1(component, gridConfig).bind(function (focused) {\n      return gridConfig.execute(component, simulatedEvent, focused);\n    });\n  };\n  var doMove$2 = function doMove$2(cycle) {\n    return function (element, focused, gridConfig, gridState) {\n      return locateVisible(element, focused, gridConfig.selector).bind(function (identified) {\n        return cycle(identified.candidates, identified.index, gridState.getNumRows().getOr(gridConfig.initSize.numRows), gridState.getNumColumns().getOr(gridConfig.initSize.numColumns));\n      });\n    };\n  };\n  var handleTab = function handleTab(_component, _simulatedEvent, gridConfig) {\n    return gridConfig.captureTab ? Optional.some(true) : Optional.none();\n  };\n  var doEscape$1 = function doEscape$1(component, simulatedEvent, gridConfig) {\n    return gridConfig.onEscape(component, simulatedEvent);\n  };\n  var moveLeft$3 = doMove$2(cycleLeft$1);\n  var moveRight$3 = doMove$2(cycleRight$1);\n  var moveNorth$1 = doMove$2(cycleUp$1);\n  var moveSouth$1 = doMove$2(cycleDown$1);\n  var getKeydownRules$4 = constant$1([rule(inSet(LEFT), west$1(moveLeft$3, moveRight$3)), rule(inSet(RIGHT), east$1(moveLeft$3, moveRight$3)), rule(inSet(UP), north$1(moveNorth$1)), rule(inSet(DOWN), south$1(moveSouth$1)), rule(and([isShift, inSet(TAB)]), handleTab), rule(and([isNotShift, inSet(TAB)]), handleTab), rule(inSet(SPACE.concat(ENTER)), execute$3)]);\n  var getKeyupRules$4 = constant$1([rule(inSet(ESCAPE), doEscape$1), rule(inSet(SPACE), stopEventForFirefox)]);\n  var FlatgridType = typical(schema$u, flatgrid$1, getKeydownRules$4, getKeyupRules$4, function () {\n    return Optional.some(focusIn$3);\n  });\n  var f = function f(container, selector, current, delta, getNewIndex) {\n    var isDisabledButton = function isDisabledButton(candidate) {\n      return name$3(candidate) === 'button' && get$f(candidate, 'disabled') === 'disabled';\n    };\n    var tryNewIndex = function tryNewIndex(initial, index, candidates) {\n      return getNewIndex(initial, index, delta, 0, candidates.length - 1, candidates[index], function (newIndex) {\n        return isDisabledButton(candidates[newIndex]) ? tryNewIndex(initial, newIndex, candidates) : Optional.from(candidates[newIndex]);\n      });\n    };\n    return locateVisible(container, current, selector).bind(function (identified) {\n      var index = identified.index;\n      var candidates = identified.candidates;\n      return tryNewIndex(index, index, candidates);\n    });\n  };\n  var horizontalWithoutCycles = function horizontalWithoutCycles(container, selector, current, delta) {\n    return f(container, selector, current, delta, function (prevIndex, v, d, min, max, oldCandidate, onNewIndex) {\n      var newIndex = clamp(v + d, min, max);\n      return newIndex === prevIndex ? Optional.from(oldCandidate) : onNewIndex(newIndex);\n    });\n  };\n  var horizontal = function horizontal(container, selector, current, delta) {\n    return f(container, selector, current, delta, function (prevIndex, v, d, min, max, _oldCandidate, onNewIndex) {\n      var newIndex = cycleBy(v, d, min, max);\n      return newIndex === prevIndex ? Optional.none() : onNewIndex(newIndex);\n    });\n  };\n  var schema$t = [required$1('selector'), defaulted('getInitial', Optional.none), defaulted('execute', defaultExecute), onKeyboardHandler('onEscape'), defaulted('executeOnMove', false), defaulted('allowVertical', true), defaulted('allowHorizontal', true), defaulted('cycles', true)];\n  var findCurrent = function findCurrent(component, flowConfig) {\n    return flowConfig.focusManager.get(component).bind(function (elem) {\n      return closest$1(elem, flowConfig.selector);\n    });\n  };\n  var execute$2 = function execute$2(component, simulatedEvent, flowConfig) {\n    return findCurrent(component, flowConfig).bind(function (focused) {\n      return flowConfig.execute(component, simulatedEvent, focused);\n    });\n  };\n  var focusIn$2 = function focusIn$2(component, flowConfig, _state) {\n    flowConfig.getInitial(component).orThunk(function () {\n      return descendant(component.element, flowConfig.selector);\n    }).each(function (first) {\n      flowConfig.focusManager.set(component, first);\n    });\n  };\n  var moveLeft$2 = function moveLeft$2(element, focused, info) {\n    return (info.cycles ? horizontal : horizontalWithoutCycles)(element, info.selector, focused, -1);\n  };\n  var moveRight$2 = function moveRight$2(element, focused, info) {\n    return (info.cycles ? horizontal : horizontalWithoutCycles)(element, info.selector, focused, +1);\n  };\n  var doMove$1 = function doMove$1(movement) {\n    return function (component, simulatedEvent, flowConfig, flowState) {\n      return movement(component, simulatedEvent, flowConfig, flowState).bind(function () {\n        return flowConfig.executeOnMove ? execute$2(component, simulatedEvent, flowConfig) : Optional.some(true);\n      });\n    };\n  };\n  var doEscape = function doEscape(component, simulatedEvent, flowConfig) {\n    return flowConfig.onEscape(component, simulatedEvent);\n  };\n  var getKeydownRules$3 = function getKeydownRules$3(_component, _se, flowConfig, _flowState) {\n    var westMovers = _toConsumableArray(flowConfig.allowHorizontal ? LEFT : []).concat(flowConfig.allowVertical ? UP : []);\n    var eastMovers = _toConsumableArray(flowConfig.allowHorizontal ? RIGHT : []).concat(flowConfig.allowVertical ? DOWN : []);\n    return [rule(inSet(westMovers), doMove$1(west$1(moveLeft$2, moveRight$2))), rule(inSet(eastMovers), doMove$1(east$1(moveLeft$2, moveRight$2))), rule(inSet(ENTER), execute$2), rule(inSet(SPACE), execute$2)];\n  };\n  var getKeyupRules$3 = constant$1([rule(inSet(SPACE), stopEventForFirefox), rule(inSet(ESCAPE), doEscape)]);\n  var FlowType = typical(schema$t, NoState.init, getKeydownRules$3, getKeyupRules$3, function () {\n    return Optional.some(focusIn$2);\n  });\n  var toCell = function toCell(matrix, rowIndex, columnIndex) {\n    return Optional.from(matrix[rowIndex]).bind(function (row) {\n      return Optional.from(row[columnIndex]).map(function (cell) {\n        return {\n          rowIndex: rowIndex,\n          columnIndex: columnIndex,\n          cell: cell\n        };\n      });\n    });\n  };\n  var cycleHorizontal = function cycleHorizontal(matrix, rowIndex, startCol, deltaCol) {\n    var row = matrix[rowIndex];\n    var colsInRow = row.length;\n    var newColIndex = cycleBy(startCol, deltaCol, 0, colsInRow - 1);\n    return toCell(matrix, rowIndex, newColIndex);\n  };\n  var cycleVertical = function cycleVertical(matrix, colIndex, startRow, deltaRow) {\n    var nextRowIndex = cycleBy(startRow, deltaRow, 0, matrix.length - 1);\n    var colsInNextRow = matrix[nextRowIndex].length;\n    var nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);\n    return toCell(matrix, nextRowIndex, nextColIndex);\n  };\n  var moveHorizontal = function moveHorizontal(matrix, rowIndex, startCol, deltaCol) {\n    var row = matrix[rowIndex];\n    var colsInRow = row.length;\n    var newColIndex = clamp(startCol + deltaCol, 0, colsInRow - 1);\n    return toCell(matrix, rowIndex, newColIndex);\n  };\n  var moveVertical = function moveVertical(matrix, colIndex, startRow, deltaRow) {\n    var nextRowIndex = clamp(startRow + deltaRow, 0, matrix.length - 1);\n    var colsInNextRow = matrix[nextRowIndex].length;\n    var nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);\n    return toCell(matrix, nextRowIndex, nextColIndex);\n  };\n  var cycleRight = function cycleRight(matrix, startRow, startCol) {\n    return cycleHorizontal(matrix, startRow, startCol, +1);\n  };\n  var cycleLeft = function cycleLeft(matrix, startRow, startCol) {\n    return cycleHorizontal(matrix, startRow, startCol, -1);\n  };\n  var cycleUp = function cycleUp(matrix, startRow, startCol) {\n    return cycleVertical(matrix, startCol, startRow, -1);\n  };\n  var cycleDown = function cycleDown(matrix, startRow, startCol) {\n    return cycleVertical(matrix, startCol, startRow, +1);\n  };\n  var moveLeft$1 = function moveLeft$1(matrix, startRow, startCol) {\n    return moveHorizontal(matrix, startRow, startCol, -1);\n  };\n  var moveRight$1 = function moveRight$1(matrix, startRow, startCol) {\n    return moveHorizontal(matrix, startRow, startCol, +1);\n  };\n  var moveUp$1 = function moveUp$1(matrix, startRow, startCol) {\n    return moveVertical(matrix, startCol, startRow, -1);\n  };\n  var moveDown$1 = function moveDown$1(matrix, startRow, startCol) {\n    return moveVertical(matrix, startCol, startRow, +1);\n  };\n  var schema$s = [requiredObjOf('selectors', [required$1('row'), required$1('cell')]), defaulted('cycles', true), defaulted('previousSelector', Optional.none), defaulted('execute', defaultExecute)];\n  var focusIn$1 = function focusIn$1(component, matrixConfig, _state) {\n    var focused = matrixConfig.previousSelector(component).orThunk(function () {\n      var selectors = matrixConfig.selectors;\n      return descendant(component.element, selectors.cell);\n    });\n    focused.each(function (cell) {\n      matrixConfig.focusManager.set(component, cell);\n    });\n  };\n  var execute$1 = function execute$1(component, simulatedEvent, matrixConfig) {\n    return search(component.element).bind(function (focused) {\n      return matrixConfig.execute(component, simulatedEvent, focused);\n    });\n  };\n  var toMatrix = function toMatrix(rows, matrixConfig) {\n    return map$2(rows, function (row) {\n      return descendants(row, matrixConfig.selectors.cell);\n    });\n  };\n  var doMove = function doMove(ifCycle, ifMove) {\n    return function (element, focused, matrixConfig) {\n      var move = matrixConfig.cycles ? ifCycle : ifMove;\n      return closest$1(focused, matrixConfig.selectors.row).bind(function (inRow) {\n        var cellsInRow = descendants(inRow, matrixConfig.selectors.cell);\n        return findIndex(cellsInRow, focused).bind(function (colIndex) {\n          var allRows = descendants(element, matrixConfig.selectors.row);\n          return findIndex(allRows, inRow).bind(function (rowIndex) {\n            var matrix = toMatrix(allRows, matrixConfig);\n            return move(matrix, rowIndex, colIndex).map(function (next) {\n              return next.cell;\n            });\n          });\n        });\n      });\n    };\n  };\n  var moveLeft = doMove(cycleLeft, moveLeft$1);\n  var moveRight = doMove(cycleRight, moveRight$1);\n  var moveNorth = doMove(cycleUp, moveUp$1);\n  var moveSouth = doMove(cycleDown, moveDown$1);\n  var getKeydownRules$2 = constant$1([rule(inSet(LEFT), west$1(moveLeft, moveRight)), rule(inSet(RIGHT), east$1(moveLeft, moveRight)), rule(inSet(UP), north$1(moveNorth)), rule(inSet(DOWN), south$1(moveSouth)), rule(inSet(SPACE.concat(ENTER)), execute$1)]);\n  var getKeyupRules$2 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);\n  var MatrixType = typical(schema$s, NoState.init, getKeydownRules$2, getKeyupRules$2, function () {\n    return Optional.some(focusIn$1);\n  });\n  var schema$r = [required$1('selector'), defaulted('execute', defaultExecute), defaulted('moveOnTab', false)];\n  var execute = function execute(component, simulatedEvent, menuConfig) {\n    return menuConfig.focusManager.get(component).bind(function (focused) {\n      return menuConfig.execute(component, simulatedEvent, focused);\n    });\n  };\n  var focusIn = function focusIn(component, menuConfig, _state) {\n    descendant(component.element, menuConfig.selector).each(function (first) {\n      menuConfig.focusManager.set(component, first);\n    });\n  };\n  var moveUp = function moveUp(element, focused, info) {\n    return horizontal(element, info.selector, focused, -1);\n  };\n  var moveDown = function moveDown(element, focused, info) {\n    return horizontal(element, info.selector, focused, +1);\n  };\n  var fireShiftTab = function fireShiftTab(component, simulatedEvent, menuConfig, menuState) {\n    return menuConfig.moveOnTab ? move$1(moveUp)(component, simulatedEvent, menuConfig, menuState) : Optional.none();\n  };\n  var fireTab = function fireTab(component, simulatedEvent, menuConfig, menuState) {\n    return menuConfig.moveOnTab ? move$1(moveDown)(component, simulatedEvent, menuConfig, menuState) : Optional.none();\n  };\n  var getKeydownRules$1 = constant$1([rule(inSet(UP), move$1(moveUp)), rule(inSet(DOWN), move$1(moveDown)), rule(and([isShift, inSet(TAB)]), fireShiftTab), rule(and([isNotShift, inSet(TAB)]), fireTab), rule(inSet(ENTER), execute), rule(inSet(SPACE), execute)]);\n  var getKeyupRules$1 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);\n  var MenuType = typical(schema$r, NoState.init, getKeydownRules$1, getKeyupRules$1, function () {\n    return Optional.some(focusIn);\n  });\n  var schema$q = [onKeyboardHandler('onSpace'), onKeyboardHandler('onEnter'), onKeyboardHandler('onShiftEnter'), onKeyboardHandler('onLeft'), onKeyboardHandler('onRight'), onKeyboardHandler('onTab'), onKeyboardHandler('onShiftTab'), onKeyboardHandler('onUp'), onKeyboardHandler('onDown'), onKeyboardHandler('onEscape'), defaulted('stopSpaceKeyup', false), option$3('focusIn')];\n  var getKeydownRules = function getKeydownRules(component, simulatedEvent, specialInfo) {\n    return [rule(inSet(SPACE), specialInfo.onSpace), rule(and([isNotShift, inSet(ENTER)]), specialInfo.onEnter), rule(and([isShift, inSet(ENTER)]), specialInfo.onShiftEnter), rule(and([isShift, inSet(TAB)]), specialInfo.onShiftTab), rule(and([isNotShift, inSet(TAB)]), specialInfo.onTab), rule(inSet(UP), specialInfo.onUp), rule(inSet(DOWN), specialInfo.onDown), rule(inSet(LEFT), specialInfo.onLeft), rule(inSet(RIGHT), specialInfo.onRight), rule(inSet(SPACE), specialInfo.onSpace)];\n  };\n  var getKeyupRules = function getKeyupRules(component, simulatedEvent, specialInfo) {\n    return [].concat(_toConsumableArray(specialInfo.stopSpaceKeyup ? [rule(inSet(SPACE), stopEventForFirefox)] : []), [rule(inSet(ESCAPE), specialInfo.onEscape)]);\n  };\n  var SpecialType = typical(schema$q, NoState.init, getKeydownRules, getKeyupRules, function (specialInfo) {\n    return specialInfo.focusIn;\n  });\n  var acyclic = AcyclicType.schema();\n  var cyclic = CyclicType.schema();\n  var flow = FlowType.schema();\n  var flatgrid = FlatgridType.schema();\n  var matrix = MatrixType.schema();\n  var execution = ExecutionType.schema();\n  var menu = MenuType.schema();\n  var special = SpecialType.schema();\n  var KeyboardBranches = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    acyclic: acyclic,\n    cyclic: cyclic,\n    flow: flow,\n    flatgrid: flatgrid,\n    matrix: matrix,\n    execution: execution,\n    menu: menu,\n    special: special\n  });\n  var isFlatgridState = function isFlatgridState(keyState) {\n    return hasNonNullableKey(keyState, 'setGridSize');\n  };\n  var Keying = createModes({\n    branchKey: 'mode',\n    branches: KeyboardBranches,\n    name: 'keying',\n    active: {\n      events: function events(keyingConfig, keyingState) {\n        var handler = keyingConfig.handler;\n        return handler.toEvents(keyingConfig, keyingState);\n      }\n    },\n    apis: {\n      focusIn: function focusIn(component, keyConfig, keyState) {\n        keyConfig.sendFocusIn(keyConfig).fold(function () {\n          component.getSystem().triggerFocus(component.element, component.element);\n        }, function (sendFocusIn) {\n          sendFocusIn(component, keyConfig, keyState);\n        });\n      },\n      setGridSize: function setGridSize(component, keyConfig, keyState, numRows, numColumns) {\n        if (!isFlatgridState(keyState)) {\n          console.error('Layout does not support setGridSize');\n        } else {\n          keyState.setGridSize(numRows, numColumns);\n        }\n      }\n    },\n    state: KeyingState\n  });\n  var withoutReuse = function withoutReuse(parent, data) {\n    preserve$1(function () {\n      replaceChildren(parent, data, function () {\n        return map$2(data, parent.getSystem().build);\n      });\n    }, parent.element);\n  };\n  var withReuse = function withReuse(parent, data) {\n    preserve$1(function () {\n      virtualReplaceChildren(parent, data, function () {\n        return patchSpecChildren(parent.element, data, parent.getSystem().buildOrPatch);\n      });\n    }, parent.element);\n  };\n  var virtualReplace = function virtualReplace(component, replacee, replaceeIndex, childSpec) {\n    virtualDetach(replacee);\n    var child = patchSpecChild(component.element, replaceeIndex, childSpec, component.getSystem().buildOrPatch);\n    virtualAttach(component, child);\n    component.syncComponents();\n  };\n  var insert = function insert(component, insertion, childSpec) {\n    var child = component.getSystem().build(childSpec);\n    attachWith(component, child, insertion);\n  };\n  var replace = function replace(component, replacee, replaceeIndex, childSpec) {\n    detach(replacee);\n    insert(component, function (p, c) {\n      return appendAt(p, c, replaceeIndex);\n    }, childSpec);\n  };\n  var set$3 = function set$3(component, replaceConfig, replaceState, data) {\n    var replacer = replaceConfig.reuseDom ? withReuse : withoutReuse;\n    return replacer(component, data);\n  };\n  var append = function append(component, replaceConfig, replaceState, appendee) {\n    insert(component, append$2, appendee);\n  };\n  var prepend = function prepend(component, replaceConfig, replaceState, prependee) {\n    insert(component, prepend$1, prependee);\n  };\n  var remove = function remove(component, replaceConfig, replaceState, removee) {\n    var children = contents(component);\n    var foundChild = find$5(children, function (child) {\n      return eq(removee.element, child.element);\n    });\n    foundChild.each(detach);\n  };\n  var contents = function contents(component, _replaceConfig) {\n    return component.components();\n  };\n  var replaceAt = function replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer) {\n    var children = contents(component);\n    return Optional.from(children[replaceeIndex]).map(function (replacee) {\n      replacer.fold(function () {\n        return detach(replacee);\n      }, function (r) {\n        var replacer = replaceConfig.reuseDom ? virtualReplace : replace;\n        replacer(component, replacee, replaceeIndex, r);\n      });\n      return replacee;\n    });\n  };\n  var replaceBy = function replaceBy(component, replaceConfig, replaceState, replaceePred, replacer) {\n    var children = contents(component);\n    return findIndex$1(children, replaceePred).bind(function (replaceeIndex) {\n      return replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer);\n    });\n  };\n  var ReplaceApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    append: append,\n    prepend: prepend,\n    remove: remove,\n    replaceAt: replaceAt,\n    replaceBy: replaceBy,\n    set: set$3,\n    contents: contents\n  });\n  var Replacing = create$4({\n    fields: [defaultedBoolean('reuseDom', true)],\n    name: 'replacing',\n    apis: ReplaceApis\n  });\n  var events$d = function events$d(name, eventHandlers) {\n    var events = derive$2(eventHandlers);\n    return create$4({\n      fields: [required$1('enabled')],\n      name: name,\n      active: {\n        events: constant$1(events)\n      }\n    });\n  };\n  var config = function config(name, eventHandlers) {\n    var me = events$d(name, eventHandlers);\n    return {\n      key: name,\n      value: {\n        config: {},\n        me: me,\n        configAsRaw: constant$1({}),\n        initialConfig: {},\n        state: NoState\n      }\n    };\n  };\n  var focus$2 = function focus$2(component, focusConfig) {\n    if (!focusConfig.ignore) {\n      focus$3(component.element);\n      focusConfig.onFocus(component);\n    }\n  };\n  var blur = function blur(component, focusConfig) {\n    if (!focusConfig.ignore) {\n      blur$1(component.element);\n    }\n  };\n  var isFocused = function isFocused(component) {\n    return hasFocus(component.element);\n  };\n  var FocusApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    focus: focus$2,\n    blur: blur,\n    isFocused: isFocused\n  });\n  var exhibit$4 = function exhibit$4(base, focusConfig) {\n    var mod = focusConfig.ignore ? {} : {\n      attributes: {\n        tabindex: '-1'\n      }\n    };\n    return nu$7(mod);\n  };\n  var events$c = function events$c(focusConfig) {\n    return derive$2([run$1(focus$4(), function (component, simulatedEvent) {\n      focus$2(component, focusConfig);\n      simulatedEvent.stop();\n    })].concat(focusConfig.stopMousedown ? [run$1(mousedown(), function (_, simulatedEvent) {\n      simulatedEvent.event.prevent();\n    })] : []));\n  };\n  var ActiveFocus = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    exhibit: exhibit$4,\n    events: events$c\n  });\n  var FocusSchema = [onHandler('onFocus'), defaulted('stopMousedown', false), defaulted('ignore', false)];\n  var Focusing = create$4({\n    fields: FocusSchema,\n    name: 'focusing',\n    active: ActiveFocus,\n    apis: FocusApis\n  });\n  var SetupBehaviourCellState = function SetupBehaviourCellState(initialState) {\n    var init = function init() {\n      var cell = Cell(initialState);\n      var get = function get() {\n        return cell.get();\n      };\n      var set = function set(newState) {\n        return cell.set(newState);\n      };\n      var clear = function clear() {\n        return cell.set(initialState);\n      };\n      var readState = function readState() {\n        return cell.get();\n      };\n      return {\n        get: get,\n        set: set,\n        clear: clear,\n        readState: readState\n      };\n    };\n    return {\n      init: init\n    };\n  };\n  var updateAriaState = function updateAriaState(component, toggleConfig, toggleState) {\n    var ariaInfo = toggleConfig.aria;\n    ariaInfo.update(component, ariaInfo, toggleState.get());\n  };\n  var updateClass = function updateClass(component, toggleConfig, toggleState) {\n    toggleConfig.toggleClass.each(function (toggleClass) {\n      if (toggleState.get()) {\n        add$2(component.element, toggleClass);\n      } else {\n        remove$2(component.element, toggleClass);\n      }\n    });\n  };\n  var set$2 = function set$2(component, toggleConfig, toggleState, state) {\n    var initialState = toggleState.get();\n    toggleState.set(state);\n    updateClass(component, toggleConfig, toggleState);\n    updateAriaState(component, toggleConfig, toggleState);\n    if (initialState !== state) {\n      toggleConfig.onToggled(component, state);\n    }\n  };\n  var toggle$2 = function toggle$2(component, toggleConfig, toggleState) {\n    set$2(component, toggleConfig, toggleState, !toggleState.get());\n  };\n  var on = function on(component, toggleConfig, toggleState) {\n    set$2(component, toggleConfig, toggleState, true);\n  };\n  var off = function off(component, toggleConfig, toggleState) {\n    set$2(component, toggleConfig, toggleState, false);\n  };\n  var isOn = function isOn(component, toggleConfig, toggleState) {\n    return toggleState.get();\n  };\n  var onLoad = function onLoad(component, toggleConfig, toggleState) {\n    set$2(component, toggleConfig, toggleState, toggleConfig.selected);\n  };\n  var ToggleApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    onLoad: onLoad,\n    toggle: toggle$2,\n    isOn: isOn,\n    on: on,\n    off: off,\n    set: set$2\n  });\n  var exhibit$3 = function exhibit$3() {\n    return nu$7({});\n  };\n  var events$b = function events$b(toggleConfig, toggleState) {\n    var execute = executeEvent(toggleConfig, toggleState, toggle$2);\n    var load = loadEvent(toggleConfig, toggleState, onLoad);\n    return derive$2(flatten([toggleConfig.toggleOnExecute ? [execute] : [], [load]]));\n  };\n  var ActiveToggle = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    exhibit: exhibit$3,\n    events: events$b\n  });\n  var updatePressed = function updatePressed(component, ariaInfo, status) {\n    set$9(component.element, 'aria-pressed', status);\n    if (ariaInfo.syncWithExpanded) {\n      updateExpanded(component, ariaInfo, status);\n    }\n  };\n  var updateSelected = function updateSelected(component, ariaInfo, status) {\n    set$9(component.element, 'aria-selected', status);\n  };\n  var updateChecked = function updateChecked(component, ariaInfo, status) {\n    set$9(component.element, 'aria-checked', status);\n  };\n  var updateExpanded = function updateExpanded(component, ariaInfo, status) {\n    set$9(component.element, 'aria-expanded', status);\n  };\n  var ToggleSchema = [defaulted('selected', false), option$3('toggleClass'), defaulted('toggleOnExecute', true), onHandler('onToggled'), defaultedOf('aria', {\n    mode: 'none'\n  }, choose$1('mode', {\n    pressed: [defaulted('syncWithExpanded', false), output$1('update', updatePressed)],\n    checked: [output$1('update', updateChecked)],\n    expanded: [output$1('update', updateExpanded)],\n    selected: [output$1('update', updateSelected)],\n    none: [output$1('update', noop)]\n  }))];\n  var Toggling = create$4({\n    fields: ToggleSchema,\n    name: 'toggling',\n    active: ActiveToggle,\n    apis: ToggleApis,\n    state: SetupBehaviourCellState(false)\n  });\n  var pointerEvents = function pointerEvents() {\n    var onClick = function onClick(component, simulatedEvent) {\n      simulatedEvent.stop();\n      emitExecute(component);\n    };\n    return [run$1(click(), onClick), run$1(tap(), onClick), cutter(touchstart()), cutter(mousedown())];\n  };\n  var events$a = function events$a(optAction) {\n    var executeHandler = function executeHandler(action) {\n      return runOnExecute$1(function (component, simulatedEvent) {\n        action(component);\n        simulatedEvent.stop();\n      });\n    };\n    return derive$2(flatten([optAction.map(executeHandler).toArray(), pointerEvents()]));\n  };\n  var hoverEvent = 'alloy.item-hover';\n  var focusEvent = 'alloy.item-focus';\n  var toggledEvent = 'alloy.item-toggled';\n  var onHover = function onHover(item) {\n    if (search(item.element).isNone() || Focusing.isFocused(item)) {\n      if (!Focusing.isFocused(item)) {\n        Focusing.focus(item);\n      }\n      emitWith(item, hoverEvent, {\n        item: item\n      });\n    }\n  };\n  var onFocus$1 = function onFocus$1(item) {\n    emitWith(item, focusEvent, {\n      item: item\n    });\n  };\n  var _onToggled = function onToggled(item, state) {\n    emitWith(item, toggledEvent, {\n      item: item,\n      state: state\n    });\n  };\n  var hover = constant$1(hoverEvent);\n  var focus$1 = constant$1(focusEvent);\n  var toggled = constant$1(toggledEvent);\n  var getItemRole = function getItemRole(detail) {\n    return detail.toggling.map(function (toggling) {\n      return toggling.exclusive ? 'menuitemradio' : 'menuitemcheckbox';\n    }).getOr('menuitem');\n  };\n  var getTogglingSpec = function getTogglingSpec(tConfig) {\n    return _objectSpread({\n      aria: {\n        mode: 'checked'\n      }\n    }, filter$1(tConfig, function (_value, name) {\n      return name !== 'exclusive';\n    }), {\n      onToggled: function onToggled(component, state) {\n        if (isFunction(tConfig.onToggled)) {\n          tConfig.onToggled(component, state);\n        }\n        _onToggled(component, state);\n      }\n    });\n  };\n  var builder$2 = function builder$2(detail) {\n    return {\n      dom: detail.dom,\n      domModification: _objectSpread({}, detail.domModification, {\n        attributes: _objectSpread({\n          'role': getItemRole(detail)\n        }, detail.domModification.attributes, {\n          'aria-haspopup': detail.hasSubmenu\n        }, detail.hasSubmenu ? {\n          'aria-expanded': false\n        } : {})\n      }),\n      behaviours: SketchBehaviours.augment(detail.itemBehaviours, [detail.toggling.fold(Toggling.revoke, function (tConfig) {\n        return Toggling.config(getTogglingSpec(tConfig));\n      }), Focusing.config({\n        ignore: detail.ignoreFocus,\n        stopMousedown: detail.ignoreFocus,\n        onFocus: function onFocus(component) {\n          onFocus$1(component);\n        }\n      }), Keying.config({\n        mode: 'execution'\n      }), Representing.config({\n        store: {\n          mode: 'memory',\n          initialValue: detail.data\n        }\n      }), config('item-type-events', [].concat(_toConsumableArray(pointerEvents()), [run$1(mouseover(), onHover), run$1(focusItem(), Focusing.focus)]))]),\n      components: detail.components,\n      eventOrder: detail.eventOrder\n    };\n  };\n  var schema$p = [required$1('data'), required$1('components'), required$1('dom'), defaulted('hasSubmenu', false), option$3('toggling'), SketchBehaviours.field('itemBehaviours', [Toggling, Focusing, Keying, Representing]), defaulted('ignoreFocus', false), defaulted('domModification', {}), output$1('builder', builder$2), defaulted('eventOrder', {})];\n  var builder$1 = function builder$1(detail) {\n    return {\n      dom: detail.dom,\n      components: detail.components,\n      events: derive$2([stopper(focusItem())])\n    };\n  };\n  var schema$o = [required$1('dom'), required$1('components'), output$1('builder', builder$1)];\n  var owner$2 = constant$1('item-widget');\n  var parts$h = constant$1([required({\n    name: 'widget',\n    overrides: function overrides(detail) {\n      return {\n        behaviours: derive$1([Representing.config({\n          store: {\n            mode: 'manual',\n            getValue: function getValue(_component) {\n              return detail.data;\n            },\n            setValue: noop\n          }\n        })])\n      };\n    }\n  })]);\n  var builder = function builder(detail) {\n    var subs = substitutes(owner$2(), detail, parts$h());\n    var components = components$1(owner$2(), detail, subs.internals());\n    var focusWidget = function focusWidget(component) {\n      return getPart(component, detail, 'widget').map(function (widget) {\n        Keying.focusIn(widget);\n        return widget;\n      });\n    };\n    var onHorizontalArrow = function onHorizontalArrow(component, simulatedEvent) {\n      return inside(simulatedEvent.event.target) ? Optional.none() : function () {\n        if (detail.autofocus) {\n          simulatedEvent.setSource(component.element);\n          return Optional.none();\n        } else {\n          return Optional.none();\n        }\n      }();\n    };\n    return {\n      dom: detail.dom,\n      components: components,\n      domModification: detail.domModification,\n      events: derive$2([runOnExecute$1(function (component, simulatedEvent) {\n        focusWidget(component).each(function (_widget) {\n          simulatedEvent.stop();\n        });\n      }), run$1(mouseover(), onHover), run$1(focusItem(), function (component, _simulatedEvent) {\n        if (detail.autofocus) {\n          focusWidget(component);\n        } else {\n          Focusing.focus(component);\n        }\n      })]),\n      behaviours: SketchBehaviours.augment(detail.widgetBehaviours, [Representing.config({\n        store: {\n          mode: 'memory',\n          initialValue: detail.data\n        }\n      }), Focusing.config({\n        ignore: detail.ignoreFocus,\n        onFocus: function onFocus(component) {\n          onFocus$1(component);\n        }\n      }), Keying.config({\n        mode: 'special',\n        focusIn: detail.autofocus ? function (component) {\n          focusWidget(component);\n        } : revoke(),\n        onLeft: onHorizontalArrow,\n        onRight: onHorizontalArrow,\n        onEscape: function onEscape(component, simulatedEvent) {\n          if (!Focusing.isFocused(component) && !detail.autofocus) {\n            Focusing.focus(component);\n            return Optional.some(true);\n          } else if (detail.autofocus) {\n            simulatedEvent.setSource(component.element);\n            return Optional.none();\n          } else {\n            return Optional.none();\n          }\n        }\n      })])\n    };\n  };\n  var schema$n = [required$1('uid'), required$1('data'), required$1('components'), required$1('dom'), defaulted('autofocus', false), defaulted('ignoreFocus', false), SketchBehaviours.field('widgetBehaviours', [Representing, Focusing, Keying]), defaulted('domModification', {}), defaultUidsSchema(parts$h()), output$1('builder', builder)];\n  var itemSchema$2 = choose$1('type', {\n    widget: schema$n,\n    item: schema$p,\n    separator: schema$o\n  });\n  var configureGrid = function configureGrid(detail, movementInfo) {\n    return {\n      mode: 'flatgrid',\n      selector: '.' + detail.markers.item,\n      initSize: {\n        numColumns: movementInfo.initSize.numColumns,\n        numRows: movementInfo.initSize.numRows\n      },\n      focusManager: detail.focusManager\n    };\n  };\n  var configureMatrix = function configureMatrix(detail, movementInfo) {\n    return {\n      mode: 'matrix',\n      selectors: {\n        row: movementInfo.rowSelector,\n        cell: '.' + detail.markers.item\n      },\n      previousSelector: movementInfo.previousSelector,\n      focusManager: detail.focusManager\n    };\n  };\n  var configureMenu = function configureMenu(detail, movementInfo) {\n    return {\n      mode: 'menu',\n      selector: '.' + detail.markers.item,\n      moveOnTab: movementInfo.moveOnTab,\n      focusManager: detail.focusManager\n    };\n  };\n  var parts$g = constant$1([group({\n    factory: {\n      sketch: function sketch(spec) {\n        var itemInfo = asRawOrDie$1('menu.spec item', itemSchema$2, spec);\n        return itemInfo.builder(itemInfo);\n      }\n    },\n    name: 'items',\n    unit: 'item',\n    defaults: function defaults(detail, u) {\n      return has$2(u, 'uid') ? u : _objectSpread({}, u, {\n        uid: generate$5('item')\n      });\n    },\n    overrides: function overrides(detail, u) {\n      return {\n        type: u.type,\n        ignoreFocus: detail.fakeFocus,\n        domModification: {\n          classes: [detail.markers.item]\n        }\n      };\n    }\n  })]);\n  var schema$m = constant$1([required$1('value'), required$1('items'), required$1('dom'), required$1('components'), defaulted('eventOrder', {}), field('menuBehaviours', [Highlighting, Representing, Composing, Keying]), defaultedOf('movement', {\n    mode: 'menu',\n    moveOnTab: true\n  }, choose$1('mode', {\n    grid: [initSize(), output$1('config', configureGrid)],\n    matrix: [output$1('config', configureMatrix), required$1('rowSelector'), defaulted('previousSelector', Optional.none)],\n    menu: [defaulted('moveOnTab', true), output$1('config', configureMenu)]\n  })), itemMarkers(), defaulted('fakeFocus', false), defaulted('focusManager', dom$2()), onHandler('onHighlight'), onHandler('onDehighlight')]);\n  var focus = constant$1('alloy.menu-focus');\n  var deselectOtherRadioItems = function deselectOtherRadioItems(menu, item) {\n    var checkedRadioItems = descendants(menu.element, '[role=\"menuitemradio\"][aria-checked=\"true\"]');\n    each$1(checkedRadioItems, function (ele) {\n      if (!eq(ele, item.element)) {\n        menu.getSystem().getByDom(ele).each(function (c) {\n          Toggling.off(c);\n        });\n      }\n    });\n  };\n  var make$7 = function make$7(detail, components, _spec, _externals) {\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      markers: detail.markers,\n      behaviours: augment(detail.menuBehaviours, [Highlighting.config({\n        highlightClass: detail.markers.selectedItem,\n        itemClass: detail.markers.item,\n        onHighlight: detail.onHighlight,\n        onDehighlight: detail.onDehighlight\n      }), Representing.config({\n        store: {\n          mode: 'memory',\n          initialValue: detail.value\n        }\n      }), Composing.config({\n        find: Optional.some\n      }), Keying.config(detail.movement.config(detail, detail.movement))]),\n      events: derive$2([run$1(focus$1(), function (menu, simulatedEvent) {\n        var event = simulatedEvent.event;\n        menu.getSystem().getByDom(event.target).each(function (item) {\n          Highlighting.highlight(menu, item);\n          simulatedEvent.stop();\n          emitWith(menu, focus(), {\n            menu: menu,\n            item: item\n          });\n        });\n      }), run$1(hover(), function (menu, simulatedEvent) {\n        var item = simulatedEvent.event.item;\n        Highlighting.highlight(menu, item);\n      }), run$1(toggled(), function (menu, simulatedEvent) {\n        var _simulatedEvent$event = simulatedEvent.event,\n          item = _simulatedEvent$event.item,\n          state = _simulatedEvent$event.state;\n        if (state && get$f(item.element, 'role') === 'menuitemradio') {\n          deselectOtherRadioItems(menu, item);\n        }\n      })]),\n      components: components,\n      eventOrder: detail.eventOrder,\n      domModification: {\n        attributes: {\n          role: 'menu'\n        }\n      }\n    };\n  };\n  var Menu = composite({\n    name: 'Menu',\n    configFields: schema$m(),\n    partFields: parts$g(),\n    factory: make$7\n  });\n  var transpose$1 = function transpose$1(obj) {\n    return tupleMap(obj, function (v, k) {\n      return {\n        k: v,\n        v: k\n      };\n    });\n  };\n  var trace = function trace(items, byItem, byMenu, finish) {\n    return get$g(byMenu, finish).bind(function (triggerItem) {\n      return get$g(items, triggerItem).bind(function (triggerMenu) {\n        var rest = trace(items, byItem, byMenu, triggerMenu);\n        return Optional.some([triggerMenu].concat(rest));\n      });\n    }).getOr([]);\n  };\n  var generate$2 = function generate$2(menus, expansions) {\n    var items = {};\n    each(menus, function (menuItems, menu) {\n      each$1(menuItems, function (item) {\n        items[item] = menu;\n      });\n    });\n    var byItem = expansions;\n    var byMenu = transpose$1(expansions);\n    var menuPaths = map$1(byMenu, function (_triggerItem, submenu) {\n      return [submenu].concat(trace(items, byItem, byMenu, submenu));\n    });\n    return map$1(items, function (menu) {\n      return get$g(menuPaths, menu).getOr([menu]);\n    });\n  };\n  var init$c = function init$c() {\n    var expansions = Cell({});\n    var menus = Cell({});\n    var paths = Cell({});\n    var primary = value$2();\n    var directory = Cell({});\n    var clear = function clear() {\n      expansions.set({});\n      menus.set({});\n      paths.set({});\n      primary.clear();\n    };\n    var isClear = function isClear() {\n      return primary.get().isNone();\n    };\n    var setMenuBuilt = function setMenuBuilt(menuName, built) {\n      menus.set(_objectSpread({}, menus.get(), _defineProperty({}, menuName, {\n        type: 'prepared',\n        menu: built\n      })));\n    };\n    var setContents = function setContents(sPrimary, sMenus, sExpansions, dir) {\n      primary.set(sPrimary);\n      expansions.set(sExpansions);\n      menus.set(sMenus);\n      directory.set(dir);\n      var sPaths = generate$2(dir, sExpansions);\n      paths.set(sPaths);\n    };\n    var getTriggeringItem = function getTriggeringItem(menuValue) {\n      return find$4(expansions.get(), function (v, _k) {\n        return v === menuValue;\n      });\n    };\n    var getTriggerData = function getTriggerData(menuValue, getItemByValue, path) {\n      return getPreparedMenu(menuValue).bind(function (menu) {\n        return getTriggeringItem(menuValue).bind(function (triggeringItemValue) {\n          return getItemByValue(triggeringItemValue).map(function (triggeredItem) {\n            return {\n              triggeredMenu: menu,\n              triggeringItem: triggeredItem,\n              triggeringPath: path\n            };\n          });\n        });\n      });\n    };\n    var getTriggeringPath = function getTriggeringPath(itemValue, getItemByValue) {\n      var extraPath = filter$2(lookupItem(itemValue).toArray(), function (menuValue) {\n        return getPreparedMenu(menuValue).isSome();\n      });\n      return get$g(paths.get(), itemValue).bind(function (path) {\n        var revPath = reverse(extraPath.concat(path));\n        var triggers = bind$3(revPath, function (menuValue, menuIndex) {\n          return getTriggerData(menuValue, getItemByValue, revPath.slice(0, menuIndex + 1)).fold(function () {\n            return is$1(primary.get(), menuValue) ? [] : [Optional.none()];\n          }, function (data) {\n            return [Optional.some(data)];\n          });\n        });\n        return sequence(triggers);\n      });\n    };\n    var expand = function expand(itemValue) {\n      return get$g(expansions.get(), itemValue).map(function (menu) {\n        var current = get$g(paths.get(), itemValue).getOr([]);\n        return [menu].concat(current);\n      });\n    };\n    var collapse = function collapse(itemValue) {\n      return get$g(paths.get(), itemValue).bind(function (path) {\n        return path.length > 1 ? Optional.some(path.slice(1)) : Optional.none();\n      });\n    };\n    var refresh = function refresh(itemValue) {\n      return get$g(paths.get(), itemValue);\n    };\n    var getPreparedMenu = function getPreparedMenu(menuValue) {\n      return lookupMenu(menuValue).bind(extractPreparedMenu);\n    };\n    var lookupMenu = function lookupMenu(menuValue) {\n      return get$g(menus.get(), menuValue);\n    };\n    var lookupItem = function lookupItem(itemValue) {\n      return get$g(expansions.get(), itemValue);\n    };\n    var otherMenus = function otherMenus(path) {\n      var menuValues = directory.get();\n      return difference(keys(menuValues), path);\n    };\n    var getPrimary = function getPrimary() {\n      return primary.get().bind(getPreparedMenu);\n    };\n    var getMenus = function getMenus() {\n      return menus.get();\n    };\n    return {\n      setMenuBuilt: setMenuBuilt,\n      setContents: setContents,\n      expand: expand,\n      refresh: refresh,\n      collapse: collapse,\n      lookupMenu: lookupMenu,\n      lookupItem: lookupItem,\n      otherMenus: otherMenus,\n      getPrimary: getPrimary,\n      getMenus: getMenus,\n      clear: clear,\n      isClear: isClear,\n      getTriggeringPath: getTriggeringPath\n    };\n  };\n  var extractPreparedMenu = function extractPreparedMenu(prep) {\n    return prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none();\n  };\n  var LayeredState = {\n    init: init$c,\n    extractPreparedMenu: extractPreparedMenu\n  };\n  var onMenuItemHighlightedEvent = generate$6('tiered-menu-item-highlight');\n  var onMenuItemDehighlightedEvent = generate$6('tiered-menu-item-dehighlight');\n  var HighlightOnOpen;\n  (function (HighlightOnOpen) {\n    HighlightOnOpen[HighlightOnOpen['HighlightMenuAndItem'] = 0] = 'HighlightMenuAndItem';\n    HighlightOnOpen[HighlightOnOpen['HighlightJustMenu'] = 1] = 'HighlightJustMenu';\n    HighlightOnOpen[HighlightOnOpen['HighlightNone'] = 2] = 'HighlightNone';\n  })(HighlightOnOpen || (HighlightOnOpen = {}));\n  var make$6 = function make$6(detail, _rawUiSpec) {\n    var submenuParentItems = value$2();\n    var buildMenus = function buildMenus(container, primaryName, menus) {\n      return map$1(menus, function (spec, name) {\n        var makeSketch = function makeSketch() {\n          return Menu.sketch(_objectSpread({}, spec, {\n            value: name,\n            markers: detail.markers,\n            fakeFocus: detail.fakeFocus,\n            onHighlight: function onHighlight(menuComp, itemComp) {\n              var highlightData = {\n                menuComp: menuComp,\n                itemComp: itemComp\n              };\n              emitWith(menuComp, onMenuItemHighlightedEvent, highlightData);\n            },\n            onDehighlight: function onDehighlight(menuComp, itemComp) {\n              var dehighlightData = {\n                menuComp: menuComp,\n                itemComp: itemComp\n              };\n              emitWith(menuComp, onMenuItemDehighlightedEvent, dehighlightData);\n            },\n            focusManager: detail.fakeFocus ? highlights() : dom$2()\n          }));\n        };\n        return name === primaryName ? {\n          type: 'prepared',\n          menu: container.getSystem().build(makeSketch())\n        } : {\n          type: 'notbuilt',\n          nbMenu: makeSketch\n        };\n      });\n    };\n    var layeredState = LayeredState.init();\n    var setup = function setup(container) {\n      var componentMap = buildMenus(container, detail.data.primary, detail.data.menus);\n      var directory = toDirectory();\n      layeredState.setContents(detail.data.primary, componentMap, detail.data.expansions, directory);\n      return layeredState.getPrimary();\n    };\n    var getItemValue = function getItemValue(item) {\n      return Representing.getValue(item).value;\n    };\n    var getItemByValue = function getItemByValue(_container, menus, itemValue) {\n      return findMap(menus, function (menu) {\n        if (!menu.getSystem().isConnected()) {\n          return Optional.none();\n        }\n        var candidates = Highlighting.getCandidates(menu);\n        return find$5(candidates, function (c) {\n          return getItemValue(c) === itemValue;\n        });\n      });\n    };\n    var toDirectory = function toDirectory(_container) {\n      return map$1(detail.data.menus, function (data, _menuName) {\n        return bind$3(data.items, function (item) {\n          return item.type === 'separator' ? [] : [item.data.value];\n        });\n      });\n    };\n    var setActiveMenu = Highlighting.highlight;\n    var setActiveMenuAndItem = function setActiveMenuAndItem(container, menu) {\n      setActiveMenu(container, menu);\n      Highlighting.getHighlighted(menu).orThunk(function () {\n        return Highlighting.getFirst(menu);\n      }).each(function (item) {\n        if (detail.fakeFocus) {\n          Highlighting.highlight(menu, item);\n        } else {\n          dispatch(container, item.element, focusItem());\n        }\n      });\n    };\n    var getMenus = function getMenus(state, menuValues) {\n      return cat(map$2(menuValues, function (mv) {\n        return state.lookupMenu(mv).bind(function (prep) {\n          return prep.type === 'prepared' ? Optional.some(prep.menu) : Optional.none();\n        });\n      }));\n    };\n    var closeOthers = function closeOthers(container, state, path) {\n      var others = getMenus(state, state.otherMenus(path));\n      each$1(others, function (o) {\n        remove$1(o.element, [detail.markers.backgroundMenu]);\n        if (!detail.stayInDom) {\n          Replacing.remove(container, o);\n        }\n      });\n    };\n    var getSubmenuParents = function getSubmenuParents(container) {\n      return submenuParentItems.get().getOrThunk(function () {\n        var r = {};\n        var items = descendants(container.element, \".\".concat(detail.markers.item));\n        var parentItems = filter$2(items, function (i) {\n          return get$f(i, 'aria-haspopup') === 'true';\n        });\n        each$1(parentItems, function (i) {\n          container.getSystem().getByDom(i).each(function (itemComp) {\n            var key = getItemValue(itemComp);\n            r[key] = itemComp;\n          });\n        });\n        submenuParentItems.set(r);\n        return r;\n      });\n    };\n    var updateAriaExpansions = function updateAriaExpansions(container, path) {\n      var parentItems = getSubmenuParents(container);\n      each(parentItems, function (v, k) {\n        var expanded = contains$2(path, k);\n        set$9(v.element, 'aria-expanded', expanded);\n      });\n    };\n    var updateMenuPath = function updateMenuPath(container, state, path) {\n      return Optional.from(path[0]).bind(function (latestMenuName) {\n        return state.lookupMenu(latestMenuName).bind(function (menuPrep) {\n          if (menuPrep.type === 'notbuilt') {\n            return Optional.none();\n          } else {\n            var activeMenu = menuPrep.menu;\n            var rest = getMenus(state, path.slice(1));\n            each$1(rest, function (r) {\n              add$2(r.element, detail.markers.backgroundMenu);\n            });\n            if (!inBody(activeMenu.element)) {\n              Replacing.append(container, premade(activeMenu));\n            }\n            remove$1(activeMenu.element, [detail.markers.backgroundMenu]);\n            setActiveMenuAndItem(container, activeMenu);\n            closeOthers(container, state, path);\n            return Optional.some(activeMenu);\n          }\n        });\n      });\n    };\n    var ExpandHighlightDecision;\n    (function (ExpandHighlightDecision) {\n      ExpandHighlightDecision[ExpandHighlightDecision['HighlightSubmenu'] = 0] = 'HighlightSubmenu';\n      ExpandHighlightDecision[ExpandHighlightDecision['HighlightParent'] = 1] = 'HighlightParent';\n    })(ExpandHighlightDecision || (ExpandHighlightDecision = {}));\n    var buildIfRequired = function buildIfRequired(container, menuName, menuPrep) {\n      if (menuPrep.type === 'notbuilt') {\n        var _menu2 = container.getSystem().build(menuPrep.nbMenu());\n        layeredState.setMenuBuilt(menuName, _menu2);\n        return _menu2;\n      } else {\n        return menuPrep.menu;\n      }\n    };\n    var expandRight = function expandRight(container, item) {\n      var decision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ExpandHighlightDecision.HighlightSubmenu;\n      if (item.hasConfigured(Disabling) && Disabling.isDisabled(item)) {\n        return Optional.some(item);\n      } else {\n        var _value2 = getItemValue(item);\n        return layeredState.expand(_value2).bind(function (path) {\n          updateAriaExpansions(container, path);\n          return Optional.from(path[0]).bind(function (menuName) {\n            return layeredState.lookupMenu(menuName).bind(function (activeMenuPrep) {\n              var activeMenu = buildIfRequired(container, menuName, activeMenuPrep);\n              if (!inBody(activeMenu.element)) {\n                Replacing.append(container, premade(activeMenu));\n              }\n              detail.onOpenSubmenu(container, item, activeMenu, reverse(path));\n              if (decision === ExpandHighlightDecision.HighlightSubmenu) {\n                Highlighting.highlightFirst(activeMenu);\n                return updateMenuPath(container, layeredState, path);\n              } else {\n                Highlighting.dehighlightAll(activeMenu);\n                return Optional.some(item);\n              }\n            });\n          });\n        });\n      }\n    };\n    var collapseLeft = function collapseLeft(container, item) {\n      var value = getItemValue(item);\n      return layeredState.collapse(value).bind(function (path) {\n        updateAriaExpansions(container, path);\n        return updateMenuPath(container, layeredState, path).map(function (activeMenu) {\n          detail.onCollapseMenu(container, item, activeMenu);\n          return activeMenu;\n        });\n      });\n    };\n    var updateView = function updateView(container, item) {\n      var value = getItemValue(item);\n      return layeredState.refresh(value).bind(function (path) {\n        updateAriaExpansions(container, path);\n        return updateMenuPath(container, layeredState, path);\n      });\n    };\n    var onRight = function onRight(container, item) {\n      return inside(item.element) ? Optional.none() : expandRight(container, item, ExpandHighlightDecision.HighlightSubmenu);\n    };\n    var onLeft = function onLeft(container, item) {\n      return inside(item.element) ? Optional.none() : collapseLeft(container, item);\n    };\n    var onEscape = function onEscape(container, item) {\n      return collapseLeft(container, item).orThunk(function () {\n        return detail.onEscape(container, item).map(function () {\n          return container;\n        });\n      });\n    };\n    var keyOnItem = function keyOnItem(f) {\n      return function (container, simulatedEvent) {\n        return closest$1(simulatedEvent.getSource(), \".\".concat(detail.markers.item)).bind(function (target) {\n          return container.getSystem().getByDom(target).toOptional().bind(function (item) {\n            return f(container, item).map(always);\n          });\n        });\n      };\n    };\n    var events = derive$2([run$1(focus(), function (tmenu, simulatedEvent) {\n      var item = simulatedEvent.event.item;\n      layeredState.lookupItem(getItemValue(item)).each(function () {\n        var menu = simulatedEvent.event.menu;\n        Highlighting.highlight(tmenu, menu);\n        var value = getItemValue(simulatedEvent.event.item);\n        layeredState.refresh(value).each(function (path) {\n          return closeOthers(tmenu, layeredState, path);\n        });\n      });\n    }), runOnExecute$1(function (component, simulatedEvent) {\n      var target = simulatedEvent.event.target;\n      component.getSystem().getByDom(target).each(function (item) {\n        var itemValue = getItemValue(item);\n        if (itemValue.indexOf('collapse-item') === 0) {\n          collapseLeft(component, item);\n        }\n        expandRight(component, item, ExpandHighlightDecision.HighlightSubmenu).fold(function () {\n          detail.onExecute(component, item);\n        }, noop);\n      });\n    }), runOnAttached(function (container, _simulatedEvent) {\n      setup(container).each(function (primary) {\n        Replacing.append(container, premade(primary));\n        detail.onOpenMenu(container, primary);\n        if (detail.highlightOnOpen === HighlightOnOpen.HighlightMenuAndItem) {\n          setActiveMenuAndItem(container, primary);\n        } else if (detail.highlightOnOpen === HighlightOnOpen.HighlightJustMenu) {\n          setActiveMenu(container, primary);\n        }\n      });\n    }), run$1(onMenuItemHighlightedEvent, function (tmenuComp, se) {\n      detail.onHighlightItem(tmenuComp, se.event.menuComp, se.event.itemComp);\n    }), run$1(onMenuItemDehighlightedEvent, function (tmenuComp, se) {\n      detail.onDehighlightItem(tmenuComp, se.event.menuComp, se.event.itemComp);\n    })].concat(_toConsumableArray(detail.navigateOnHover ? [run$1(hover(), function (tmenu, simulatedEvent) {\n      var item = simulatedEvent.event.item;\n      updateView(tmenu, item);\n      expandRight(tmenu, item, ExpandHighlightDecision.HighlightParent);\n      detail.onHover(tmenu, item);\n    })] : [])));\n    var getActiveItem = function getActiveItem(container) {\n      return Highlighting.getHighlighted(container).bind(Highlighting.getHighlighted);\n    };\n    var collapseMenuApi = function collapseMenuApi(container) {\n      getActiveItem(container).each(function (currentItem) {\n        collapseLeft(container, currentItem);\n      });\n    };\n    var highlightPrimary = function highlightPrimary(container) {\n      layeredState.getPrimary().each(function (primary) {\n        setActiveMenuAndItem(container, primary);\n      });\n    };\n    var extractMenuFromContainer = function extractMenuFromContainer(container) {\n      return Optional.from(container.components()[0]).filter(function (comp) {\n        return get$f(comp.element, 'role') === 'menu';\n      });\n    };\n    var repositionMenus = function repositionMenus(container) {\n      var maybeActivePrimary = layeredState.getPrimary().bind(function (primary) {\n        return getActiveItem(container).bind(function (currentItem) {\n          var itemValue = getItemValue(currentItem);\n          var allMenus = values(layeredState.getMenus());\n          var preparedMenus = cat(map$2(allMenus, LayeredState.extractPreparedMenu));\n          return layeredState.getTriggeringPath(itemValue, function (v) {\n            return getItemByValue(container, preparedMenus, v);\n          });\n        }).map(function (triggeringPath) {\n          return {\n            primary: primary,\n            triggeringPath: triggeringPath\n          };\n        });\n      });\n      maybeActivePrimary.fold(function () {\n        extractMenuFromContainer(container).each(function (primaryMenu) {\n          detail.onRepositionMenu(container, primaryMenu, []);\n        });\n      }, function (_ref4) {\n        var primary = _ref4.primary,\n          triggeringPath = _ref4.triggeringPath;\n        detail.onRepositionMenu(container, primary, triggeringPath);\n      });\n    };\n    var apis = {\n      collapseMenu: collapseMenuApi,\n      highlightPrimary: highlightPrimary,\n      repositionMenus: repositionMenus\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      markers: detail.markers,\n      behaviours: augment(detail.tmenuBehaviours, [Keying.config({\n        mode: 'special',\n        onRight: keyOnItem(onRight),\n        onLeft: keyOnItem(onLeft),\n        onEscape: keyOnItem(onEscape),\n        focusIn: function focusIn(container, _keyInfo) {\n          layeredState.getPrimary().each(function (primary) {\n            dispatch(container, primary.element, focusItem());\n          });\n        }\n      }), Highlighting.config({\n        highlightClass: detail.markers.selectedMenu,\n        itemClass: detail.markers.menu\n      }), Composing.config({\n        find: function find(container) {\n          return Highlighting.getHighlighted(container);\n        }\n      }), Replacing.config({})]),\n      eventOrder: detail.eventOrder,\n      apis: apis,\n      events: events\n    };\n  };\n  var collapseItem$1 = constant$1('collapse-item');\n  var tieredData = function tieredData(primary, menus, expansions) {\n    return {\n      primary: primary,\n      menus: menus,\n      expansions: expansions\n    };\n  };\n  var singleData = function singleData(name, menu) {\n    return {\n      primary: name,\n      menus: wrap$1(name, menu),\n      expansions: {}\n    };\n  };\n  var collapseItem = function collapseItem(text) {\n    return {\n      value: generate$6(collapseItem$1()),\n      meta: {\n        text: text\n      }\n    };\n  };\n  var tieredMenu = single({\n    name: 'TieredMenu',\n    configFields: [onStrictKeyboardHandler('onExecute'), onStrictKeyboardHandler('onEscape'), onStrictHandler('onOpenMenu'), onStrictHandler('onOpenSubmenu'), onHandler('onRepositionMenu'), onHandler('onCollapseMenu'), defaulted('highlightOnOpen', HighlightOnOpen.HighlightMenuAndItem), requiredObjOf('data', [required$1('primary'), required$1('menus'), required$1('expansions')]), defaulted('fakeFocus', false), onHandler('onHighlightItem'), onHandler('onDehighlightItem'), onHandler('onHover'), tieredMenuMarkers(), required$1('dom'), defaulted('navigateOnHover', true), defaulted('stayInDom', false), field('tmenuBehaviours', [Keying, Highlighting, Composing, Replacing]), defaulted('eventOrder', {})],\n    apis: {\n      collapseMenu: function collapseMenu(apis, tmenu) {\n        apis.collapseMenu(tmenu);\n      },\n      highlightPrimary: function highlightPrimary(apis, tmenu) {\n        apis.highlightPrimary(tmenu);\n      },\n      repositionMenus: function repositionMenus(apis, tmenu) {\n        apis.repositionMenus(tmenu);\n      }\n    },\n    factory: make$6,\n    extraApis: {\n      tieredData: tieredData,\n      singleData: singleData,\n      collapseItem: collapseItem\n    }\n  });\n  var makeMenu = function makeMenu(detail, menuSandbox, placementSpec, menuSpec, getBounds) {\n    var lazySink = function lazySink() {\n      return detail.lazySink(menuSandbox);\n    };\n    var layouts = menuSpec.type === 'horizontal' ? {\n      layouts: {\n        onLtr: function onLtr() {\n          return belowOrAbove();\n        },\n        onRtl: function onRtl() {\n          return belowOrAboveRtl();\n        }\n      }\n    } : {};\n    var isFirstTierSubmenu = function isFirstTierSubmenu(triggeringPaths) {\n      return triggeringPaths.length === 2;\n    };\n    var getSubmenuLayouts = function getSubmenuLayouts(triggeringPaths) {\n      return isFirstTierSubmenu(triggeringPaths) ? layouts : {};\n    };\n    return tieredMenu.sketch({\n      dom: {\n        tag: 'div'\n      },\n      data: menuSpec.data,\n      markers: menuSpec.menu.markers,\n      highlightOnOpen: menuSpec.menu.highlightOnOpen,\n      fakeFocus: menuSpec.menu.fakeFocus,\n      onEscape: function onEscape() {\n        Sandboxing.close(menuSandbox);\n        detail.onEscape.map(function (handler) {\n          return handler(menuSandbox);\n        });\n        return Optional.some(true);\n      },\n      onExecute: function onExecute() {\n        return Optional.some(true);\n      },\n      onOpenMenu: function onOpenMenu(tmenu, menu) {\n        Positioning.positionWithinBounds(lazySink().getOrDie(), menu, placementSpec, getBounds());\n      },\n      onOpenSubmenu: function onOpenSubmenu(tmenu, item, submenu, triggeringPaths) {\n        var sink = lazySink().getOrDie();\n        Positioning.position(sink, submenu, {\n          anchor: _objectSpread({\n            type: 'submenu',\n            item: item\n          }, getSubmenuLayouts(triggeringPaths))\n        });\n      },\n      onRepositionMenu: function onRepositionMenu(tmenu, primaryMenu, submenuTriggers) {\n        var sink = lazySink().getOrDie();\n        Positioning.positionWithinBounds(sink, primaryMenu, placementSpec, getBounds());\n        each$1(submenuTriggers, function (st) {\n          var submenuLayouts = getSubmenuLayouts(st.triggeringPath);\n          Positioning.position(sink, st.triggeredMenu, {\n            anchor: _objectSpread({\n              type: 'submenu',\n              item: st.triggeringItem\n            }, submenuLayouts)\n          });\n        });\n      }\n    });\n  };\n  var factory$o = function factory$o(detail, spec) {\n    var isPartOfRelated = function isPartOfRelated(sandbox, queryElem) {\n      var related = detail.getRelated(sandbox);\n      return related.exists(function (rel) {\n        return isPartOf$1(rel, queryElem);\n      });\n    };\n    var setContent = function setContent(sandbox, thing) {\n      Sandboxing.setContent(sandbox, thing);\n    };\n    var showAt = function showAt(sandbox, thing, placementSpec) {\n      var getBounds = Optional.none;\n      showWithinBounds(sandbox, thing, placementSpec, getBounds);\n    };\n    var showWithinBounds = function showWithinBounds(sandbox, thing, placementSpec, getBounds) {\n      var sink = detail.lazySink(sandbox).getOrDie();\n      Sandboxing.openWhileCloaked(sandbox, thing, function () {\n        return Positioning.positionWithinBounds(sink, sandbox, placementSpec, getBounds());\n      });\n      Representing.setValue(sandbox, Optional.some({\n        mode: 'position',\n        config: placementSpec,\n        getBounds: getBounds\n      }));\n    };\n    var showMenuAt = function showMenuAt(sandbox, placementSpec, menuSpec) {\n      showMenuWithinBounds(sandbox, placementSpec, menuSpec, Optional.none);\n    };\n    var showMenuWithinBounds = function showMenuWithinBounds(sandbox, placementSpec, menuSpec, getBounds) {\n      var menu = makeMenu(detail, sandbox, placementSpec, menuSpec, getBounds);\n      Sandboxing.open(sandbox, menu);\n      Representing.setValue(sandbox, Optional.some({\n        mode: 'menu',\n        menu: menu\n      }));\n    };\n    var hide = function hide(sandbox) {\n      if (Sandboxing.isOpen(sandbox)) {\n        Representing.setValue(sandbox, Optional.none());\n        Sandboxing.close(sandbox);\n      }\n    };\n    var getContent = function getContent(sandbox) {\n      return Sandboxing.getState(sandbox);\n    };\n    var reposition = function reposition(sandbox) {\n      if (Sandboxing.isOpen(sandbox)) {\n        Representing.getValue(sandbox).each(function (state) {\n          switch (state.mode) {\n            case 'menu':\n              Sandboxing.getState(sandbox).each(tieredMenu.repositionMenus);\n              break;\n            case 'position':\n              var sink = detail.lazySink(sandbox).getOrDie();\n              Positioning.positionWithinBounds(sink, sandbox, state.config, state.getBounds());\n              break;\n          }\n        });\n      }\n    };\n    var apis = {\n      setContent: setContent,\n      showAt: showAt,\n      showWithinBounds: showWithinBounds,\n      showMenuAt: showMenuAt,\n      showMenuWithinBounds: showMenuWithinBounds,\n      hide: hide,\n      getContent: getContent,\n      reposition: reposition,\n      isOpen: Sandboxing.isOpen\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      behaviours: augment(detail.inlineBehaviours, [Sandboxing.config({\n        isPartOf: function isPartOf(sandbox, data, queryElem) {\n          return isPartOf$1(data, queryElem) || isPartOfRelated(sandbox, queryElem);\n        },\n        getAttachPoint: function getAttachPoint(sandbox) {\n          return detail.lazySink(sandbox).getOrDie();\n        },\n        onOpen: function onOpen(sandbox) {\n          detail.onShow(sandbox);\n        },\n        onClose: function onClose(sandbox) {\n          detail.onHide(sandbox);\n        }\n      }), Representing.config({\n        store: {\n          mode: 'memory',\n          initialValue: Optional.none()\n        }\n      }), Receiving.config({\n        channels: _objectSpread({}, receivingChannel$1(_objectSpread({\n          isExtraPart: spec.isExtraPart\n        }, detail.fireDismissalEventInstead.map(function (fe) {\n          return {\n            fireEventInstead: {\n              event: fe.event\n            }\n          };\n        }).getOr({}))), receivingChannel(_objectSpread({}, detail.fireRepositionEventInstead.map(function (fe) {\n          return {\n            fireEventInstead: {\n              event: fe.event\n            }\n          };\n        }).getOr({}), {\n          doReposition: reposition\n        })))\n      })]),\n      eventOrder: detail.eventOrder,\n      apis: apis\n    };\n  };\n  var InlineView = single({\n    name: 'InlineView',\n    configFields: [required$1('lazySink'), onHandler('onShow'), onHandler('onHide'), optionFunction('onEscape'), field('inlineBehaviours', [Sandboxing, Representing, Receiving]), optionObjOf('fireDismissalEventInstead', [defaulted('event', dismissRequested())]), optionObjOf('fireRepositionEventInstead', [defaulted('event', repositionRequested())]), defaulted('getRelated', Optional.none), defaulted('isExtraPart', never), defaulted('eventOrder', Optional.none)],\n    factory: factory$o,\n    apis: {\n      showAt: function showAt(apis, component, anchor, thing) {\n        apis.showAt(component, anchor, thing);\n      },\n      showWithinBounds: function showWithinBounds(apis, component, anchor, thing, bounds) {\n        apis.showWithinBounds(component, anchor, thing, bounds);\n      },\n      showMenuAt: function showMenuAt(apis, component, anchor, menuSpec) {\n        apis.showMenuAt(component, anchor, menuSpec);\n      },\n      showMenuWithinBounds: function showMenuWithinBounds(apis, component, anchor, menuSpec, bounds) {\n        apis.showMenuWithinBounds(component, anchor, menuSpec, bounds);\n      },\n      hide: function hide(apis, component) {\n        apis.hide(component);\n      },\n      isOpen: function isOpen(apis, component) {\n        return apis.isOpen(component);\n      },\n      getContent: function getContent(apis, component) {\n        return apis.getContent(component);\n      },\n      setContent: function setContent(apis, component, thing) {\n        apis.setContent(component, thing);\n      },\n      reposition: function reposition(apis, component) {\n        apis.reposition(component);\n      }\n    }\n  });\n  var global$9 = tinymce.util.Tools.resolve('tinymce.util.Delay');\n  var factory$n = function factory$n(detail) {\n    var events = events$a(detail.action);\n    var tag = detail.dom.tag;\n    var lookupAttr = function lookupAttr(attr) {\n      return get$g(detail.dom, 'attributes').bind(function (attrs) {\n        return get$g(attrs, attr);\n      });\n    };\n    var getModAttributes = function getModAttributes() {\n      if (tag === 'button') {\n        var _type2 = lookupAttr('type').getOr('button');\n        var roleAttrs = lookupAttr('role').map(function (role) {\n          return {\n            role: role\n          };\n        }).getOr({});\n        return _objectSpread({\n          type: _type2\n        }, roleAttrs);\n      } else {\n        var role = detail.role.getOr(lookupAttr('role').getOr('button'));\n        return {\n          role: role\n        };\n      }\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: detail.components,\n      events: events,\n      behaviours: SketchBehaviours.augment(detail.buttonBehaviours, [Focusing.config({}), Keying.config({\n        mode: 'execution',\n        useSpace: true,\n        useEnter: true\n      })]),\n      domModification: {\n        attributes: getModAttributes()\n      },\n      eventOrder: detail.eventOrder\n    };\n  };\n  var Button = single({\n    name: 'Button',\n    factory: factory$n,\n    configFields: [defaulted('uid', undefined), required$1('dom'), defaulted('components', []), SketchBehaviours.field('buttonBehaviours', [Focusing, Keying]), option$3('action'), option$3('role'), defaulted('eventOrder', {})]\n  });\n  var getAttrs = function getAttrs(elem) {\n    var attributes = elem.dom.attributes !== undefined ? elem.dom.attributes : [];\n    return foldl(attributes, function (b, attr) {\n      if (attr.name === 'class') {\n        return b;\n      } else {\n        return _objectSpread({}, b, _defineProperty({}, attr.name, attr.value));\n      }\n    }, {});\n  };\n  var getClasses = function getClasses(elem) {\n    return Array.prototype.slice.call(elem.dom.classList, 0);\n  };\n  var fromHtml = function fromHtml(html) {\n    var elem = SugarElement.fromHtml(html);\n    var children$1 = children(elem);\n    var attrs = getAttrs(elem);\n    var classes = getClasses(elem);\n    var contents = children$1.length === 0 ? {} : {\n      innerHtml: get$9(elem)\n    };\n    return _objectSpread({\n      tag: name$3(elem),\n      classes: classes,\n      attributes: attrs\n    }, contents);\n  };\n  var record = function record(spec) {\n    var uid = isSketchSpec(spec) && hasNonNullableKey(spec, 'uid') ? spec.uid : generate$5('memento');\n    var get = function get(anyInSystem) {\n      return anyInSystem.getSystem().getByUid(uid).getOrDie();\n    };\n    var getOpt = function getOpt(anyInSystem) {\n      return anyInSystem.getSystem().getByUid(uid).toOptional();\n    };\n    var asSpec = function asSpec() {\n      return _objectSpread({}, spec, {\n        uid: uid\n      });\n    };\n    return {\n      get: get,\n      getOpt: getOpt,\n      asSpec: asSpec\n    };\n  };\n  var entries = Object.entries,\n    setPrototypeOf = Object.setPrototypeOf,\n    isFrozen = Object.isFrozen,\n    getPrototypeOf = Object.getPrototypeOf,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var freeze = Object.freeze,\n    seal = Object.seal,\n    create$1 = Object.create;\n  var _ref5 = typeof Reflect !== 'undefined' && Reflect,\n    apply = _ref5.apply,\n    construct = _ref5.construct;\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return _construct(Func, _toConsumableArray(args));\n    };\n  }\n  var arrayForEach = unapply(Array.prototype.forEach);\n  var arrayPop = unapply(Array.prototype.pop);\n  var arrayPush = unapply(Array.prototype.push);\n  var stringToLowerCase = unapply(String.prototype.toLowerCase);\n  var stringToString = unapply(String.prototype.toString);\n  var stringMatch = unapply(String.prototype.match);\n  var stringReplace = unapply(String.prototype.replace);\n  var stringIndexOf = unapply(String.prototype.indexOf);\n  var stringTrim = unapply(String.prototype.trim);\n  var regExpTest = unapply(RegExp.prototype.test);\n  var typeErrorCreate = unconstruct(TypeError);\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return apply(func, thisArg, args);\n    };\n  }\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return construct(func, args);\n    };\n  }\n  function addToSet(set, array, transformCaseFunc) {\n    var _transformCaseFunc;\n    transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;\n    if (setPrototypeOf) {\n      setPrototypeOf(set, null);\n    }\n    var l = array.length;\n    while (l--) {\n      var _element = array[l];\n      if (typeof _element === 'string') {\n        var lcElement = transformCaseFunc(_element);\n        if (lcElement !== _element) {\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n          _element = lcElement;\n        }\n      }\n      set[_element] = true;\n    }\n    return set;\n  }\n  function clone(object) {\n    var newObject = create$1(null);\n    var _iterator3 = _createForOfIteratorHelper(entries(object)),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _slicedToArray(_step3.value, 2),\n          property = _step3$value[0],\n          _value3 = _step3$value[1];\n        newObject[property] = _value3;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return newObject;\n  }\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      var desc = getOwnPropertyDescriptor(object, prop);\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n      object = getPrototypeOf(object);\n    }\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n    return fallbackValue;\n  }\n  var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n  var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n  var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);\n  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n  var text$1 = freeze(['#text']);\n  var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n  var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n  var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n  var MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm);\n  var ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n  var TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\n  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\n  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\n  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\n  var DOCTYPE_NAME = seal(/^html$/i);\n  var EXPRESSIONS = Object.freeze({\n    __proto__: null,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    ERB_EXPR: ERB_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR,\n    DATA_ATTR: DATA_ATTR,\n    ARIA_ATTR: ARIA_ATTR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    DOCTYPE_NAME: DOCTYPE_NAME\n  });\n  var getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n    var suffix = null;\n    var ATTR_NAME = 'data-tt-policy-suffix';\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n      suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML: function createHTML(html) {\n          return html;\n        },\n        createScriptURL: function createScriptURL(scriptUrl) {\n          return scriptUrl;\n        }\n      });\n    } catch (_) {\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n  function createDOMPurify() {\n    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n    var DOMPurify = function DOMPurify(root) {\n      return createDOMPurify(root);\n    };\n    DOMPurify.version = '3.0.5';\n    DOMPurify.removed = [];\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      DOMPurify.isSupported = false;\n      return DOMPurify;\n    }\n    var originalDocument = window.document;\n    var currentScript = originalDocument.currentScript;\n    var document = window.document;\n    var DocumentFragment = window.DocumentFragment,\n      HTMLTemplateElement = window.HTMLTemplateElement,\n      Node = window.Node,\n      Element = window.Element,\n      NodeFilter = window.NodeFilter,\n      _window$NamedNodeMap = window.NamedNodeMap,\n      NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n      HTMLFormElement = window.HTMLFormElement,\n      DOMParser = window.DOMParser,\n      trustedTypes = window.trustedTypes;\n    var ElementPrototype = Element.prototype;\n    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n    if (typeof HTMLTemplateElement === 'function') {\n      var template = document.createElement('template');\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n    var trustedTypesPolicy;\n    var emptyHTML = '';\n    var _document = document,\n      implementation = _document.implementation,\n      createNodeIterator = _document.createNodeIterator,\n      createDocumentFragment = _document.createDocumentFragment,\n      getElementsByTagName = _document.getElementsByTagName;\n    var importNode = originalDocument.importNode;\n    var hooks = {};\n    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n    var MUSTACHE_EXPR = EXPRESSIONS.MUSTACHE_EXPR,\n      ERB_EXPR = EXPRESSIONS.ERB_EXPR,\n      TMPLIT_EXPR = EXPRESSIONS.TMPLIT_EXPR,\n      DATA_ATTR = EXPRESSIONS.DATA_ATTR,\n      ARIA_ATTR = EXPRESSIONS.ARIA_ATTR,\n      IS_SCRIPT_OR_DATA = EXPRESSIONS.IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE = EXPRESSIONS.ATTR_WHITESPACE;\n    var IS_ALLOWED_URI$1 = EXPRESSIONS.IS_ALLOWED_URI;\n    var ALLOWED_TAGS = null;\n    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text$1)));\n    var ALLOWED_ATTR = null;\n    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));\n    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false\n      }\n    }));\n    var FORBID_TAGS = null;\n    var FORBID_ATTR = null;\n    var ALLOW_ARIA_ATTR = true;\n    var ALLOW_DATA_ATTR = true;\n    var ALLOW_UNKNOWN_PROTOCOLS = false;\n    var ALLOW_SELF_CLOSE_IN_ATTR = true;\n    var SAFE_FOR_TEMPLATES = false;\n    var WHOLE_DOCUMENT = false;\n    var SET_CONFIG = false;\n    var FORCE_BODY = false;\n    var RETURN_DOM = false;\n    var RETURN_DOM_FRAGMENT = false;\n    var RETURN_TRUSTED_TYPE = false;\n    var SANITIZE_DOM = true;\n    var SANITIZE_NAMED_PROPS = false;\n    var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n    var KEEP_CONTENT = true;\n    var IN_PLACE = false;\n    var USE_PROFILES = {};\n    var FORBID_CONTENTS = null;\n    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n    var DATA_URI_TAGS = null;\n    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n    var URI_SAFE_ATTRIBUTES = null;\n    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    var NAMESPACE = HTML_NAMESPACE;\n    var IS_EMPTY_INPUT = false;\n    var ALLOWED_NAMESPACES = null;\n    var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n    var PARSER_MEDIA_TYPE;\n    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n    var transformCaseFunc;\n    var CONFIG = null;\n    var formElement = document.createElement('form');\n    var isRegexOrFunction = function isRegexOrFunction(testValue) {\n      return testValue instanceof RegExp || testValue instanceof Function;\n    };\n    var _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n      if (!cfg || typeof cfg !== 'object') {\n        cfg = {};\n      }\n      cfg = clone(cfg);\n      PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n      ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\n      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\n      RETURN_DOM = cfg.RETURN_DOM || false;\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\n      FORCE_BODY = cfg.FORCE_BODY || false;\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\n      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\n      IN_PLACE = cfg.IN_PLACE || false;\n      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n      }\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n      }\n      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n      }\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, _toConsumableArray(text$1));\n        ALLOWED_ATTR = [];\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html$1);\n          addToSet(ALLOWED_ATTR, html);\n        }\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg$1);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl$1);\n          addToSet(ALLOWED_ATTR, mathMl);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n      }\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n      }\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n      }\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n      }\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n      if (cfg.TRUSTED_TYPES_POLICY) {\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n        }\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n        }\n        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      } else {\n        if (trustedTypesPolicy === undefined) {\n          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n        }\n        if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        }\n      }\n      if (freeze) {\n        freeze(cfg);\n      }\n      CONFIG = cfg;\n    };\n    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n    var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n    var ALL_SVG_TAGS = addToSet({}, svg$1);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n    var ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n    var _checkValidNamespace = function _checkValidNamespace(element) {\n      var parent = getParentNode(element);\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: NAMESPACE,\n          tagName: 'template'\n        };\n      }\n      var tagName = stringToLowerCase(element.tagName);\n      var parentTagName = stringToLowerCase(parent.tagName);\n      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return false;\n      }\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return true;\n      }\n      return false;\n    };\n    var _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, {\n        element: node\n      });\n      try {\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        node.remove();\n      }\n    };\n    var _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n      node.removeAttribute(name);\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n    var _initDocument = function _initDocument(dirty) {\n      var doc;\n      var leadingWhitespace;\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n        dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n      }\n      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n        } catch (_) {}\n      }\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n        } catch (_) {}\n      }\n      var body = doc.body || doc.documentElement;\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    var _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n    var _isClobbered = function _isClobbered(elm) {\n      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n    };\n    var _isNode = function _isNode(object) {\n      return typeof Node === 'object' ? object instanceof Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n    var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n      arrayForEach(hooks[entryPoint], function (hook) {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n    var _sanitizeElements = function _sanitizeElements(currentNode) {\n      var content;\n      _executeHook('beforeSanitizeElements', currentNode, null);\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n      var tagName = transformCaseFunc(currentNode.nodeName);\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName: tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;\n        }\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          var _parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n          if (childNodes && _parentNode) {\n            var childCount = childNodes.length;\n            for (var i = childCount - 1; i >= 0; --i) {\n              _parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n        _forceRemove(currentNode);\n        return true;\n      }\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n      if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR, ' ');\n        content = stringReplace(content, ERB_EXPR, ' ');\n        content = stringReplace(content, TMPLIT_EXPR, ' ');\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, {\n            element: currentNode.cloneNode()\n          });\n          currentNode.textContent = content;\n        }\n      }\n      _executeHook('afterSanitizeElements', currentNode, null);\n      return false;\n    };\n    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;else {\n          return false;\n        }\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if (value) {\n        return false;\n      } else ;\n      return true;\n    };\n    var _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n      return tagName.indexOf('-') > 0;\n    };\n    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      var attr;\n      var value;\n      var lcName;\n      var l;\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n      var attributes = currentNode.attributes;\n      if (!attributes) {\n        return;\n      }\n      var hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n      while (l--) {\n        attr = attributes[l];\n        var _attr = attr,\n          _name2 = _attr.name,\n          namespaceURI = _attr.namespaceURI;\n        value = _name2 === 'value' ? attr.value : stringTrim(attr.value);\n        var initValue = value;\n        lcName = transformCaseFunc(_name2);\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined;\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n        value = hookEvent.attrValue;\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n        if (!hookEvent.keepAttr) {\n          _removeAttribute(_name2, currentNode);\n          continue;\n        }\n        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n          _removeAttribute(_name2, currentNode);\n          continue;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR, ' ');\n          value = stringReplace(value, ERB_EXPR, ' ');\n          value = stringReplace(value, TMPLIT_EXPR, ' ');\n        }\n        var lcTag = transformCaseFunc(currentNode.nodeName);\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          _removeAttribute(_name2, currentNode);\n          continue;\n        }\n        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n          _removeAttribute(_name2, currentNode);\n          value = SANITIZE_NAMED_PROPS_PREFIX + value;\n        }\n        if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n          if (namespaceURI) ;else {\n            switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n              case 'TrustedHTML':\n                {\n                  value = trustedTypesPolicy.createHTML(value);\n                  break;\n                }\n              case 'TrustedScriptURL':\n                {\n                  value = trustedTypesPolicy.createScriptURL(value);\n                  break;\n                }\n            }\n          }\n        }\n        if (value !== initValue) {\n          try {\n            if (namespaceURI) {\n              currentNode.setAttributeNS(namespaceURI, _name2, value);\n            } else {\n              currentNode.setAttribute(_name2, value);\n            }\n          } catch (_) {\n            _removeAttribute(_name2, currentNode);\n          }\n        }\n      }\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      var shadowNode;\n      var shadowIterator = _createIterator(fragment);\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n      while (shadowNode = shadowIterator.nextNode()) {\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n        _sanitizeAttributes(shadowNode);\n      }\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n    DOMPurify.sanitize = function (dirty) {\n      var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var body;\n      var importedNode;\n      var currentNode;\n      var returnNode;\n      IS_EMPTY_INPUT = !dirty;\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        if (typeof dirty.toString === 'function') {\n          dirty = dirty.toString();\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        } else {\n          throw typeErrorCreate('toString is not a function');\n        }\n      }\n      if (!DOMPurify.isSupported) {\n        return dirty;\n      }\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n      DOMPurify.removed = [];\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n      if (IN_PLACE) {\n        if (dirty.nodeName) {\n          var tagName = transformCaseFunc(dirty.nodeName);\n          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n          }\n        }\n      } else if (dirty instanceof Node) {\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          body.appendChild(importedNode);\n        }\n      } else {\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n        body = _initDocument(dirty);\n        if (!body) {\n          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n        }\n      }\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n      while (currentNode = nodeIterator.nextNode()) {\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n        _sanitizeAttributes(currentNode);\n      }\n      if (IN_PLACE) {\n        return dirty;\n      }\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n          while (body.firstChild) {\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n        return returnNode;\n      }\n      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n      }\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR, ' ');\n        serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR, ' ');\n      }\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n      SET_CONFIG = true;\n    };\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n      var lcTag = transformCaseFunc(tag);\n      var lcName = transformCaseFunc(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        return arrayPop(hooks[entryPoint]);\n      }\n    };\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n    return DOMPurify;\n  }\n  var purify = createDOMPurify();\n  var sanitizeHtmlString = function sanitizeHtmlString(html) {\n    return purify().sanitize(html);\n  };\n  var global$8 = tinymce.util.Tools.resolve('tinymce.util.I18n');\n  var rtlTransform = {\n    'indent': true,\n    'outdent': true,\n    'table-insert-column-after': true,\n    'table-insert-column-before': true,\n    'paste-column-after': true,\n    'paste-column-before': true,\n    'unordered-list': true,\n    'list-bull-circle': true,\n    'list-bull-default': true,\n    'list-bull-square': true\n  };\n  var defaultIconName = 'temporary-placeholder';\n  var defaultIcon = function defaultIcon(icons) {\n    return function () {\n      return get$g(icons, defaultIconName).getOr('!not found!');\n    };\n  };\n  var getIconName = function getIconName(name, icons) {\n    var lcName = name.toLowerCase();\n    if (global$8.isRtl()) {\n      var rtlName = ensureTrailing(lcName, '-rtl');\n      return has$2(icons, rtlName) ? rtlName : lcName;\n    } else {\n      return lcName;\n    }\n  };\n  var lookupIcon = function lookupIcon(name, icons) {\n    return get$g(icons, getIconName(name, icons));\n  };\n  var get$2 = function get$2(name, iconProvider) {\n    var icons = iconProvider();\n    return lookupIcon(name, icons).getOrThunk(defaultIcon(icons));\n  };\n  var getOr = function getOr(name, iconProvider, fallbackIcon) {\n    var icons = iconProvider();\n    return lookupIcon(name, icons).or(fallbackIcon).getOrThunk(defaultIcon(icons));\n  };\n  var needsRtlTransform = function needsRtlTransform(iconName) {\n    return global$8.isRtl() ? has$2(rtlTransform, iconName) : false;\n  };\n  var addFocusableBehaviour = function addFocusableBehaviour() {\n    return config('add-focusable', [runOnAttached(function (comp) {\n      child(comp.element, 'svg').each(function (svg) {\n        return set$9(svg, 'focusable', 'false');\n      });\n    })]);\n  };\n  var renderIcon$3 = function renderIcon$3(spec, iconName, icons, fallbackIcon) {\n    var _a, _b;\n    var rtlIconClasses = needsRtlTransform(iconName) ? ['tox-icon--flip'] : [];\n    var iconHtml = get$g(icons, getIconName(iconName, icons)).or(fallbackIcon).getOrThunk(defaultIcon(icons));\n    return {\n      dom: {\n        tag: spec.tag,\n        attributes: (_a = spec.attributes) !== null && _a !== void 0 ? _a : {},\n        classes: spec.classes.concat(rtlIconClasses),\n        innerHtml: iconHtml\n      },\n      behaviours: derive$1([].concat(_toConsumableArray((_b = spec.behaviours) !== null && _b !== void 0 ? _b : []), [addFocusableBehaviour()]))\n    };\n  };\n  var render$3 = function render$3(iconName, spec, iconProvider) {\n    var fallbackIcon = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Optional.none();\n    return renderIcon$3(spec, iconName, iconProvider(), fallbackIcon);\n  };\n  var renderFirst = function renderFirst(iconNames, spec, iconProvider) {\n    var icons = iconProvider();\n    var iconName = find$5(iconNames, function (name) {\n      return has$2(icons, getIconName(name, icons));\n    });\n    return renderIcon$3(spec, iconName.getOr(defaultIconName), icons, Optional.none());\n  };\n  var notificationIconMap = {\n    success: 'checkmark',\n    error: 'warning',\n    err: 'error',\n    warning: 'warning',\n    warn: 'warning',\n    info: 'info'\n  };\n  var factory$m = function factory$m(detail) {\n    var memBannerText = record({\n      dom: fromHtml(\"<p>\".concat(sanitizeHtmlString(detail.translationProvider(detail.text)), \"</p>\")),\n      behaviours: derive$1([Replacing.config({})])\n    });\n    var renderPercentBar = function renderPercentBar(percent) {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-bar'],\n          styles: {\n            width: \"\".concat(percent, \"%\")\n          }\n        }\n      };\n    };\n    var renderPercentText = function renderPercentText(percent) {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-text'],\n          innerHtml: \"\".concat(percent, \"%\")\n        }\n      };\n    };\n    var memBannerProgress = record({\n      dom: {\n        tag: 'div',\n        classes: detail.progress ? ['tox-progress-bar', 'tox-progress-indicator'] : ['tox-progress-bar']\n      },\n      components: [{\n        dom: {\n          tag: 'div',\n          classes: ['tox-bar-container']\n        },\n        components: [renderPercentBar(0)]\n      }, renderPercentText(0)],\n      behaviours: derive$1([Replacing.config({})])\n    });\n    var updateProgress = function updateProgress(comp, percent) {\n      if (comp.getSystem().isConnected()) {\n        memBannerProgress.getOpt(comp).each(function (progress) {\n          Replacing.set(progress, [{\n            dom: {\n              tag: 'div',\n              classes: ['tox-bar-container']\n            },\n            components: [renderPercentBar(percent)]\n          }, renderPercentText(percent)]);\n        });\n      }\n    };\n    var updateText = function updateText(comp, text) {\n      if (comp.getSystem().isConnected()) {\n        var banner = memBannerText.get(comp);\n        Replacing.set(banner, [text$2(text)]);\n      }\n    };\n    var apis = {\n      updateProgress: updateProgress,\n      updateText: updateText\n    };\n    var iconChoices = flatten([detail.icon.toArray(), detail.level.toArray(), detail.level.bind(function (level) {\n      return Optional.from(notificationIconMap[level]);\n    }).toArray()]);\n    var memButton = record(Button.sketch({\n      dom: {\n        tag: 'button',\n        classes: ['tox-notification__dismiss', 'tox-button', 'tox-button--naked', 'tox-button--icon']\n      },\n      components: [render$3('close', {\n        tag: 'span',\n        classes: ['tox-icon'],\n        attributes: {\n          'aria-label': detail.translationProvider('Close')\n        }\n      }, detail.iconProvider)],\n      action: function action(comp) {\n        detail.onAction(comp);\n      }\n    }));\n    var notificationIconSpec = renderFirst(iconChoices, {\n      tag: 'div',\n      classes: ['tox-notification__icon']\n    }, detail.iconProvider);\n    var notificationBodySpec = {\n      dom: {\n        tag: 'div',\n        classes: ['tox-notification__body']\n      },\n      components: [memBannerText.asSpec()],\n      behaviours: derive$1([Replacing.config({})])\n    };\n    var components = [notificationIconSpec, notificationBodySpec];\n    return {\n      uid: detail.uid,\n      dom: {\n        tag: 'div',\n        attributes: {\n          role: 'alert'\n        },\n        classes: detail.level.map(function (level) {\n          return ['tox-notification', 'tox-notification--in', \"tox-notification--\".concat(level)];\n        }).getOr(['tox-notification', 'tox-notification--in'])\n      },\n      behaviours: derive$1([Focusing.config({}), config('notification-events', [run$1(focusin(), function (comp) {\n        memButton.getOpt(comp).each(Focusing.focus);\n      })])]),\n      components: components.concat(detail.progress ? [memBannerProgress.asSpec()] : []).concat(!detail.closeButton ? [] : [memButton.asSpec()]),\n      apis: apis\n    };\n  };\n  var Notification = single({\n    name: 'Notification',\n    factory: factory$m,\n    configFields: [option$3('level'), required$1('progress'), option$3('icon'), required$1('onAction'), required$1('text'), required$1('iconProvider'), required$1('translationProvider'), defaultedBoolean('closeButton', true)],\n    apis: {\n      updateProgress: function updateProgress(apis, comp, percent) {\n        apis.updateProgress(comp, percent);\n      },\n      updateText: function updateText(apis, comp, text) {\n        apis.updateText(comp, text);\n      }\n    }\n  });\n  var NotificationManagerImpl = function NotificationManagerImpl(editor, extras, uiMothership) {\n    var sharedBackstage = extras.backstage.shared;\n    var getBounds = function getBounds() {\n      var contentArea = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));\n      var win$1 = win();\n      var x = clamp(win$1.x, contentArea.x, contentArea.right);\n      var y = clamp(win$1.y, contentArea.y, contentArea.bottom);\n      var right = Math.max(contentArea.right, win$1.right);\n      var bottom = Math.max(contentArea.bottom, win$1.bottom);\n      return Optional.some(bounds(x, y, right - x, bottom - y));\n    };\n    var open = function open(settings, closeCallback) {\n      var close = function close() {\n        closeCallback();\n        InlineView.hide(notificationWrapper);\n      };\n      var notification = build$1(Notification.sketch({\n        text: settings.text,\n        level: contains$2(['success', 'error', 'warning', 'warn', 'info'], settings.type) ? settings.type : undefined,\n        progress: settings.progressBar === true,\n        icon: settings.icon,\n        closeButton: settings.closeButton,\n        onAction: close,\n        iconProvider: sharedBackstage.providers.icons,\n        translationProvider: sharedBackstage.providers.translate\n      }));\n      var notificationWrapper = build$1(InlineView.sketch(_objectSpread({\n        dom: {\n          tag: 'div',\n          classes: ['tox-notifications-container']\n        },\n        lazySink: sharedBackstage.getSink,\n        fireDismissalEventInstead: {}\n      }, sharedBackstage.header.isPositionedAtTop() ? {} : {\n        fireRepositionEventInstead: {}\n      })));\n      uiMothership.add(notificationWrapper);\n      if (isNumber(settings.timeout) && settings.timeout > 0) {\n        global$9.setEditorTimeout(editor, function () {\n          close();\n        }, settings.timeout);\n      }\n      var reposition = function reposition() {\n        var notificationSpec = premade(notification);\n        var anchorOverrides = {\n          maxHeightFunction: expandable$1()\n        };\n        var allNotifications = editor.notificationManager.getNotifications();\n        if (allNotifications[0] === thisNotification) {\n          var _anchor2 = _objectSpread({}, sharedBackstage.anchors.banner(), {\n            overrides: anchorOverrides\n          });\n          InlineView.showWithinBounds(notificationWrapper, notificationSpec, {\n            anchor: _anchor2\n          }, getBounds);\n        } else {\n          indexOf(allNotifications, thisNotification).each(function (idx) {\n            var previousNotification = allNotifications[idx - 1].getEl();\n            var nodeAnchor = {\n              type: 'node',\n              root: body(),\n              node: Optional.some(SugarElement.fromDom(previousNotification)),\n              overrides: anchorOverrides,\n              layouts: {\n                onRtl: function onRtl() {\n                  return [south$2];\n                },\n                onLtr: function onLtr() {\n                  return [south$2];\n                }\n              }\n            };\n            InlineView.showWithinBounds(notificationWrapper, notificationSpec, {\n              anchor: nodeAnchor\n            }, getBounds);\n          });\n        }\n      };\n      var thisNotification = {\n        close: close,\n        reposition: reposition,\n        text: function text(nuText) {\n          Notification.updateText(notification, nuText);\n        },\n        settings: settings,\n        getEl: function getEl() {\n          return notification.element.dom;\n        },\n        progressBar: {\n          value: function value(percent) {\n            Notification.updateProgress(notification, percent);\n          }\n        }\n      };\n      return thisNotification;\n    };\n    var close = function close(notification) {\n      notification.close();\n    };\n    var getArgs = function getArgs(notification) {\n      return notification.settings;\n    };\n    return {\n      open: open,\n      close: close,\n      getArgs: getArgs\n    };\n  };\n  var global$7 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\n  var global$6 = tinymce.util.Tools.resolve('tinymce.EditorManager');\n  var global$5 = tinymce.util.Tools.resolve('tinymce.Env');\n  var ToolbarMode$1;\n  (function (ToolbarMode) {\n    ToolbarMode['default'] = 'wrap';\n    ToolbarMode['floating'] = 'floating';\n    ToolbarMode['sliding'] = 'sliding';\n    ToolbarMode['scrolling'] = 'scrolling';\n  })(ToolbarMode$1 || (ToolbarMode$1 = {}));\n  var ToolbarLocation$1;\n  (function (ToolbarLocation) {\n    ToolbarLocation['auto'] = 'auto';\n    ToolbarLocation['top'] = 'top';\n    ToolbarLocation['bottom'] = 'bottom';\n  })(ToolbarLocation$1 || (ToolbarLocation$1 = {}));\n  var option$2 = function option$2(name) {\n    return function (editor) {\n      return editor.options.get(name);\n    };\n  };\n  var wrapOptional = function wrapOptional(fn) {\n    return function (editor) {\n      return Optional.from(fn(editor));\n    };\n  };\n  var register$e = function register$e(editor) {\n    var isPhone = global$5.deviceType.isPhone();\n    var isMobile = global$5.deviceType.isTablet() || isPhone;\n    var registerOption = editor.options.register;\n    var stringOrFalseProcessor = function stringOrFalseProcessor(value) {\n      return isString(value) || value === false;\n    };\n    var stringOrNumberProcessor = function stringOrNumberProcessor(value) {\n      return isString(value) || isNumber(value);\n    };\n    registerOption('skin', {\n      processor: function processor(value) {\n        return isString(value) || value === false;\n      },\n      default: 'oxide'\n    });\n    registerOption('skin_url', {\n      processor: 'string'\n    });\n    registerOption('height', {\n      processor: stringOrNumberProcessor,\n      default: Math.max(editor.getElement().offsetHeight, 400)\n    });\n    registerOption('width', {\n      processor: stringOrNumberProcessor,\n      default: global$7.DOM.getStyle(editor.getElement(), 'width')\n    });\n    registerOption('min_height', {\n      processor: 'number',\n      default: 100\n    });\n    registerOption('min_width', {\n      processor: 'number'\n    });\n    registerOption('max_height', {\n      processor: 'number'\n    });\n    registerOption('max_width', {\n      processor: 'number'\n    });\n    registerOption('style_formats', {\n      processor: 'object[]'\n    });\n    registerOption('style_formats_merge', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('style_formats_autohide', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('line_height_formats', {\n      processor: 'string',\n      default: '1 1.1 1.2 1.3 1.4 1.5 2'\n    });\n    registerOption('font_family_formats', {\n      processor: 'string',\n      default: 'Andale Mono=andale mono,monospace;' + 'Arial=arial,helvetica,sans-serif;' + 'Arial Black=arial black,sans-serif;' + 'Book Antiqua=book antiqua,palatino,serif;' + 'Comic Sans MS=comic sans ms,sans-serif;' + 'Courier New=courier new,courier,monospace;' + 'Georgia=georgia,palatino,serif;' + 'Helvetica=helvetica,arial,sans-serif;' + 'Impact=impact,sans-serif;' + 'Symbol=symbol;' + 'Tahoma=tahoma,arial,helvetica,sans-serif;' + 'Terminal=terminal,monaco,monospace;' + 'Times New Roman=times new roman,times,serif;' + 'Trebuchet MS=trebuchet ms,geneva,sans-serif;' + 'Verdana=verdana,geneva,sans-serif;' + 'Webdings=webdings;' + 'Wingdings=wingdings,zapf dingbats'\n    });\n    registerOption('font_size_formats', {\n      processor: 'string',\n      default: '8pt 10pt 12pt 14pt 18pt 24pt 36pt'\n    });\n    registerOption('font_size_input_default_unit', {\n      processor: 'string',\n      default: 'pt'\n    });\n    registerOption('block_formats', {\n      processor: 'string',\n      default: 'Paragraph=p;' + 'Heading 1=h1;' + 'Heading 2=h2;' + 'Heading 3=h3;' + 'Heading 4=h4;' + 'Heading 5=h5;' + 'Heading 6=h6;' + 'Preformatted=pre'\n    });\n    registerOption('content_langs', {\n      processor: 'object[]'\n    });\n    registerOption('removed_menuitems', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('menubar', {\n      processor: function processor(value) {\n        return isString(value) || isBoolean(value);\n      },\n      default: !isPhone\n    });\n    registerOption('menu', {\n      processor: 'object',\n      default: {}\n    });\n    registerOption('toolbar', {\n      processor: function processor(value) {\n        if (isBoolean(value) || isString(value) || isArray(value)) {\n          return {\n            value: value,\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a boolean, string or array.'\n          };\n        }\n      },\n      default: true\n    });\n    range$2(9, function (num) {\n      registerOption('toolbar' + (num + 1), {\n        processor: 'string'\n      });\n    });\n    registerOption('toolbar_mode', {\n      processor: 'string',\n      default: isMobile ? 'scrolling' : 'floating'\n    });\n    registerOption('toolbar_groups', {\n      processor: 'object',\n      default: {}\n    });\n    registerOption('toolbar_location', {\n      processor: 'string',\n      default: ToolbarLocation$1.auto\n    });\n    registerOption('toolbar_persist', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('toolbar_sticky', {\n      processor: 'boolean',\n      default: editor.inline\n    });\n    registerOption('toolbar_sticky_offset', {\n      processor: 'number',\n      default: 0\n    });\n    registerOption('fixed_toolbar_container', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('fixed_toolbar_container_target', {\n      processor: 'object'\n    });\n    registerOption('ui_mode', {\n      processor: 'string',\n      default: 'combined'\n    });\n    registerOption('file_picker_callback', {\n      processor: 'function'\n    });\n    registerOption('file_picker_validator_handler', {\n      processor: 'function'\n    });\n    registerOption('file_picker_types', {\n      processor: 'string'\n    });\n    registerOption('typeahead_urls', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('anchor_top', {\n      processor: stringOrFalseProcessor,\n      default: '#top'\n    });\n    registerOption('anchor_bottom', {\n      processor: stringOrFalseProcessor,\n      default: '#bottom'\n    });\n    registerOption('draggable_modal', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('statusbar', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('elementpath', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('branding', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('promotion', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('resize', {\n      processor: function processor(value) {\n        return value === 'both' || isBoolean(value);\n      },\n      default: !global$5.deviceType.isTouch()\n    });\n    registerOption('sidebar_show', {\n      processor: 'string'\n    });\n    registerOption('help_accessibility', {\n      processor: 'boolean',\n      default: editor.hasPlugin('help')\n    });\n    registerOption('default_font_stack', {\n      processor: 'string[]',\n      default: []\n    });\n  };\n  var isReadOnly = option$2('readonly');\n  var getHeightOption = option$2('height');\n  var getWidthOption = option$2('width');\n  var getMinWidthOption = wrapOptional(option$2('min_width'));\n  var getMinHeightOption = wrapOptional(option$2('min_height'));\n  var getMaxWidthOption = wrapOptional(option$2('max_width'));\n  var getMaxHeightOption = wrapOptional(option$2('max_height'));\n  var getUserStyleFormats = wrapOptional(option$2('style_formats'));\n  var shouldMergeStyleFormats = option$2('style_formats_merge');\n  var shouldAutoHideStyleFormats = option$2('style_formats_autohide');\n  var getContentLanguages = option$2('content_langs');\n  var getRemovedMenuItems = option$2('removed_menuitems');\n  var getToolbarMode = option$2('toolbar_mode');\n  var getToolbarGroups = option$2('toolbar_groups');\n  var getToolbarLocation = option$2('toolbar_location');\n  var fixedContainerSelector = option$2('fixed_toolbar_container');\n  var fixedToolbarContainerTarget = option$2('fixed_toolbar_container_target');\n  var isToolbarPersist = option$2('toolbar_persist');\n  var getStickyToolbarOffset = option$2('toolbar_sticky_offset');\n  var getMenubar = option$2('menubar');\n  var getToolbar = option$2('toolbar');\n  var getFilePickerCallback = option$2('file_picker_callback');\n  var getFilePickerValidatorHandler = option$2('file_picker_validator_handler');\n  var getFontSizeInputDefaultUnit = option$2('font_size_input_default_unit');\n  var getFilePickerTypes = option$2('file_picker_types');\n  var useTypeaheadUrls = option$2('typeahead_urls');\n  var getAnchorTop = option$2('anchor_top');\n  var getAnchorBottom = option$2('anchor_bottom');\n  var isDraggableModal$1 = option$2('draggable_modal');\n  var useStatusBar = option$2('statusbar');\n  var useElementPath = option$2('elementpath');\n  var useBranding = option$2('branding');\n  var getResize = option$2('resize');\n  var getPasteAsText = option$2('paste_as_text');\n  var getSidebarShow = option$2('sidebar_show');\n  var promotionEnabled = option$2('promotion');\n  var useHelpAccessibility = option$2('help_accessibility');\n  var getDefaultFontStack = option$2('default_font_stack');\n  var isSkinDisabled = function isSkinDisabled(editor) {\n    return editor.options.get('skin') === false;\n  };\n  var isMenubarEnabled = function isMenubarEnabled(editor) {\n    return editor.options.get('menubar') !== false;\n  };\n  var getSkinUrl = function getSkinUrl(editor) {\n    var skinUrl = editor.options.get('skin_url');\n    if (isSkinDisabled(editor)) {\n      return skinUrl;\n    } else {\n      if (skinUrl) {\n        return editor.documentBaseURI.toAbsolute(skinUrl);\n      } else {\n        var skin = editor.options.get('skin');\n        return global$6.baseURL + '/skins/ui/' + skin;\n      }\n    }\n  };\n  var getSkinUrlOption = function getSkinUrlOption(editor) {\n    return Optional.from(editor.options.get('skin_url'));\n  };\n  var getLineHeightFormats = function getLineHeightFormats(editor) {\n    return editor.options.get('line_height_formats').split(' ');\n  };\n  var isToolbarEnabled = function isToolbarEnabled(editor) {\n    var toolbar = getToolbar(editor);\n    var isToolbarString = isString(toolbar);\n    var isToolbarObjectArray = isArray(toolbar) && toolbar.length > 0;\n    return !isMultipleToolbars(editor) && (isToolbarObjectArray || isToolbarString || toolbar === true);\n  };\n  var getMultipleToolbarsOption = function getMultipleToolbarsOption(editor) {\n    var toolbars = range$2(9, function (num) {\n      return editor.options.get('toolbar' + (num + 1));\n    });\n    var toolbarArray = filter$2(toolbars, isString);\n    return someIf(toolbarArray.length > 0, toolbarArray);\n  };\n  var isMultipleToolbars = function isMultipleToolbars(editor) {\n    return getMultipleToolbarsOption(editor).fold(function () {\n      var toolbar = getToolbar(editor);\n      return isArrayOf(toolbar, isString) && toolbar.length > 0;\n    }, always);\n  };\n  var isToolbarLocationBottom = function isToolbarLocationBottom(editor) {\n    return getToolbarLocation(editor) === ToolbarLocation$1.bottom;\n  };\n  var fixedContainerTarget = function fixedContainerTarget(editor) {\n    var _a;\n    if (!editor.inline) {\n      return Optional.none();\n    }\n    var selector = (_a = fixedContainerSelector(editor)) !== null && _a !== void 0 ? _a : '';\n    if (selector.length > 0) {\n      return descendant(body(), selector);\n    }\n    var element = fixedToolbarContainerTarget(editor);\n    if (isNonNullable(element)) {\n      return Optional.some(SugarElement.fromDom(element));\n    }\n    return Optional.none();\n  };\n  var useFixedContainer = function useFixedContainer(editor) {\n    return editor.inline && fixedContainerTarget(editor).isSome();\n  };\n  var getUiContainer = function getUiContainer(editor) {\n    var fixedContainer = fixedContainerTarget(editor);\n    return fixedContainer.getOrThunk(function () {\n      return getContentContainer(getRootNode(SugarElement.fromDom(editor.getElement())));\n    });\n  };\n  var isDistractionFree = function isDistractionFree(editor) {\n    return editor.inline && !isMenubarEnabled(editor) && !isToolbarEnabled(editor) && !isMultipleToolbars(editor);\n  };\n  var isStickyToolbar = function isStickyToolbar(editor) {\n    var isStickyToolbar = editor.options.get('toolbar_sticky');\n    return (isStickyToolbar || editor.inline) && !useFixedContainer(editor) && !isDistractionFree(editor);\n  };\n  var isSplitUiMode = function isSplitUiMode(editor) {\n    return !useFixedContainer(editor) && editor.options.get('ui_mode') === 'split';\n  };\n  var getMenus = function getMenus(editor) {\n    var menu = editor.options.get('menu');\n    return map$1(menu, function (menu) {\n      return _objectSpread({}, menu, {\n        items: menu.items\n      });\n    });\n  };\n  var Options = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get ToolbarMode() {\n      return ToolbarMode$1;\n    },\n    get ToolbarLocation() {\n      return ToolbarLocation$1;\n    },\n    register: register$e,\n    getSkinUrl: getSkinUrl,\n    getSkinUrlOption: getSkinUrlOption,\n    isReadOnly: isReadOnly,\n    isSkinDisabled: isSkinDisabled,\n    getHeightOption: getHeightOption,\n    getWidthOption: getWidthOption,\n    getMinWidthOption: getMinWidthOption,\n    getMinHeightOption: getMinHeightOption,\n    getMaxWidthOption: getMaxWidthOption,\n    getMaxHeightOption: getMaxHeightOption,\n    getUserStyleFormats: getUserStyleFormats,\n    shouldMergeStyleFormats: shouldMergeStyleFormats,\n    shouldAutoHideStyleFormats: shouldAutoHideStyleFormats,\n    getLineHeightFormats: getLineHeightFormats,\n    getContentLanguages: getContentLanguages,\n    getRemovedMenuItems: getRemovedMenuItems,\n    isMenubarEnabled: isMenubarEnabled,\n    isMultipleToolbars: isMultipleToolbars,\n    isToolbarEnabled: isToolbarEnabled,\n    isToolbarPersist: isToolbarPersist,\n    getMultipleToolbarsOption: getMultipleToolbarsOption,\n    getUiContainer: getUiContainer,\n    useFixedContainer: useFixedContainer,\n    isSplitUiMode: isSplitUiMode,\n    getToolbarMode: getToolbarMode,\n    isDraggableModal: isDraggableModal$1,\n    isDistractionFree: isDistractionFree,\n    isStickyToolbar: isStickyToolbar,\n    getStickyToolbarOffset: getStickyToolbarOffset,\n    getToolbarLocation: getToolbarLocation,\n    isToolbarLocationBottom: isToolbarLocationBottom,\n    getToolbarGroups: getToolbarGroups,\n    getMenus: getMenus,\n    getMenubar: getMenubar,\n    getToolbar: getToolbar,\n    getFilePickerCallback: getFilePickerCallback,\n    getFilePickerTypes: getFilePickerTypes,\n    useTypeaheadUrls: useTypeaheadUrls,\n    getAnchorTop: getAnchorTop,\n    getAnchorBottom: getAnchorBottom,\n    getFilePickerValidatorHandler: getFilePickerValidatorHandler,\n    getFontSizeInputDefaultUnit: getFontSizeInputDefaultUnit,\n    useStatusBar: useStatusBar,\n    useElementPath: useElementPath,\n    promotionEnabled: promotionEnabled,\n    useBranding: useBranding,\n    getResize: getResize,\n    getPasteAsText: getPasteAsText,\n    getSidebarShow: getSidebarShow,\n    useHelpAccessibility: useHelpAccessibility,\n    getDefaultFontStack: getDefaultFontStack\n  });\n  var autocompleteSelector = '[data-mce-autocompleter]';\n  var detect$1 = function detect$1(elm) {\n    return closest$1(elm, autocompleteSelector);\n  };\n  var findIn = function findIn(elm) {\n    return descendant(elm, autocompleteSelector);\n  };\n  var setup$e = function setup$e(api, editor) {\n    var redirectKeyToItem = function redirectKeyToItem(item, e) {\n      emitWith(item, keydown(), {\n        raw: e\n      });\n    };\n    var getItem = function getItem() {\n      return api.getMenu().bind(Highlighting.getHighlighted);\n    };\n    editor.on('keydown', function (e) {\n      var keyCode = e.which;\n      if (!api.isActive()) {\n        return;\n      }\n      if (api.isMenuOpen()) {\n        if (keyCode === 13) {\n          getItem().each(emitExecute);\n          e.preventDefault();\n        } else if (keyCode === 40) {\n          getItem().fold(function () {\n            api.getMenu().each(Highlighting.highlightFirst);\n          }, function (item) {\n            redirectKeyToItem(item, e);\n          });\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        } else if (keyCode === 37 || keyCode === 38 || keyCode === 39) {\n          getItem().each(function (item) {\n            redirectKeyToItem(item, e);\n            e.preventDefault();\n            e.stopImmediatePropagation();\n          });\n        }\n      } else {\n        if (keyCode === 13 || keyCode === 38 || keyCode === 40) {\n          api.cancelIfNecessary();\n        }\n      }\n    });\n    editor.on('NodeChange', function (e) {\n      if (api.isActive() && !api.isProcessingAction() && detect$1(SugarElement.fromDom(e.element)).isNone()) {\n        api.cancelIfNecessary();\n      }\n    });\n  };\n  var AutocompleterEditorEvents = {\n    setup: setup$e\n  };\n  var ItemResponse;\n  (function (ItemResponse) {\n    ItemResponse[ItemResponse['CLOSE_ON_EXECUTE'] = 0] = 'CLOSE_ON_EXECUTE';\n    ItemResponse[ItemResponse['BUBBLE_TO_SANDBOX'] = 1] = 'BUBBLE_TO_SANDBOX';\n  })(ItemResponse || (ItemResponse = {}));\n  var ItemResponse$1 = ItemResponse;\n  var navClass = 'tox-menu-nav__js';\n  var selectableClass = 'tox-collection__item';\n  var colorClass = 'tox-swatch';\n  var presetClasses = {\n    normal: navClass,\n    color: colorClass\n  };\n  var tickedClass = 'tox-collection__item--enabled';\n  var groupHeadingClass = 'tox-collection__group-heading';\n  var iconClass = 'tox-collection__item-icon';\n  var textClass = 'tox-collection__item-label';\n  var accessoryClass = 'tox-collection__item-accessory';\n  var caretClass = 'tox-collection__item-caret';\n  var checkmarkClass = 'tox-collection__item-checkmark';\n  var activeClass = 'tox-collection__item--active';\n  var containerClass = 'tox-collection__item-container';\n  var containerColumnClass = 'tox-collection__item-container--column';\n  var containerRowClass = 'tox-collection__item-container--row';\n  var containerAlignRightClass = 'tox-collection__item-container--align-right';\n  var containerAlignLeftClass = 'tox-collection__item-container--align-left';\n  var containerValignTopClass = 'tox-collection__item-container--valign-top';\n  var containerValignMiddleClass = 'tox-collection__item-container--valign-middle';\n  var containerValignBottomClass = 'tox-collection__item-container--valign-bottom';\n  var classForPreset = function classForPreset(presets) {\n    return get$g(presetClasses, presets).getOr(navClass);\n  };\n  var forMenu = function forMenu(presets) {\n    if (presets === 'color') {\n      return 'tox-swatches';\n    } else {\n      return 'tox-menu';\n    }\n  };\n  var classes = function classes(presets) {\n    return {\n      backgroundMenu: 'tox-background-menu',\n      selectedMenu: 'tox-selected-menu',\n      selectedItem: 'tox-collection__item--active',\n      hasIcons: 'tox-menu--has-icons',\n      menu: forMenu(presets),\n      tieredMenu: 'tox-tiered-menu'\n    };\n  };\n  var markers = function markers(presets) {\n    var menuClasses = classes(presets);\n    return {\n      backgroundMenu: menuClasses.backgroundMenu,\n      selectedMenu: menuClasses.selectedMenu,\n      menu: menuClasses.menu,\n      selectedItem: menuClasses.selectedItem,\n      item: classForPreset(presets)\n    };\n  };\n  var dom$1 = function dom$1(hasIcons, columns, presets) {\n    var menuClasses = classes(presets);\n    return {\n      tag: 'div',\n      classes: flatten([[menuClasses.menu, \"tox-menu-\".concat(columns, \"-column\")], hasIcons ? [menuClasses.hasIcons] : []])\n    };\n  };\n  var components = [Menu.parts.items({})];\n  var part = function part(hasIcons, columns, presets) {\n    var menuClasses = classes(presets);\n    var d = {\n      tag: 'div',\n      classes: flatten([[menuClasses.tieredMenu]])\n    };\n    return {\n      dom: d,\n      markers: markers(presets)\n    };\n  };\n  var schema$l = constant$1([option$3('data'), defaulted('inputAttributes', {}), defaulted('inputStyles', {}), defaulted('tag', 'input'), defaulted('inputClasses', []), onHandler('onSetValue'), defaulted('styles', {}), defaulted('eventOrder', {}), field('inputBehaviours', [Representing, Focusing]), defaulted('selectOnFocus', true)]);\n  var focusBehaviours = function focusBehaviours(detail) {\n    return derive$1([Focusing.config({\n      onFocus: !detail.selectOnFocus ? noop : function (component) {\n        var input = component.element;\n        var value = get$6(input);\n        input.dom.setSelectionRange(0, value.length);\n      }\n    })]);\n  };\n  var behaviours = function behaviours(detail) {\n    return _objectSpread({}, focusBehaviours(detail), augment(detail.inputBehaviours, [Representing.config({\n      store: _objectSpread({\n        mode: 'manual'\n      }, detail.data.map(function (data) {\n        return {\n          initialValue: data\n        };\n      }).getOr({}), {\n        getValue: function getValue(input) {\n          return get$6(input.element);\n        },\n        setValue: function setValue(input, data) {\n          var current = get$6(input.element);\n          if (current !== data) {\n            set$5(input.element, data);\n          }\n        }\n      }),\n      onSetValue: detail.onSetValue\n    })]));\n  };\n  var dom = function dom(detail) {\n    return {\n      tag: detail.tag,\n      attributes: _objectSpread({\n        type: 'text'\n      }, detail.inputAttributes),\n      styles: detail.inputStyles,\n      classes: detail.inputClasses\n    };\n  };\n  var factory$l = function factory$l(detail, _spec) {\n    return {\n      uid: detail.uid,\n      dom: dom(detail),\n      components: [],\n      behaviours: behaviours(detail),\n      eventOrder: detail.eventOrder\n    };\n  };\n  var Input = single({\n    name: 'Input',\n    configFields: schema$l(),\n    factory: factory$l\n  });\n  var refetchTriggerEvent = generate$6('refetch-trigger-event');\n  var redirectMenuItemInteractionEvent = generate$6('redirect-menu-item-interaction');\n  var menuSearcherClass = 'tox-menu__searcher';\n  var findWithinSandbox = function findWithinSandbox(sandboxComp) {\n    return descendant(sandboxComp.element, \".\".concat(menuSearcherClass)).bind(function (inputElem) {\n      return sandboxComp.getSystem().getByDom(inputElem).toOptional();\n    });\n  };\n  var findWithinMenu = findWithinSandbox;\n  var restoreState = function restoreState(inputComp, searcherState) {\n    Representing.setValue(inputComp, searcherState.fetchPattern);\n    inputComp.element.dom.selectionStart = searcherState.selectionStart;\n    inputComp.element.dom.selectionEnd = searcherState.selectionEnd;\n  };\n  var saveState = function saveState(inputComp) {\n    var fetchPattern = Representing.getValue(inputComp);\n    var selectionStart = inputComp.element.dom.selectionStart;\n    var selectionEnd = inputComp.element.dom.selectionEnd;\n    return {\n      fetchPattern: fetchPattern,\n      selectionStart: selectionStart,\n      selectionEnd: selectionEnd\n    };\n  };\n  var setActiveDescendant = function setActiveDescendant(inputComp, active) {\n    getOpt(active.element, 'id').each(function (id) {\n      return set$9(inputComp.element, 'aria-activedescendant', id);\n    });\n  };\n  var renderMenuSearcher = function renderMenuSearcher(spec) {\n    var handleByBrowser = function handleByBrowser(comp, se) {\n      se.cut();\n      return Optional.none();\n    };\n    var handleByHighlightedItem = function handleByHighlightedItem(comp, se) {\n      var eventData = {\n        interactionEvent: se.event,\n        eventType: se.event.raw.type\n      };\n      emitWith(comp, redirectMenuItemInteractionEvent, eventData);\n      return Optional.some(true);\n    };\n    var customSearcherEventsName = 'searcher-events';\n    return {\n      dom: {\n        tag: 'div',\n        classes: [selectableClass]\n      },\n      components: [Input.sketch({\n        inputClasses: [menuSearcherClass, 'tox-textfield'],\n        inputAttributes: _objectSpread({}, spec.placeholder.map(function (placeholder) {\n          return {\n            placeholder: spec.i18n(placeholder)\n          };\n        }).getOr({}), {\n          'type': 'search',\n          'aria-autocomplete': 'list'\n        }),\n        inputBehaviours: derive$1([config(customSearcherEventsName, [run$1(input(), function (inputComp) {\n          emit(inputComp, refetchTriggerEvent);\n        }), run$1(keydown(), function (inputComp, se) {\n          if (se.event.raw.key === 'Escape') {\n            se.stop();\n          }\n        })]), Keying.config({\n          mode: 'special',\n          onLeft: handleByBrowser,\n          onRight: handleByBrowser,\n          onSpace: handleByBrowser,\n          onEnter: handleByHighlightedItem,\n          onEscape: handleByHighlightedItem,\n          onUp: handleByHighlightedItem,\n          onDown: handleByHighlightedItem\n        })]),\n        eventOrder: {\n          keydown: [customSearcherEventsName, Keying.name()]\n        }\n      })]\n    };\n  };\n  var searchResultsClass = 'tox-collection--results__js';\n  var augmentWithAria = function augmentWithAria(item) {\n    var _a;\n    if (item.dom) {\n      return _objectSpread({}, item, {\n        dom: _objectSpread({}, item.dom, {\n          attributes: _objectSpread({}, (_a = item.dom.attributes) !== null && _a !== void 0 ? _a : {}, {\n            'id': generate$6('aria-item-search-result-id'),\n            'aria-selected': 'false'\n          })\n        })\n      });\n    } else {\n      return item;\n    }\n  };\n  var chunk = function chunk(rowDom, numColumns) {\n    return function (items) {\n      var chunks = chunk$1(items, numColumns);\n      return map$2(chunks, function (c) {\n        return {\n          dom: rowDom,\n          components: c\n        };\n      });\n    };\n  };\n  var forSwatch = function forSwatch(columns) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-menu', 'tox-swatches-menu']\n      },\n      components: [{\n        dom: {\n          tag: 'div',\n          classes: ['tox-swatches']\n        },\n        components: [Menu.parts.items({\n          preprocess: columns !== 'auto' ? chunk({\n            tag: 'div',\n            classes: ['tox-swatches__row']\n          }, columns) : identity\n        })]\n      }]\n    };\n  };\n  var forToolbar = function forToolbar(columns) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-menu', 'tox-collection', 'tox-collection--toolbar', 'tox-collection--toolbar-lg']\n      },\n      components: [Menu.parts.items({\n        preprocess: chunk({\n          tag: 'div',\n          classes: ['tox-collection__group']\n        }, columns)\n      })]\n    };\n  };\n  var preprocessCollection = function preprocessCollection(items, isSeparator) {\n    var allSplits = [];\n    var currentSplit = [];\n    each$1(items, function (item, i) {\n      if (isSeparator(item, i)) {\n        if (currentSplit.length > 0) {\n          allSplits.push(currentSplit);\n        }\n        currentSplit = [];\n        if (has$2(item.dom, 'innerHtml') || item.components && item.components.length > 0) {\n          currentSplit.push(item);\n        }\n      } else {\n        currentSplit.push(item);\n      }\n    });\n    if (currentSplit.length > 0) {\n      allSplits.push(currentSplit);\n    }\n    return map$2(allSplits, function (s) {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-collection__group']\n        },\n        components: s\n      };\n    });\n  };\n  var insertItemsPlaceholder = function insertItemsPlaceholder(columns, initItems, onItem) {\n    return Menu.parts.items({\n      preprocess: function preprocess(rawItems) {\n        var enrichedItems = map$2(rawItems, onItem);\n        if (columns !== 'auto' && columns > 1) {\n          return chunk({\n            tag: 'div',\n            classes: ['tox-collection__group']\n          }, columns)(enrichedItems);\n        } else {\n          return preprocessCollection(enrichedItems, function (_item, i) {\n            return initItems[i].type === 'separator';\n          });\n        }\n      }\n    });\n  };\n  var forCollection = function forCollection(columns, initItems) {\n    var _hasIcons = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-menu', 'tox-collection'].concat(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid'])\n      },\n      components: [insertItemsPlaceholder(columns, initItems, identity)]\n    };\n  };\n  var forCollectionWithSearchResults = function forCollectionWithSearchResults(columns, initItems) {\n    var _hasIcons = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var ariaControlsSearchResults = generate$6('aria-controls-search-results');\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-menu', 'tox-collection', searchResultsClass].concat(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid']),\n        attributes: {\n          id: ariaControlsSearchResults\n        }\n      },\n      components: [insertItemsPlaceholder(columns, initItems, augmentWithAria)]\n    };\n  };\n  var forCollectionWithSearchField = function forCollectionWithSearchField(columns, initItems, searchField) {\n    var ariaControlsSearchResults = generate$6('aria-controls-search-results');\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-menu', 'tox-collection'].concat(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid'])\n      },\n      components: [renderMenuSearcher({\n        i18n: global$8.translate,\n        placeholder: searchField.placeholder\n      }), {\n        dom: {\n          tag: 'div',\n          classes: [].concat(_toConsumableArray(columns === 1 ? ['tox-collection--list'] : ['tox-collection--grid']), [searchResultsClass]),\n          attributes: {\n            id: ariaControlsSearchResults\n          }\n        },\n        components: [insertItemsPlaceholder(columns, initItems, augmentWithAria)]\n      }]\n    };\n  };\n  var forHorizontalCollection = function forHorizontalCollection(initItems) {\n    var _hasIcons = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-collection', 'tox-collection--horizontal']\n      },\n      components: [Menu.parts.items({\n        preprocess: function preprocess(items) {\n          return preprocessCollection(items, function (_item, i) {\n            return initItems[i].type === 'separator';\n          });\n        }\n      })]\n    };\n  };\n  var menuHasIcons = function menuHasIcons(xs) {\n    return exists(xs, function (item) {\n      return 'icon' in item && item.icon !== undefined;\n    });\n  };\n  var handleError = function handleError(error) {\n    console.error(formatError(error));\n    console.log(error);\n    return Optional.none();\n  };\n  var createHorizontalPartialMenuWithAlloyItems = function createHorizontalPartialMenuWithAlloyItems(value, _hasIcons, items, _columns, _menuLayout) {\n    var structure = forHorizontalCollection(items);\n    return {\n      value: value,\n      dom: structure.dom,\n      components: structure.components,\n      items: items\n    };\n  };\n  var createPartialMenuWithAlloyItems = function createPartialMenuWithAlloyItems(value, hasIcons, items, columns, menuLayout) {\n    var getNormalStructure = function getNormalStructure() {\n      if (menuLayout.menuType !== 'searchable') {\n        return forCollection(columns, items);\n      } else {\n        return menuLayout.searchMode.searchMode === 'search-with-field' ? forCollectionWithSearchField(columns, items, menuLayout.searchMode) : forCollectionWithSearchResults(columns, items);\n      }\n    };\n    if (menuLayout.menuType === 'color') {\n      var structure = forSwatch(columns);\n      return {\n        value: value,\n        dom: structure.dom,\n        components: structure.components,\n        items: items\n      };\n    } else if (menuLayout.menuType === 'normal' && columns === 'auto') {\n      var _structure = forCollection(columns, items);\n      return {\n        value: value,\n        dom: _structure.dom,\n        components: _structure.components,\n        items: items\n      };\n    } else if (menuLayout.menuType === 'normal' || menuLayout.menuType === 'searchable') {\n      var _structure2 = getNormalStructure();\n      return {\n        value: value,\n        dom: _structure2.dom,\n        components: _structure2.components,\n        items: items\n      };\n    } else if (menuLayout.menuType === 'listpreview' && columns !== 'auto') {\n      var _structure3 = forToolbar(columns);\n      return {\n        value: value,\n        dom: _structure3.dom,\n        components: _structure3.components,\n        items: items\n      };\n    } else {\n      return {\n        value: value,\n        dom: dom$1(hasIcons, columns, menuLayout.menuType),\n        components: components,\n        items: items\n      };\n    }\n  };\n  var type = requiredString('type');\n  var name$1 = requiredString('name');\n  var label = requiredString('label');\n  var text = requiredString('text');\n  var title$5 = requiredString('title');\n  var icon = requiredString('icon');\n  var value$1 = requiredString('value');\n  var fetch$1 = requiredFunction('fetch');\n  var getSubmenuItems = requiredFunction('getSubmenuItems');\n  var onAction = requiredFunction('onAction');\n  var onItemAction = requiredFunction('onItemAction');\n  var onSetup = defaultedFunction('onSetup', function () {\n    return noop;\n  });\n  var optionalName = optionString('name');\n  var optionalText = optionString('text');\n  var optionalIcon = optionString('icon');\n  var optionalTooltip = optionString('tooltip');\n  var optionalLabel = optionString('label');\n  var optionalShortcut = optionString('shortcut');\n  var optionalSelect = optionFunction('select');\n  var active = defaultedBoolean('active', false);\n  var borderless = defaultedBoolean('borderless', false);\n  var enabled = defaultedBoolean('enabled', true);\n  var primary = defaultedBoolean('primary', false);\n  var defaultedColumns = function defaultedColumns(num) {\n    return defaulted('columns', num);\n  };\n  var defaultedMeta = defaulted('meta', {});\n  var defaultedOnAction = defaultedFunction('onAction', noop);\n  var defaultedType = function defaultedType(type) {\n    return defaultedString('type', type);\n  };\n  var generatedName = function generatedName(namePrefix) {\n    return field$1('name', 'name', defaultedThunk(function () {\n      return generate$6(\"\".concat(namePrefix, \"-name\"));\n    }), string);\n  };\n  var generatedValue = function generatedValue(valuePrefix) {\n    return field$1('value', 'value', defaultedThunk(function () {\n      return generate$6(\"\".concat(valuePrefix, \"-value\"));\n    }), anyValue());\n  };\n  var separatorMenuItemSchema = objOf([type, optionalText]);\n  var createSeparatorMenuItem = function createSeparatorMenuItem(spec) {\n    return asRaw('separatormenuitem', separatorMenuItemSchema, spec);\n  };\n  var autocompleterItemSchema = objOf([defaultedType('autocompleteitem'), active, enabled, defaultedMeta, value$1, optionalText, optionalIcon]);\n  var createSeparatorItem = function createSeparatorItem(spec) {\n    return asRaw('Autocompleter.Separator', separatorMenuItemSchema, spec);\n  };\n  var createAutocompleterItem = function createAutocompleterItem(spec) {\n    return asRaw('Autocompleter.Item', autocompleterItemSchema, spec);\n  };\n  var baseToolbarButtonFields = [enabled, optionalTooltip, optionalIcon, optionalText, onSetup];\n  var toolbarButtonSchema = objOf([type, onAction].concat(baseToolbarButtonFields));\n  var createToolbarButton = function createToolbarButton(spec) {\n    return asRaw('toolbarbutton', toolbarButtonSchema, spec);\n  };\n  var baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n  var toggleButtonSchema = objOf(baseToolbarToggleButtonFields.concat([type, onAction]));\n  var createToggleButton = function createToggleButton(spec) {\n    return asRaw('ToggleButton', toggleButtonSchema, spec);\n  };\n  var contextBarFields = [defaultedFunction('predicate', never), defaultedStringEnum('scope', 'node', ['node', 'editor']), defaultedStringEnum('position', 'selection', ['node', 'selection', 'line'])];\n  var contextButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton'), primary, onAction, customField('original', identity)]);\n  var contextToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformbutton'), primary, onAction, customField('original', identity)]);\n  var launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n  var launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n  var toggleOrNormal = choose$1('type', {\n    contextformbutton: contextButtonFields,\n    contextformtogglebutton: contextToggleButtonFields\n  });\n  var contextFormSchema = objOf([defaultedType('contextform'), defaultedFunction('initValue', constant$1('')), optionalLabel, requiredArrayOf('commands', toggleOrNormal), optionOf('launch', choose$1('type', {\n    contextformbutton: launchButtonFields,\n    contextformtogglebutton: launchToggleButtonFields\n  }))].concat(contextBarFields));\n  var createContextForm = function createContextForm(spec) {\n    return asRaw('ContextForm', contextFormSchema, spec);\n  };\n  var contextToolbarSchema = objOf([defaultedType('contexttoolbar'), requiredString('items')].concat(contextBarFields));\n  var createContextToolbar = function createContextToolbar(spec) {\n    return asRaw('ContextToolbar', contextToolbarSchema, spec);\n  };\n  var cardImageFields = [type, requiredString('src'), optionString('alt'), defaultedArrayOf('classes', [], string)];\n  var cardImageSchema = objOf(cardImageFields);\n  var cardTextFields = [type, text, optionalName, defaultedArrayOf('classes', ['tox-collection__item-label'], string)];\n  var cardTextSchema = objOf(cardTextFields);\n  var itemSchema$1 = valueThunk(function () {\n    return choose$2('type', {\n      cardimage: cardImageSchema,\n      cardtext: cardTextSchema,\n      cardcontainer: cardContainerSchema\n    });\n  });\n  var cardContainerSchema = objOf([type, defaultedString('direction', 'horizontal'), defaultedString('align', 'left'), defaultedString('valign', 'middle'), requiredArrayOf('items', itemSchema$1)]);\n  var commonMenuItemFields = [enabled, optionalText, optionalShortcut, generatedValue('menuitem'), defaultedMeta];\n  var cardMenuItemSchema = objOf([type, optionalLabel, requiredArrayOf('items', itemSchema$1), onSetup, defaultedOnAction].concat(commonMenuItemFields));\n  var createCardMenuItem = function createCardMenuItem(spec) {\n    return asRaw('cardmenuitem', cardMenuItemSchema, spec);\n  };\n  var choiceMenuItemSchema = objOf([type, active, optionalIcon].concat(commonMenuItemFields));\n  var createChoiceMenuItem = function createChoiceMenuItem(spec) {\n    return asRaw('choicemenuitem', choiceMenuItemSchema, spec);\n  };\n  var baseFields = [type, requiredString('fancytype'), defaultedOnAction];\n  var insertTableFields = [defaulted('initData', {})].concat(baseFields);\n  var colorSwatchFields = [optionFunction('select'), defaultedObjOf('initData', {}, [defaultedBoolean('allowCustomColors', true), defaultedString('storageKey', 'default'), optionArrayOf('colors', anyValue())])].concat(baseFields);\n  var fancyMenuItemSchema = choose$1('fancytype', {\n    inserttable: insertTableFields,\n    colorswatch: colorSwatchFields\n  });\n  var createFancyMenuItem = function createFancyMenuItem(spec) {\n    return asRaw('fancymenuitem', fancyMenuItemSchema, spec);\n  };\n  var menuItemSchema = objOf([type, onSetup, defaultedOnAction, optionalIcon].concat(commonMenuItemFields));\n  var createMenuItem = function createMenuItem(spec) {\n    return asRaw('menuitem', menuItemSchema, spec);\n  };\n  var nestedMenuItemSchema = objOf([type, getSubmenuItems, onSetup, optionalIcon].concat(commonMenuItemFields));\n  var createNestedMenuItem = function createNestedMenuItem(spec) {\n    return asRaw('nestedmenuitem', nestedMenuItemSchema, spec);\n  };\n  var toggleMenuItemSchema = objOf([type, optionalIcon, active, onSetup, onAction].concat(commonMenuItemFields));\n  var createToggleMenuItem = function createToggleMenuItem(spec) {\n    return asRaw('togglemenuitem', toggleMenuItemSchema, spec);\n  };\n  var detectSize = function detectSize(comp, margin, selectorClass) {\n    var descendants$1 = descendants(comp.element, '.' + selectorClass);\n    if (descendants$1.length > 0) {\n      var columnLength = findIndex$1(descendants$1, function (c) {\n        var thisTop = c.dom.getBoundingClientRect().top;\n        var cTop = descendants$1[0].dom.getBoundingClientRect().top;\n        return Math.abs(thisTop - cTop) > margin;\n      }).getOr(descendants$1.length);\n      return Optional.some({\n        numColumns: columnLength,\n        numRows: Math.ceil(descendants$1.length / columnLength)\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n  var namedEvents = function namedEvents(name, handlers) {\n    return derive$1([config(name, handlers)]);\n  };\n  var unnamedEvents = function unnamedEvents(handlers) {\n    return namedEvents(generate$6('unnamed-events'), handlers);\n  };\n  var SimpleBehaviours = {\n    namedEvents: namedEvents,\n    unnamedEvents: unnamedEvents\n  };\n  var ExclusivityChannel = generate$6('tooltip.exclusive');\n  var ShowTooltipEvent = generate$6('tooltip.show');\n  var HideTooltipEvent = generate$6('tooltip.hide');\n  var hideAllExclusive = function hideAllExclusive(component, _tConfig, _tState) {\n    component.getSystem().broadcastOn([ExclusivityChannel], {});\n  };\n  var setComponents = function setComponents(component, tConfig, tState, specs) {\n    tState.getTooltip().each(function (tooltip) {\n      if (tooltip.getSystem().isConnected()) {\n        Replacing.set(tooltip, specs);\n      }\n    });\n  };\n  var TooltippingApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    hideAllExclusive: hideAllExclusive,\n    setComponents: setComponents\n  });\n  var events$9 = function events$9(tooltipConfig, state) {\n    var hide = function hide(comp) {\n      state.getTooltip().each(function (p) {\n        detach(p);\n        tooltipConfig.onHide(comp, p);\n        state.clearTooltip();\n      });\n      state.clearTimer();\n    };\n    var show = function show(comp) {\n      if (!state.isShowing()) {\n        hideAllExclusive(comp);\n        var sink = tooltipConfig.lazySink(comp).getOrDie();\n        var popup = comp.getSystem().build({\n          dom: tooltipConfig.tooltipDom,\n          components: tooltipConfig.tooltipComponents,\n          events: derive$2(tooltipConfig.mode === 'normal' ? [run$1(mouseover(), function (_) {\n            emit(comp, ShowTooltipEvent);\n          }), run$1(mouseout(), function (_) {\n            emit(comp, HideTooltipEvent);\n          })] : []),\n          behaviours: derive$1([Replacing.config({})])\n        });\n        state.setTooltip(popup);\n        attach(sink, popup);\n        tooltipConfig.onShow(comp, popup);\n        Positioning.position(sink, popup, {\n          anchor: tooltipConfig.anchor(comp)\n        });\n      }\n    };\n    return derive$2(flatten([[run$1(ShowTooltipEvent, function (comp) {\n      state.resetTimer(function () {\n        show(comp);\n      }, tooltipConfig.delay);\n    }), run$1(HideTooltipEvent, function (comp) {\n      state.resetTimer(function () {\n        hide(comp);\n      }, tooltipConfig.delay);\n    }), run$1(receive(), function (comp, message) {\n      var receivingData = message;\n      if (!receivingData.universal) {\n        if (contains$2(receivingData.channels, ExclusivityChannel)) {\n          hide(comp);\n        }\n      }\n    }), runOnDetached(function (comp) {\n      hide(comp);\n    })], tooltipConfig.mode === 'normal' ? [run$1(focusin(), function (comp) {\n      emit(comp, ShowTooltipEvent);\n    }), run$1(postBlur(), function (comp) {\n      emit(comp, HideTooltipEvent);\n    }), run$1(mouseover(), function (comp) {\n      emit(comp, ShowTooltipEvent);\n    }), run$1(mouseout(), function (comp) {\n      emit(comp, HideTooltipEvent);\n    })] : [run$1(highlight$1(), function (comp, _se) {\n      emit(comp, ShowTooltipEvent);\n    }), run$1(dehighlight$1(), function (comp) {\n      emit(comp, HideTooltipEvent);\n    })]]));\n  };\n  var ActiveTooltipping = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    events: events$9\n  });\n  var TooltippingSchema = [required$1('lazySink'), required$1('tooltipDom'), defaulted('exclusive', true), defaulted('tooltipComponents', []), defaulted('delay', 300), defaultedStringEnum('mode', 'normal', ['normal', 'follow-highlight']), defaulted('anchor', function (comp) {\n    return {\n      type: 'hotspot',\n      hotspot: comp,\n      layouts: {\n        onLtr: constant$1([south$2, north$2, southeast$2, northeast$2, southwest$2, northwest$2]),\n        onRtl: constant$1([south$2, north$2, southeast$2, northeast$2, southwest$2, northwest$2])\n      }\n    };\n  }), onHandler('onHide'), onHandler('onShow')];\n  var init$b = function init$b() {\n    var timer = value$2();\n    var popup = value$2();\n    var clearTimer = function clearTimer() {\n      timer.on(clearTimeout);\n    };\n    var resetTimer = function resetTimer(f, delay) {\n      clearTimer();\n      timer.set(setTimeout(f, delay));\n    };\n    var readState = constant$1('not-implemented');\n    return nu$8({\n      getTooltip: popup.get,\n      isShowing: popup.isSet,\n      setTooltip: popup.set,\n      clearTooltip: popup.clear,\n      clearTimer: clearTimer,\n      resetTimer: resetTimer,\n      readState: readState\n    });\n  };\n  var TooltippingState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    init: init$b\n  });\n  var Tooltipping = create$4({\n    fields: TooltippingSchema,\n    name: 'tooltipping',\n    active: ActiveTooltipping,\n    state: TooltippingState,\n    apis: TooltippingApis\n  });\n  var escape = function escape(text) {\n    return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  };\n  var ReadOnlyChannel = 'silver.readonly';\n  var ReadOnlyDataSchema = objOf([requiredBoolean('readonly')]);\n  var broadcastReadonly = function broadcastReadonly(uiRefs, readonly) {\n    var outerContainer = uiRefs.mainUi.outerContainer;\n    var target = outerContainer.element;\n    var motherships = [uiRefs.mainUi.mothership].concat(_toConsumableArray(uiRefs.uiMotherships));\n    if (readonly) {\n      each$1(motherships, function (m) {\n        m.broadcastOn([dismissPopups()], {\n          target: target\n        });\n      });\n    }\n    each$1(motherships, function (m) {\n      m.broadcastOn([ReadOnlyChannel], {\n        readonly: readonly\n      });\n    });\n  };\n  var setupReadonlyModeSwitch = function setupReadonlyModeSwitch(editor, uiRefs) {\n    editor.on('init', function () {\n      if (editor.mode.isReadOnly()) {\n        broadcastReadonly(uiRefs, true);\n      }\n    });\n    editor.on('SwitchMode', function () {\n      return broadcastReadonly(uiRefs, editor.mode.isReadOnly());\n    });\n    if (isReadOnly(editor)) {\n      editor.mode.set('readonly');\n    }\n  };\n  var receivingConfig = function receivingConfig() {\n    return Receiving.config({\n      channels: _defineProperty({}, ReadOnlyChannel, {\n        schema: ReadOnlyDataSchema,\n        onReceive: function onReceive(comp, data) {\n          Disabling.set(comp, data.readonly);\n        }\n      })\n    });\n  };\n  var item = function item(disabled) {\n    return Disabling.config({\n      disabled: disabled,\n      disableClass: 'tox-collection__item--state-disabled'\n    });\n  };\n  var button = function button(disabled) {\n    return Disabling.config({\n      disabled: disabled\n    });\n  };\n  var splitButton = function splitButton(disabled) {\n    return Disabling.config({\n      disabled: disabled,\n      disableClass: 'tox-tbtn--disabled'\n    });\n  };\n  var toolbarButton = function toolbarButton(disabled) {\n    return Disabling.config({\n      disabled: disabled,\n      disableClass: 'tox-tbtn--disabled',\n      useNative: false\n    });\n  };\n  var DisablingConfigs = {\n    item: item,\n    button: button,\n    splitButton: splitButton,\n    toolbarButton: toolbarButton\n  };\n  var runWithApi = function runWithApi(info, comp) {\n    var api = info.getApi(comp);\n    return function (f) {\n      f(api);\n    };\n  };\n  var onControlAttached = function onControlAttached(info, editorOffCell) {\n    return runOnAttached(function (comp) {\n      var run = runWithApi(info, comp);\n      run(function (api) {\n        var onDestroy = info.onSetup(api);\n        if (isFunction(onDestroy)) {\n          editorOffCell.set(onDestroy);\n        }\n      });\n    });\n  };\n  var onControlDetached = function onControlDetached(getApi, editorOffCell) {\n    return runOnDetached(function (comp) {\n      return runWithApi(getApi, comp)(editorOffCell.get());\n    });\n  };\n  var onMenuItemExecute = function onMenuItemExecute(info, itemResponse) {\n    return runOnExecute$1(function (comp, simulatedEvent) {\n      runWithApi(info, comp)(info.onAction);\n      if (!info.triggersSubmenu && itemResponse === ItemResponse$1.CLOSE_ON_EXECUTE) {\n        if (comp.getSystem().isConnected()) {\n          emit(comp, sandboxClose());\n        }\n        simulatedEvent.stop();\n      }\n    });\n  };\n  var menuItemEventOrder = _defineProperty({}, execute$5(), ['disabling', 'alloy.base.behaviour', 'toggling', 'item-events']);\n  var componentRenderPipeline = cat;\n  var renderCommonItem = function renderCommonItem(spec, structure, itemResponse, providersBackstage) {\n    var editorOffCell = Cell(noop);\n    return {\n      type: 'item',\n      dom: structure.dom,\n      components: componentRenderPipeline(structure.optComponents),\n      data: spec.data,\n      eventOrder: menuItemEventOrder,\n      hasSubmenu: spec.triggersSubmenu,\n      itemBehaviours: derive$1([config('item-events', [onMenuItemExecute(spec, itemResponse), onControlAttached(spec, editorOffCell), onControlDetached(spec, editorOffCell)]), DisablingConfigs.item(function () {\n        return !spec.enabled || providersBackstage.isDisabled();\n      }), receivingConfig(), Replacing.config({})].concat(spec.itemBehaviours))\n    };\n  };\n  var buildData = function buildData(source) {\n    return {\n      value: source.value,\n      meta: _objectSpread({\n        text: source.text.getOr('')\n      }, source.meta)\n    };\n  };\n  var convertText = function convertText(source) {\n    var isMac = global$5.os.isMacOS() || global$5.os.isiOS();\n    var mac = {\n      alt: \"\\u2325\",\n      ctrl: \"\\u2303\",\n      shift: \"\\u21E7\",\n      meta: \"\\u2318\",\n      access: \"\\u2303\\u2325\"\n    };\n    var other = {\n      meta: 'Ctrl',\n      access: 'Shift+Alt'\n    };\n    var replace = isMac ? mac : other;\n    var shortcut = source.split('+');\n    var updated = map$2(shortcut, function (segment) {\n      var search = segment.toLowerCase().trim();\n      return has$2(replace, search) ? replace[search] : segment;\n    });\n    return isMac ? updated.join('') : updated.join('+');\n  };\n  var renderIcon$2 = function renderIcon$2(name, icons) {\n    var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [iconClass];\n    return render$3(name, {\n      tag: 'div',\n      classes: classes\n    }, icons);\n  };\n  var renderText = function renderText(text) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: [textClass]\n      },\n      components: [text$2(global$8.translate(text))]\n    };\n  };\n  var renderHtml = function renderHtml(html, classes) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: classes,\n        innerHtml: html\n      }\n    };\n  };\n  var renderStyledText = function renderStyledText(style, text) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: [textClass]\n      },\n      components: [{\n        dom: {\n          tag: style.tag,\n          styles: style.styles\n        },\n        components: [text$2(global$8.translate(text))]\n      }]\n    };\n  };\n  var renderShortcut = function renderShortcut(shortcut) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: [accessoryClass]\n      },\n      components: [text$2(convertText(shortcut))]\n    };\n  };\n  var renderCheckmark = function renderCheckmark(icons) {\n    return renderIcon$2('checkmark', icons, [checkmarkClass]);\n  };\n  var renderSubmenuCaret = function renderSubmenuCaret(icons) {\n    return renderIcon$2('chevron-right', icons, [caretClass]);\n  };\n  var renderDownwardsCaret = function renderDownwardsCaret(icons) {\n    return renderIcon$2('chevron-down', icons, [caretClass]);\n  };\n  var renderContainer = function renderContainer(container, components) {\n    var directionClass = container.direction === 'vertical' ? containerColumnClass : containerRowClass;\n    var alignClass = container.align === 'left' ? containerAlignLeftClass : containerAlignRightClass;\n    var getValignClass = function getValignClass() {\n      switch (container.valign) {\n        case 'top':\n          return containerValignTopClass;\n        case 'middle':\n          return containerValignMiddleClass;\n        case 'bottom':\n          return containerValignBottomClass;\n      }\n    };\n    return {\n      dom: {\n        tag: 'div',\n        classes: [containerClass, directionClass, alignClass, getValignClass()]\n      },\n      components: components\n    };\n  };\n  var renderImage = function renderImage(src, classes, alt) {\n    return {\n      dom: {\n        tag: 'img',\n        classes: classes,\n        attributes: {\n          src: src,\n          alt: alt.getOr('')\n        }\n      }\n    };\n  };\n  var renderColorStructure = function renderColorStructure(item, providerBackstage, fallbackIcon) {\n    var colorPickerCommand = 'custom';\n    var removeColorCommand = 'remove';\n    var itemText = item.ariaLabel;\n    var itemValue = item.value;\n    var iconSvg = item.iconContent.map(function (name) {\n      return getOr(name, providerBackstage.icons, fallbackIcon);\n    });\n    var getDom = function getDom() {\n      var common = colorClass;\n      var icon = iconSvg.getOr('');\n      var attributes = itemText.map(function (text) {\n        return {\n          title: providerBackstage.translate(text)\n        };\n      }).getOr({});\n      var baseDom = {\n        tag: 'div',\n        attributes: attributes,\n        classes: [common]\n      };\n      if (itemValue === colorPickerCommand) {\n        return _objectSpread({}, baseDom, {\n          tag: 'button',\n          classes: [].concat(_toConsumableArray(baseDom.classes), ['tox-swatches__picker-btn']),\n          innerHtml: icon\n        });\n      } else if (itemValue === removeColorCommand) {\n        return _objectSpread({}, baseDom, {\n          classes: [].concat(_toConsumableArray(baseDom.classes), ['tox-swatch--remove']),\n          innerHtml: icon\n        });\n      } else if (isNonNullable(itemValue)) {\n        return _objectSpread({}, baseDom, {\n          attributes: _objectSpread({}, baseDom.attributes, {\n            'data-mce-color': itemValue\n          }),\n          styles: {\n            'background-color': itemValue\n          },\n          innerHtml: icon\n        });\n      } else {\n        return baseDom;\n      }\n    };\n    return {\n      dom: getDom(),\n      optComponents: []\n    };\n  };\n  var renderItemDomStructure = function renderItemDomStructure(ariaLabel) {\n    var domTitle = ariaLabel.map(function (label) {\n      return {\n        attributes: {\n          title: global$8.translate(label),\n          id: generate$6('menu-item')\n        }\n      };\n    }).getOr({});\n    return _objectSpread({\n      tag: 'div',\n      classes: [navClass, selectableClass]\n    }, domTitle);\n  };\n  var renderNormalItemStructure = function renderNormalItemStructure(info, providersBackstage, renderIcons, fallbackIcon) {\n    var iconSpec = {\n      tag: 'div',\n      classes: [iconClass]\n    };\n    var renderIcon = function renderIcon(iconName) {\n      return render$3(iconName, iconSpec, providersBackstage.icons, fallbackIcon);\n    };\n    var renderEmptyIcon = function renderEmptyIcon() {\n      return Optional.some({\n        dom: iconSpec\n      });\n    };\n    var leftIcon = renderIcons ? info.iconContent.map(renderIcon).orThunk(renderEmptyIcon) : Optional.none();\n    var checkmark = info.checkMark;\n    var textRender = Optional.from(info.meta).fold(function () {\n      return renderText;\n    }, function (meta) {\n      return has$2(meta, 'style') ? curry(renderStyledText, meta.style) : renderText;\n    });\n    var content = info.htmlContent.fold(function () {\n      return info.textContent.map(textRender);\n    }, function (html) {\n      return Optional.some(renderHtml(html, [textClass]));\n    });\n    var menuItem = {\n      dom: renderItemDomStructure(info.ariaLabel),\n      optComponents: [leftIcon, content, info.shortcutContent.map(renderShortcut), checkmark, info.caret]\n    };\n    return menuItem;\n  };\n  var renderItemStructure = function renderItemStructure(info, providersBackstage, renderIcons) {\n    var fallbackIcon = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Optional.none();\n    if (info.presets === 'color') {\n      return renderColorStructure(info, providersBackstage, fallbackIcon);\n    } else {\n      return renderNormalItemStructure(info, providersBackstage, renderIcons, fallbackIcon);\n    }\n  };\n  var tooltipBehaviour = function tooltipBehaviour(meta, sharedBackstage) {\n    return get$g(meta, 'tooltipWorker').map(function (tooltipWorker) {\n      return [Tooltipping.config({\n        lazySink: sharedBackstage.getSink,\n        tooltipDom: {\n          tag: 'div',\n          classes: ['tox-tooltip-worker-container']\n        },\n        tooltipComponents: [],\n        anchor: function anchor(comp) {\n          return {\n            type: 'submenu',\n            item: comp,\n            overrides: {\n              maxHeightFunction: expandable$1\n            }\n          };\n        },\n        mode: 'follow-highlight',\n        onShow: function onShow(component, _tooltip) {\n          tooltipWorker(function (elm) {\n            Tooltipping.setComponents(component, [external$1({\n              element: SugarElement.fromDom(elm)\n            })]);\n          });\n        }\n      })];\n    }).getOr([]);\n  };\n  var encodeText = function encodeText(text) {\n    return global$7.DOM.encode(text);\n  };\n  var replaceText = function replaceText(text, matchText) {\n    var translated = global$8.translate(text);\n    var encoded = encodeText(translated);\n    if (matchText.length > 0) {\n      var escapedMatchRegex = new RegExp(escape(matchText), 'gi');\n      return encoded.replace(escapedMatchRegex, function (match) {\n        return \"<span class=\\\"tox-autocompleter-highlight\\\">\".concat(match, \"</span>\");\n      });\n    } else {\n      return encoded;\n    }\n  };\n  var renderAutocompleteItem = function renderAutocompleteItem(spec, matchText, useText, presets, onItemValueHandler, itemResponse, sharedBackstage) {\n    var renderIcons = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;\n    var structure = renderItemStructure({\n      presets: presets,\n      textContent: Optional.none(),\n      htmlContent: useText ? spec.text.map(function (text) {\n        return replaceText(text, matchText);\n      }) : Optional.none(),\n      ariaLabel: spec.text,\n      iconContent: spec.icon,\n      shortcutContent: Optional.none(),\n      checkMark: Optional.none(),\n      caret: Optional.none(),\n      value: spec.value\n    }, sharedBackstage.providers, renderIcons, spec.icon);\n    return renderCommonItem({\n      data: buildData(spec),\n      enabled: spec.enabled,\n      getApi: constant$1({}),\n      onAction: function onAction(_api) {\n        return onItemValueHandler(spec.value, spec.meta);\n      },\n      onSetup: constant$1(noop),\n      triggersSubmenu: false,\n      itemBehaviours: tooltipBehaviour(spec.meta, sharedBackstage)\n    }, structure, itemResponse, sharedBackstage.providers);\n  };\n  var render$2 = function render$2(items, extras) {\n    return map$2(items, function (item) {\n      switch (item.type) {\n        case 'cardcontainer':\n          return renderContainer(item, render$2(item.items, extras));\n        case 'cardimage':\n          return renderImage(item.src, item.classes, item.alt);\n        case 'cardtext':\n          var shouldHighlight = item.name.exists(function (name) {\n            return contains$2(extras.cardText.highlightOn, name);\n          });\n          var matchText = shouldHighlight ? Optional.from(extras.cardText.matchText).getOr('') : '';\n          return renderHtml(replaceText(item.text, matchText), item.classes);\n      }\n    });\n  };\n  var renderCardMenuItem = function renderCardMenuItem(spec, itemResponse, sharedBackstage, extras) {\n    var getApi = function getApi(component) {\n      return {\n        isEnabled: function isEnabled() {\n          return !Disabling.isDisabled(component);\n        },\n        setEnabled: function setEnabled(state) {\n          Disabling.set(component, !state);\n          each$1(descendants(component.element, '*'), function (elm) {\n            component.getSystem().getByDom(elm).each(function (comp) {\n              if (comp.hasConfigured(Disabling)) {\n                Disabling.set(comp, !state);\n              }\n            });\n          });\n        }\n      };\n    };\n    var structure = {\n      dom: renderItemDomStructure(spec.label),\n      optComponents: [Optional.some({\n        dom: {\n          tag: 'div',\n          classes: [containerClass, containerRowClass]\n        },\n        components: render$2(spec.items, extras)\n      })]\n    };\n    return renderCommonItem({\n      data: buildData(_objectSpread({\n        text: Optional.none()\n      }, spec)),\n      enabled: spec.enabled,\n      getApi: getApi,\n      onAction: spec.onAction,\n      onSetup: spec.onSetup,\n      triggersSubmenu: false,\n      itemBehaviours: Optional.from(extras.itemBehaviours).getOr([])\n    }, structure, itemResponse, sharedBackstage.providers);\n  };\n  var renderChoiceItem = function renderChoiceItem(spec, useText, presets, onItemValueHandler, isSelected, itemResponse, providersBackstage) {\n    var renderIcons = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;\n    var getApi = function getApi(component) {\n      return {\n        setActive: function setActive(state) {\n          Toggling.set(component, state);\n        },\n        isActive: function isActive() {\n          return Toggling.isOn(component);\n        },\n        isEnabled: function isEnabled() {\n          return !Disabling.isDisabled(component);\n        },\n        setEnabled: function setEnabled(state) {\n          return Disabling.set(component, !state);\n        }\n      };\n    };\n    var structure = renderItemStructure({\n      presets: presets,\n      textContent: useText ? spec.text : Optional.none(),\n      htmlContent: Optional.none(),\n      ariaLabel: spec.text,\n      iconContent: spec.icon,\n      shortcutContent: useText ? spec.shortcut : Optional.none(),\n      checkMark: useText ? Optional.some(renderCheckmark(providersBackstage.icons)) : Optional.none(),\n      caret: Optional.none(),\n      value: spec.value\n    }, providersBackstage, renderIcons);\n    return deepMerge(renderCommonItem({\n      data: buildData(spec),\n      enabled: spec.enabled,\n      getApi: getApi,\n      onAction: function onAction(_api) {\n        return onItemValueHandler(spec.value);\n      },\n      onSetup: function onSetup(api) {\n        api.setActive(isSelected);\n        return noop;\n      },\n      triggersSubmenu: false,\n      itemBehaviours: []\n    }, structure, itemResponse, providersBackstage), {\n      toggling: {\n        toggleClass: tickedClass,\n        toggleOnExecute: false,\n        selected: spec.active,\n        exclusive: true\n      }\n    });\n  };\n  var parts$f = generate$3(owner$2(), parts$h());\n  var hexColour = function hexColour(value) {\n    return {\n      value: normalizeHex(value)\n    };\n  };\n  var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  var longformRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n  var isHexString = function isHexString(hex) {\n    return shorthandRegex.test(hex) || longformRegex.test(hex);\n  };\n  var normalizeHex = function normalizeHex(hex) {\n    return removeLeading(hex, '#').toUpperCase();\n  };\n  var fromString$1 = function fromString$1(hex) {\n    return isHexString(hex) ? Optional.some({\n      value: normalizeHex(hex)\n    }) : Optional.none();\n  };\n  var getLongForm = function getLongForm(hex) {\n    var hexString = hex.value.replace(shorthandRegex, function (m, r, g, b) {\n      return r + r + g + g + b + b;\n    });\n    return {\n      value: hexString\n    };\n  };\n  var extractValues = function extractValues(hex) {\n    var longForm = getLongForm(hex);\n    var splitForm = longformRegex.exec(longForm.value);\n    return splitForm === null ? ['FFFFFF', 'FF', 'FF', 'FF'] : splitForm;\n  };\n  var toHex = function toHex(component) {\n    var hex = component.toString(16);\n    return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n  };\n  var fromRgba = function fromRgba(rgbaColour) {\n    var value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n    return hexColour(value);\n  };\n  var min = Math.min;\n  var max = Math.max;\n  var round$1 = Math.round;\n  var rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*$/i;\n  var rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)\\s*$/i;\n  var rgbaColour = function rgbaColour(red, green, blue, alpha) {\n    return {\n      red: red,\n      green: green,\n      blue: blue,\n      alpha: alpha\n    };\n  };\n  var isRgbaComponent = function isRgbaComponent(value) {\n    var num = parseInt(value, 10);\n    return num.toString() === value && num >= 0 && num <= 255;\n  };\n  var fromHsv = function fromHsv(hsv) {\n    var r;\n    var g;\n    var b;\n    var hue = (hsv.hue || 0) % 360;\n    var saturation = hsv.saturation / 100;\n    var brightness = hsv.value / 100;\n    saturation = max(0, min(saturation, 1));\n    brightness = max(0, min(brightness, 1));\n    if (saturation === 0) {\n      r = g = b = round$1(255 * brightness);\n      return rgbaColour(r, g, b, 1);\n    }\n    var side = hue / 60;\n    var chroma = brightness * saturation;\n    var x = chroma * (1 - Math.abs(side % 2 - 1));\n    var match = brightness - chroma;\n    switch (Math.floor(side)) {\n      case 0:\n        r = chroma;\n        g = x;\n        b = 0;\n        break;\n      case 1:\n        r = x;\n        g = chroma;\n        b = 0;\n        break;\n      case 2:\n        r = 0;\n        g = chroma;\n        b = x;\n        break;\n      case 3:\n        r = 0;\n        g = x;\n        b = chroma;\n        break;\n      case 4:\n        r = x;\n        g = 0;\n        b = chroma;\n        break;\n      case 5:\n        r = chroma;\n        g = 0;\n        b = x;\n        break;\n      default:\n        r = g = b = 0;\n    }\n    r = round$1(255 * (r + match));\n    g = round$1(255 * (g + match));\n    b = round$1(255 * (b + match));\n    return rgbaColour(r, g, b, 1);\n  };\n  var fromHex = function fromHex(hexColour) {\n    var result = extractValues(hexColour);\n    var red = parseInt(result[1], 16);\n    var green = parseInt(result[2], 16);\n    var blue = parseInt(result[3], 16);\n    return rgbaColour(red, green, blue, 1);\n  };\n  var fromStringValues = function fromStringValues(red, green, blue, alpha) {\n    var r = parseInt(red, 10);\n    var g = parseInt(green, 10);\n    var b = parseInt(blue, 10);\n    var a = parseFloat(alpha);\n    return rgbaColour(r, g, b, a);\n  };\n  var fromString = function fromString(rgbaString) {\n    if (rgbaString === 'transparent') {\n      return Optional.some(rgbaColour(0, 0, 0, 0));\n    }\n    var rgbMatch = rgbRegex.exec(rgbaString);\n    if (rgbMatch !== null) {\n      return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n    }\n    var rgbaMatch = rgbaRegex.exec(rgbaString);\n    if (rgbaMatch !== null) {\n      return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n    }\n    return Optional.none();\n  };\n  var toString = function toString(rgba) {\n    return \"rgba(\".concat(rgba.red, \",\").concat(rgba.green, \",\").concat(rgba.blue, \",\").concat(rgba.alpha, \")\");\n  };\n  var red = rgbaColour(255, 0, 0, 1);\n  var fireSkinLoaded$1 = function fireSkinLoaded$1(editor) {\n    editor.dispatch('SkinLoaded');\n  };\n  var fireSkinLoadError$1 = function fireSkinLoadError$1(editor, error) {\n    editor.dispatch('SkinLoadError', error);\n  };\n  var fireResizeEditor = function fireResizeEditor(editor) {\n    editor.dispatch('ResizeEditor');\n  };\n  var fireResizeContent = function fireResizeContent(editor, e) {\n    editor.dispatch('ResizeContent', e);\n  };\n  var fireScrollContent = function fireScrollContent(editor, e) {\n    editor.dispatch('ScrollContent', e);\n  };\n  var fireTextColorChange = function fireTextColorChange(editor, data) {\n    editor.dispatch('TextColorChange', data);\n  };\n  var fireAfterProgressState = function fireAfterProgressState(editor, state) {\n    editor.dispatch('AfterProgressState', {\n      state: state\n    });\n  };\n  var fireResolveName = function fireResolveName(editor, node) {\n    return editor.dispatch('ResolveName', {\n      name: node.nodeName.toLowerCase(),\n      target: node\n    });\n  };\n  var fireToggleToolbarDrawer = function fireToggleToolbarDrawer(editor, state) {\n    editor.dispatch('ToggleToolbarDrawer', {\n      state: state\n    });\n  };\n  var fireStylesTextUpdate = function fireStylesTextUpdate(editor, data) {\n    editor.dispatch('StylesTextUpdate', data);\n  };\n  var fireAlignTextUpdate = function fireAlignTextUpdate(editor, data) {\n    editor.dispatch('AlignTextUpdate', data);\n  };\n  var fireFontSizeTextUpdate = function fireFontSizeTextUpdate(editor, data) {\n    editor.dispatch('FontSizeTextUpdate', data);\n  };\n  var fireFontSizeInputTextUpdate = function fireFontSizeInputTextUpdate(editor, data) {\n    editor.dispatch('FontSizeInputTextUpdate', data);\n  };\n  var fireBlocksTextUpdate = function fireBlocksTextUpdate(editor, data) {\n    editor.dispatch('BlocksTextUpdate', data);\n  };\n  var fireFontFamilyTextUpdate = function fireFontFamilyTextUpdate(editor, data) {\n    editor.dispatch('FontFamilyTextUpdate', data);\n  };\n  var composeUnbinders = function composeUnbinders(f, g) {\n    return function () {\n      f();\n      g();\n    };\n  };\n  var onSetupEditableToggle = function onSetupEditableToggle(editor) {\n    return onSetupEvent(editor, 'NodeChange', function (api) {\n      api.setEnabled(editor.selection.isEditable());\n    });\n  };\n  var onSetupFormatToggle = function onSetupFormatToggle(editor, name) {\n    return function (api) {\n      var boundFormatChangeCallback = unbindable();\n      var init = function init() {\n        api.setActive(editor.formatter.match(name));\n        var binding = editor.formatter.formatChanged(name, api.setActive);\n        boundFormatChangeCallback.set(binding);\n      };\n      editor.initialized ? init() : editor.once('init', init);\n      return function () {\n        editor.off('init', init);\n        boundFormatChangeCallback.clear();\n      };\n    };\n  };\n  var onSetupStateToggle = function onSetupStateToggle(editor, name) {\n    return function (api) {\n      var unbindEditableToogle = onSetupEditableToggle(editor)(api);\n      var unbindFormatToggle = onSetupFormatToggle(editor, name)(api);\n      return function () {\n        unbindEditableToogle();\n        unbindFormatToggle();\n      };\n    };\n  };\n  var onSetupEvent = function onSetupEvent(editor, event, f) {\n    return function (api) {\n      var handleEvent = function handleEvent() {\n        return f(api);\n      };\n      var init = function init() {\n        f(api);\n        editor.on(event, handleEvent);\n      };\n      editor.initialized ? init() : editor.once('init', init);\n      return function () {\n        editor.off('init', init);\n        editor.off(event, handleEvent);\n      };\n    };\n  };\n  var onActionToggleFormat$1 = function onActionToggleFormat$1(editor) {\n    return function (rawItem) {\n      return function () {\n        editor.undoManager.transact(function () {\n          editor.focus();\n          editor.execCommand('mceToggleFormat', false, rawItem.format);\n        });\n      };\n    };\n  };\n  var onActionExecCommand = function onActionExecCommand(editor, command) {\n    return function () {\n      return editor.execCommand(command);\n    };\n  };\n  var global$4 = tinymce.util.Tools.resolve('tinymce.util.LocalStorage');\n  var cacheStorage = {};\n  var ColorCache = function ColorCache(storageId) {\n    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    var storageString = global$4.getItem(storageId);\n    var localstorage = isString(storageString) ? JSON.parse(storageString) : [];\n    var prune = function prune(list) {\n      var diff = max - list.length;\n      return diff < 0 ? list.slice(0, max) : list;\n    };\n    var cache = prune(localstorage);\n    var add = function add(key) {\n      indexOf(cache, key).each(remove);\n      cache.unshift(key);\n      if (cache.length > max) {\n        cache.pop();\n      }\n      global$4.setItem(storageId, JSON.stringify(cache));\n    };\n    var remove = function remove(idx) {\n      cache.splice(idx, 1);\n    };\n    var state = function state() {\n      return cache.slice(0);\n    };\n    return {\n      add: add,\n      state: state\n    };\n  };\n  var getCacheForId = function getCacheForId(id) {\n    return get$g(cacheStorage, id).getOrThunk(function () {\n      var storageId = \"tinymce-custom-colors-\".concat(id);\n      var currentData = global$4.getItem(storageId);\n      if (isNullable(currentData)) {\n        var legacyDefault = global$4.getItem('tinymce-custom-colors');\n        global$4.setItem(storageId, isNonNullable(legacyDefault) ? legacyDefault : '[]');\n      }\n      var storage = ColorCache(storageId, 10);\n      cacheStorage[id] = storage;\n      return storage;\n    });\n  };\n  var getCurrentColors = function getCurrentColors(id) {\n    return map$2(getCacheForId(id).state(), function (color) {\n      return {\n        type: 'choiceitem',\n        text: color,\n        icon: 'checkmark',\n        value: color\n      };\n    });\n  };\n  var addColor = function addColor(id, color) {\n    getCacheForId(id).add(color);\n  };\n  var hsvColour = function hsvColour(hue, saturation, value) {\n    return {\n      hue: hue,\n      saturation: saturation,\n      value: value\n    };\n  };\n  var fromRgb = function fromRgb(rgbaColour) {\n    var h = 0;\n    var s = 0;\n    var v = 0;\n    var r = rgbaColour.red / 255;\n    var g = rgbaColour.green / 255;\n    var b = rgbaColour.blue / 255;\n    var minRGB = Math.min(r, Math.min(g, b));\n    var maxRGB = Math.max(r, Math.max(g, b));\n    if (minRGB === maxRGB) {\n      v = minRGB;\n      return hsvColour(0, 0, v * 100);\n    }\n    var d = r === minRGB ? g - b : b === minRGB ? r - g : b - r;\n    h = r === minRGB ? 3 : b === minRGB ? 1 : 5;\n    h = 60 * (h - d / (maxRGB - minRGB));\n    s = (maxRGB - minRGB) / maxRGB;\n    v = maxRGB;\n    return hsvColour(Math.round(h), Math.round(s * 100), Math.round(v * 100));\n  };\n  var hexToHsv = function hexToHsv(hex) {\n    return fromRgb(fromHex(hex));\n  };\n  var hsvToHex = function hsvToHex(hsv) {\n    return fromRgba(fromHsv(hsv));\n  };\n  var anyToHex = function anyToHex(color) {\n    return fromString$1(color).orThunk(function () {\n      return fromString(color).map(fromRgba);\n    }).getOrThunk(function () {\n      var canvas = document.createElement('canvas');\n      canvas.height = 1;\n      canvas.width = 1;\n      var canvasContext = canvas.getContext('2d');\n      canvasContext.clearRect(0, 0, canvas.width, canvas.height);\n      canvasContext.fillStyle = '#FFFFFF';\n      canvasContext.fillStyle = color;\n      canvasContext.fillRect(0, 0, 1, 1);\n      var rgba = canvasContext.getImageData(0, 0, 1, 1).data;\n      var r = rgba[0];\n      var g = rgba[1];\n      var b = rgba[2];\n      var a = rgba[3];\n      return fromRgba(rgbaColour(r, g, b, a));\n    });\n  };\n  var foregroundId = 'forecolor';\n  var backgroundId = 'hilitecolor';\n  var fallbackCols = 5;\n  var mapColors = function mapColors(colorMap) {\n    var colors = [];\n    for (var i = 0; i < colorMap.length; i += 2) {\n      colors.push({\n        text: colorMap[i + 1],\n        value: '#' + anyToHex(colorMap[i]).value,\n        icon: 'checkmark',\n        type: 'choiceitem'\n      });\n    }\n    return colors;\n  };\n  var option$1 = function option$1(name) {\n    return function (editor) {\n      return editor.options.get(name);\n    };\n  };\n  var fallbackColor = '#000000';\n  var register$d = function register$d(editor) {\n    var registerOption = editor.options.register;\n    var colorProcessor = function colorProcessor(value) {\n      if (isArrayOf(value, isString)) {\n        return {\n          value: mapColors(value),\n          valid: true\n        };\n      } else {\n        return {\n          valid: false,\n          message: 'Must be an array of strings.'\n        };\n      }\n    };\n    var colorColsProcessor = function colorColsProcessor(value) {\n      if (isNumber(value) && value > 0) {\n        return {\n          value: value,\n          valid: true\n        };\n      } else {\n        return {\n          valid: false,\n          message: 'Must be a positive number.'\n        };\n      }\n    };\n    registerOption('color_map', {\n      processor: colorProcessor,\n      default: ['#BFEDD2', 'Light Green', '#FBEEB8', 'Light Yellow', '#F8CAC6', 'Light Red', '#ECCAFA', 'Light Purple', '#C2E0F4', 'Light Blue', '#2DC26B', 'Green', '#F1C40F', 'Yellow', '#E03E2D', 'Red', '#B96AD9', 'Purple', '#3598DB', 'Blue', '#169179', 'Dark Turquoise', '#E67E23', 'Orange', '#BA372A', 'Dark Red', '#843FA1', 'Dark Purple', '#236FA1', 'Dark Blue', '#ECF0F1', 'Light Gray', '#CED4D9', 'Medium Gray', '#95A5A6', 'Gray', '#7E8C8D', 'Dark Gray', '#34495E', 'Navy Blue', '#000000', 'Black', '#ffffff', 'White']\n    });\n    registerOption('color_map_background', {\n      processor: colorProcessor\n    });\n    registerOption('color_map_foreground', {\n      processor: colorProcessor\n    });\n    registerOption('color_cols', {\n      processor: colorColsProcessor,\n      default: calcCols(editor)\n    });\n    registerOption('color_cols_foreground', {\n      processor: colorColsProcessor,\n      default: defaultCols(editor, foregroundId)\n    });\n    registerOption('color_cols_background', {\n      processor: colorColsProcessor,\n      default: defaultCols(editor, backgroundId)\n    });\n    registerOption('custom_colors', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('color_default_foreground', {\n      processor: 'string',\n      default: fallbackColor\n    });\n    registerOption('color_default_background', {\n      processor: 'string',\n      default: fallbackColor\n    });\n  };\n  var getColors$2 = function getColors$2(editor, id) {\n    if (id === foregroundId && editor.options.isSet('color_map_foreground')) {\n      return option$1('color_map_foreground')(editor);\n    } else if (id === backgroundId && editor.options.isSet('color_map_background')) {\n      return option$1('color_map_background')(editor);\n    } else {\n      return option$1('color_map')(editor);\n    }\n  };\n  var calcCols = function calcCols(editor) {\n    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n    return Math.max(fallbackCols, Math.ceil(Math.sqrt(getColors$2(editor, id).length)));\n  };\n  var defaultCols = function defaultCols(editor, id) {\n    var defaultCols = option$1('color_cols')(editor);\n    var calculatedCols = calcCols(editor, id);\n    if (defaultCols === calcCols(editor)) {\n      return calculatedCols;\n    } else {\n      return defaultCols;\n    }\n  };\n  var getColorCols$1 = function getColorCols$1(editor) {\n    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n    var getCols = function getCols() {\n      if (id === foregroundId) {\n        return option$1('color_cols_foreground')(editor);\n      } else if (id === backgroundId) {\n        return option$1('color_cols_background')(editor);\n      } else {\n        return option$1('color_cols')(editor);\n      }\n    };\n    return Math.round(getCols());\n  };\n  var hasCustomColors$1 = option$1('custom_colors');\n  var getDefaultForegroundColor = option$1('color_default_foreground');\n  var getDefaultBackgroundColor = option$1('color_default_background');\n  var defaultBackgroundColor = 'rgba(0, 0, 0, 0)';\n  var isValidBackgroundColor = function isValidBackgroundColor(value) {\n    return fromString(value).exists(function (c) {\n      return c.alpha !== 0;\n    });\n  };\n  var getClosestCssBackgroundColorValue = function getClosestCssBackgroundColorValue(scope) {\n    return closest$4(scope, function (node) {\n      if (isElement$1(node)) {\n        var color = get$e(node, 'background-color');\n        return someIf(isValidBackgroundColor(color), color);\n      } else {\n        return Optional.none();\n      }\n    }).getOr(defaultBackgroundColor);\n  };\n  var getCurrentColor = function getCurrentColor(editor, format) {\n    var node = SugarElement.fromDom(editor.selection.getStart());\n    var cssRgbValue = format === 'hilitecolor' ? getClosestCssBackgroundColorValue(node) : get$e(node, 'color');\n    return fromString(cssRgbValue).map(function (rgba) {\n      return '#' + fromRgba(rgba).value;\n    });\n  };\n  var applyFormat = function applyFormat(editor, format, value) {\n    editor.undoManager.transact(function () {\n      editor.focus();\n      editor.formatter.apply(format, {\n        value: value\n      });\n      editor.nodeChanged();\n    });\n  };\n  var removeFormat = function removeFormat(editor, format) {\n    editor.undoManager.transact(function () {\n      editor.focus();\n      editor.formatter.remove(format, {\n        value: null\n      }, undefined, true);\n      editor.nodeChanged();\n    });\n  };\n  var registerCommands = function registerCommands(editor) {\n    editor.addCommand('mceApplyTextcolor', function (format, value) {\n      applyFormat(editor, format, value);\n    });\n    editor.addCommand('mceRemoveTextcolor', function (format) {\n      removeFormat(editor, format);\n    });\n  };\n  var getAdditionalColors = function getAdditionalColors(hasCustom) {\n    var type = 'choiceitem';\n    var remove = {\n      type: type,\n      text: 'Remove color',\n      icon: 'color-swatch-remove-color',\n      value: 'remove'\n    };\n    var custom = {\n      type: type,\n      text: 'Custom color',\n      icon: 'color-picker',\n      value: 'custom'\n    };\n    return hasCustom ? [remove, custom] : [remove];\n  };\n  var applyColor = function applyColor(editor, format, value, onChoice) {\n    if (value === 'custom') {\n      var dialog = colorPickerDialog(editor);\n      dialog(function (colorOpt) {\n        colorOpt.each(function (color) {\n          addColor(format, color);\n          editor.execCommand('mceApplyTextcolor', format, color);\n          onChoice(color);\n        });\n      }, getCurrentColor(editor, format).getOr(fallbackColor));\n    } else if (value === 'remove') {\n      onChoice('');\n      editor.execCommand('mceRemoveTextcolor', format);\n    } else {\n      onChoice(value);\n      editor.execCommand('mceApplyTextcolor', format, value);\n    }\n  };\n  var getColors$1 = function getColors$1(colors, id, hasCustom) {\n    return colors.concat(getCurrentColors(id).concat(getAdditionalColors(hasCustom)));\n  };\n  var getFetch$1 = function getFetch$1(colors, id, hasCustom) {\n    return function (callback) {\n      callback(getColors$1(colors, id, hasCustom));\n    };\n  };\n  var setIconColor = function setIconColor(splitButtonApi, name, newColor) {\n    var id = name === 'forecolor' ? 'tox-icon-text-color__color' : 'tox-icon-highlight-bg-color__color';\n    splitButtonApi.setIconFill(id, newColor);\n  };\n  var setTooltip = function setTooltip(buttonApi, tooltip) {\n    buttonApi.setTooltip(tooltip);\n  };\n  var select$1 = function select$1(editor, format) {\n    return function (value) {\n      var optCurrentHex = getCurrentColor(editor, format);\n      return is$1(optCurrentHex, value.toUpperCase());\n    };\n  };\n  var getToolTipText = function getToolTipText(editor, format, lastColor) {\n    if (isEmpty(lastColor)) {\n      return format === 'forecolor' ? 'Text color' : 'Background color';\n    }\n    var tooltipPrefix = format === 'forecolor' ? 'Text color {0}' : 'Background color {0}';\n    var colors = getColors$1(getColors$2(editor, format), format, false);\n    var colorText = find$5(colors, function (c) {\n      return c.value === lastColor;\n    }).getOr({\n      text: ''\n    }).text;\n    return editor.translate([tooltipPrefix, editor.translate(colorText)]);\n  };\n  var registerTextColorButton = function registerTextColorButton(editor, name, format, lastColor) {\n    editor.ui.registry.addSplitButton(name, {\n      tooltip: getToolTipText(editor, format, lastColor.get()),\n      presets: 'color',\n      icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',\n      select: select$1(editor, format),\n      columns: getColorCols$1(editor, format),\n      fetch: getFetch$1(getColors$2(editor, format), format, hasCustomColors$1(editor)),\n      onAction: function onAction(_splitButtonApi) {\n        applyColor(editor, format, lastColor.get(), noop);\n      },\n      onItemAction: function onItemAction(_splitButtonApi, value) {\n        applyColor(editor, format, value, function (newColor) {\n          lastColor.set(newColor);\n          fireTextColorChange(editor, {\n            name: name,\n            color: newColor\n          });\n        });\n      },\n      onSetup: function onSetup(splitButtonApi) {\n        setIconColor(splitButtonApi, name, lastColor.get());\n        var handler = function handler(e) {\n          if (e.name === name) {\n            setIconColor(splitButtonApi, e.name, e.color);\n            setTooltip(splitButtonApi, getToolTipText(editor, format, e.color));\n          }\n        };\n        editor.on('TextColorChange', handler);\n        return composeUnbinders(onSetupEditableToggle(editor)(splitButtonApi), function () {\n          editor.off('TextColorChange', handler);\n        });\n      }\n    });\n  };\n  var registerTextColorMenuItem = function registerTextColorMenuItem(editor, name, format, text, lastColor) {\n    editor.ui.registry.addNestedMenuItem(name, {\n      text: text,\n      icon: name === 'forecolor' ? 'text-color' : 'highlight-bg-color',\n      onSetup: function onSetup(api) {\n        setTooltip(api, getToolTipText(editor, format, lastColor.get()));\n        setIconColor(api, name, lastColor.get());\n        return onSetupEditableToggle(editor)(api);\n      },\n      getSubmenuItems: function getSubmenuItems() {\n        return [{\n          type: 'fancymenuitem',\n          fancytype: 'colorswatch',\n          select: select$1(editor, format),\n          initData: {\n            storageKey: format\n          },\n          onAction: function onAction(data) {\n            applyColor(editor, format, data.value, function (newColor) {\n              lastColor.set(newColor);\n              fireTextColorChange(editor, {\n                name: name,\n                color: newColor\n              });\n            });\n          }\n        }];\n      }\n    });\n  };\n  var colorPickerDialog = function colorPickerDialog(editor) {\n    return function (callback, value) {\n      var isValid = false;\n      var onSubmit = function onSubmit(api) {\n        var data = api.getData();\n        var hex = data.colorpicker;\n        if (isValid) {\n          callback(Optional.from(hex));\n          api.close();\n        } else {\n          editor.windowManager.alert(editor.translate(['Invalid hex color code: {0}', hex]));\n        }\n      };\n      var onAction = function onAction(_api, details) {\n        if (details.name === 'hex-valid') {\n          isValid = details.value;\n        }\n      };\n      var initialData = {\n        colorpicker: value\n      };\n      editor.windowManager.open({\n        title: 'Color Picker',\n        size: 'normal',\n        body: {\n          type: 'panel',\n          items: [{\n            type: 'colorpicker',\n            name: 'colorpicker',\n            label: 'Color'\n          }]\n        },\n        buttons: [{\n          type: 'cancel',\n          name: 'cancel',\n          text: 'Cancel'\n        }, {\n          type: 'submit',\n          name: 'save',\n          text: 'Save',\n          primary: true\n        }],\n        initialData: initialData,\n        onAction: onAction,\n        onSubmit: onSubmit,\n        onClose: noop,\n        onCancel: function onCancel() {\n          callback(Optional.none());\n        }\n      });\n    };\n  };\n  var register$c = function register$c(editor) {\n    registerCommands(editor);\n    var fallbackColorForeground = getDefaultForegroundColor(editor);\n    var fallbackColorBackground = getDefaultBackgroundColor(editor);\n    var lastForeColor = Cell(fallbackColorForeground);\n    var lastBackColor = Cell(fallbackColorBackground);\n    registerTextColorButton(editor, 'forecolor', 'forecolor', lastForeColor);\n    registerTextColorButton(editor, 'backcolor', 'hilitecolor', lastBackColor);\n    registerTextColorMenuItem(editor, 'forecolor', 'forecolor', 'Text color', lastForeColor);\n    registerTextColorMenuItem(editor, 'backcolor', 'hilitecolor', 'Background color', lastBackColor);\n  };\n  var createPartialChoiceMenu = function createPartialChoiceMenu(value, items, onItemValueHandler, columns, presets, itemResponse, select, providersBackstage) {\n    var hasIcons = menuHasIcons(items);\n    var presetItemTypes = presets !== 'color' ? 'normal' : 'color';\n    var alloyItems = createChoiceItems(items, onItemValueHandler, columns, presetItemTypes, itemResponse, select, providersBackstage);\n    var menuLayout = {\n      menuType: presets\n    };\n    return createPartialMenuWithAlloyItems(value, hasIcons, alloyItems, columns, menuLayout);\n  };\n  var createChoiceItems = function createChoiceItems(items, onItemValueHandler, columns, itemPresets, itemResponse, select, providersBackstage) {\n    return cat(map$2(items, function (item) {\n      if (item.type === 'choiceitem') {\n        return createChoiceMenuItem(item).fold(handleError, function (d) {\n          return Optional.some(renderChoiceItem(d, columns === 1, itemPresets, onItemValueHandler, select(d.value), itemResponse, providersBackstage, menuHasIcons(items)));\n        });\n      } else {\n        return Optional.none();\n      }\n    }));\n  };\n  var deriveMenuMovement = function deriveMenuMovement(columns, presets) {\n    var menuMarkers = markers(presets);\n    if (columns === 1) {\n      return {\n        mode: 'menu',\n        moveOnTab: true\n      };\n    } else if (columns === 'auto') {\n      return {\n        mode: 'grid',\n        selector: '.' + menuMarkers.item,\n        initSize: {\n          numColumns: 1,\n          numRows: 1\n        }\n      };\n    } else {\n      var rowClass = presets === 'color' ? 'tox-swatches__row' : 'tox-collection__group';\n      return {\n        mode: 'matrix',\n        rowSelector: '.' + rowClass,\n        previousSelector: function previousSelector(menu) {\n          return presets === 'color' ? descendant(menu.element, '[aria-checked=true]') : Optional.none();\n        }\n      };\n    }\n  };\n  var deriveCollectionMovement = function deriveCollectionMovement(columns, presets) {\n    if (columns === 1) {\n      return {\n        mode: 'menu',\n        moveOnTab: false,\n        selector: '.tox-collection__item'\n      };\n    } else if (columns === 'auto') {\n      return {\n        mode: 'flatgrid',\n        selector: '.' + 'tox-collection__item',\n        initSize: {\n          numColumns: 1,\n          numRows: 1\n        }\n      };\n    } else {\n      return {\n        mode: 'matrix',\n        selectors: {\n          row: presets === 'color' ? '.tox-swatches__row' : '.tox-collection__group',\n          cell: presets === 'color' ? \".\".concat(colorClass) : \".\".concat(selectableClass)\n        }\n      };\n    }\n  };\n  var renderColorSwatchItem = function renderColorSwatchItem(spec, backstage) {\n    var items = getColorItems(spec, backstage);\n    var columns = backstage.colorinput.getColorCols(spec.initData.storageKey);\n    var presets = 'color';\n    var menuSpec = createPartialChoiceMenu(generate$6('menu-value'), items, function (value) {\n      spec.onAction({\n        value: value\n      });\n    }, columns, presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), backstage.shared.providers);\n    var widgetSpec = _objectSpread({}, menuSpec, {\n      markers: markers(presets),\n      movement: deriveMenuMovement(columns, presets)\n    });\n    return {\n      type: 'widget',\n      data: {\n        value: generate$6('widget-id')\n      },\n      dom: {\n        tag: 'div',\n        classes: ['tox-fancymenuitem']\n      },\n      autofocus: true,\n      components: [parts$f.widget(Menu.sketch(widgetSpec))]\n    };\n  };\n  var getColorItems = function getColorItems(spec, backstage) {\n    var useCustomColors = spec.initData.allowCustomColors && backstage.colorinput.hasCustomColors();\n    return spec.initData.colors.fold(function () {\n      return getColors$1(backstage.colorinput.getColors(spec.initData.storageKey), spec.initData.storageKey, useCustomColors);\n    }, function (colors) {\n      return colors.concat(getAdditionalColors(useCustomColors));\n    });\n  };\n  var cellOverEvent = generate$6('cell-over');\n  var cellExecuteEvent = generate$6('cell-execute');\n  var makeAnnouncementText = function makeAnnouncementText(backstage) {\n    return function (row, col) {\n      return backstage.shared.providers.translate(\"\".concat(col, \" columns, \").concat(row, \" rows\"));\n    };\n  };\n  var makeCell = function makeCell(row, col, label) {\n    var emitCellOver = function emitCellOver(c) {\n      return emitWith(c, cellOverEvent, {\n        row: row,\n        col: col\n      });\n    };\n    var emitExecute = function emitExecute(c) {\n      return emitWith(c, cellExecuteEvent, {\n        row: row,\n        col: col\n      });\n    };\n    var onClick = function onClick(c, se) {\n      se.stop();\n      emitExecute(c);\n    };\n    return build$1({\n      dom: {\n        tag: 'div',\n        attributes: _defineProperty({\n          role: 'button'\n        }, 'aria-label', label)\n      },\n      behaviours: derive$1([config('insert-table-picker-cell', [run$1(mouseover(), Focusing.focus), run$1(execute$5(), emitExecute), run$1(click(), onClick), run$1(tap(), onClick)]), Toggling.config({\n        toggleClass: 'tox-insert-table-picker__selected',\n        toggleOnExecute: false\n      }), Focusing.config({\n        onFocus: emitCellOver\n      })])\n    });\n  };\n  var makeCells = function makeCells(getCellLabel, numRows, numCols) {\n    var cells = [];\n    for (var i = 0; i < numRows; i++) {\n      var row = [];\n      for (var j = 0; j < numCols; j++) {\n        var _label = getCellLabel(i + 1, j + 1);\n        row.push(makeCell(i, j, _label));\n      }\n      cells.push(row);\n    }\n    return cells;\n  };\n  var selectCells = function selectCells(cells, selectedRow, selectedColumn, numRows, numColumns) {\n    for (var i = 0; i < numRows; i++) {\n      for (var j = 0; j < numColumns; j++) {\n        Toggling.set(cells[i][j], i <= selectedRow && j <= selectedColumn);\n      }\n    }\n  };\n  var makeComponents = function makeComponents(cells) {\n    return bind$3(cells, function (cellRow) {\n      return map$2(cellRow, premade);\n    });\n  };\n  var makeLabelText = function makeLabelText(row, col) {\n    return text$2(\"\".concat(col, \"x\").concat(row));\n  };\n  var renderInsertTableMenuItem = function renderInsertTableMenuItem(spec, backstage) {\n    var numRows = 10;\n    var numColumns = 10;\n    var getCellLabel = makeAnnouncementText(backstage);\n    var cells = makeCells(getCellLabel, numRows, numColumns);\n    var emptyLabelText = makeLabelText(0, 0);\n    var memLabel = record({\n      dom: {\n        tag: 'span',\n        classes: ['tox-insert-table-picker__label']\n      },\n      components: [emptyLabelText],\n      behaviours: derive$1([Replacing.config({})])\n    });\n    return {\n      type: 'widget',\n      data: {\n        value: generate$6('widget-id')\n      },\n      dom: {\n        tag: 'div',\n        classes: ['tox-fancymenuitem']\n      },\n      autofocus: true,\n      components: [parts$f.widget({\n        dom: {\n          tag: 'div',\n          classes: ['tox-insert-table-picker']\n        },\n        components: makeComponents(cells).concat(memLabel.asSpec()),\n        behaviours: derive$1([config('insert-table-picker', [runOnAttached(function (c) {\n          Replacing.set(memLabel.get(c), [emptyLabelText]);\n        }), runWithTarget(cellOverEvent, function (c, t, e) {\n          var _e$event = e.event,\n            row = _e$event.row,\n            col = _e$event.col;\n          selectCells(cells, row, col, numRows, numColumns);\n          Replacing.set(memLabel.get(c), [makeLabelText(row + 1, col + 1)]);\n        }), runWithTarget(cellExecuteEvent, function (c, _, e) {\n          var _e$event2 = e.event,\n            row = _e$event2.row,\n            col = _e$event2.col;\n          spec.onAction({\n            numRows: row + 1,\n            numColumns: col + 1\n          });\n          emit(c, sandboxClose());\n        })]), Keying.config({\n          initSize: {\n            numRows: numRows,\n            numColumns: numColumns\n          },\n          mode: 'flatgrid',\n          selector: '[role=\"button\"]'\n        })])\n      })]\n    };\n  };\n  var fancyMenuItems = {\n    inserttable: renderInsertTableMenuItem,\n    colorswatch: renderColorSwatchItem\n  };\n  var renderFancyMenuItem = function renderFancyMenuItem(spec, backstage) {\n    return get$g(fancyMenuItems, spec.fancytype).map(function (render) {\n      return render(spec, backstage);\n    });\n  };\n  var renderNestedItem = function renderNestedItem(spec, itemResponse, providersBackstage) {\n    var renderIcons = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var downwardsCaret = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var caret = downwardsCaret ? renderDownwardsCaret(providersBackstage.icons) : renderSubmenuCaret(providersBackstage.icons);\n    var getApi = function getApi(component) {\n      return {\n        isEnabled: function isEnabled() {\n          return !Disabling.isDisabled(component);\n        },\n        setEnabled: function setEnabled(state) {\n          return Disabling.set(component, !state);\n        },\n        setIconFill: function setIconFill(id, value) {\n          descendant(component.element, \"svg path[class=\\\"\".concat(id, \"\\\"], rect[class=\\\"\").concat(id, \"\\\"]\")).each(function (underlinePath) {\n            set$9(underlinePath, 'fill', value);\n          });\n        },\n        setTooltip: function setTooltip(tooltip) {\n          var translatedTooltip = providersBackstage.translate(tooltip);\n          setAll$1(component.element, {\n            'aria-label': translatedTooltip,\n            'title': translatedTooltip\n          });\n        }\n      };\n    };\n    var structure = renderItemStructure({\n      presets: 'normal',\n      iconContent: spec.icon,\n      textContent: spec.text,\n      htmlContent: Optional.none(),\n      ariaLabel: spec.text,\n      caret: Optional.some(caret),\n      checkMark: Optional.none(),\n      shortcutContent: spec.shortcut\n    }, providersBackstage, renderIcons);\n    return renderCommonItem({\n      data: buildData(spec),\n      getApi: getApi,\n      enabled: spec.enabled,\n      onAction: noop,\n      onSetup: spec.onSetup,\n      triggersSubmenu: true,\n      itemBehaviours: []\n    }, structure, itemResponse, providersBackstage);\n  };\n  var renderNormalItem = function renderNormalItem(spec, itemResponse, providersBackstage) {\n    var renderIcons = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var getApi = function getApi(component) {\n      return {\n        isEnabled: function isEnabled() {\n          return !Disabling.isDisabled(component);\n        },\n        setEnabled: function setEnabled(state) {\n          return Disabling.set(component, !state);\n        }\n      };\n    };\n    var structure = renderItemStructure({\n      presets: 'normal',\n      iconContent: spec.icon,\n      textContent: spec.text,\n      htmlContent: Optional.none(),\n      ariaLabel: spec.text,\n      caret: Optional.none(),\n      checkMark: Optional.none(),\n      shortcutContent: spec.shortcut\n    }, providersBackstage, renderIcons);\n    return renderCommonItem({\n      data: buildData(spec),\n      getApi: getApi,\n      enabled: spec.enabled,\n      onAction: spec.onAction,\n      onSetup: spec.onSetup,\n      triggersSubmenu: false,\n      itemBehaviours: []\n    }, structure, itemResponse, providersBackstage);\n  };\n  var renderSeparatorItem = function renderSeparatorItem(spec) {\n    return {\n      type: 'separator',\n      dom: {\n        tag: 'div',\n        classes: [selectableClass, groupHeadingClass]\n      },\n      components: spec.text.map(text$2).toArray()\n    };\n  };\n  var renderToggleMenuItem = function renderToggleMenuItem(spec, itemResponse, providersBackstage) {\n    var renderIcons = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var getApi = function getApi(component) {\n      return {\n        setActive: function setActive(state) {\n          Toggling.set(component, state);\n        },\n        isActive: function isActive() {\n          return Toggling.isOn(component);\n        },\n        isEnabled: function isEnabled() {\n          return !Disabling.isDisabled(component);\n        },\n        setEnabled: function setEnabled(state) {\n          return Disabling.set(component, !state);\n        }\n      };\n    };\n    var structure = renderItemStructure({\n      iconContent: spec.icon,\n      textContent: spec.text,\n      htmlContent: Optional.none(),\n      ariaLabel: spec.text,\n      checkMark: Optional.some(renderCheckmark(providersBackstage.icons)),\n      caret: Optional.none(),\n      shortcutContent: spec.shortcut,\n      presets: 'normal',\n      meta: spec.meta\n    }, providersBackstage, renderIcons);\n    return deepMerge(renderCommonItem({\n      data: buildData(spec),\n      enabled: spec.enabled,\n      getApi: getApi,\n      onAction: spec.onAction,\n      onSetup: spec.onSetup,\n      triggersSubmenu: false,\n      itemBehaviours: []\n    }, structure, itemResponse, providersBackstage), {\n      toggling: {\n        toggleClass: tickedClass,\n        toggleOnExecute: false,\n        selected: spec.active\n      }\n    });\n  };\n  var autocomplete = renderAutocompleteItem;\n  var separator$3 = renderSeparatorItem;\n  var normal = renderNormalItem;\n  var nested = renderNestedItem;\n  var toggle$1 = renderToggleMenuItem;\n  var fancy = renderFancyMenuItem;\n  var card = renderCardMenuItem;\n  var getCoupled = function getCoupled(component, coupleConfig, coupleState, name) {\n    return coupleState.getOrCreate(component, coupleConfig, name);\n  };\n  var getExistingCoupled = function getExistingCoupled(component, coupleConfig, coupleState, name) {\n    return coupleState.getExisting(component, coupleConfig, name);\n  };\n  var CouplingApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getCoupled: getCoupled,\n    getExistingCoupled: getExistingCoupled\n  });\n  var CouplingSchema = [requiredOf('others', setOf(Result.value, anyValue()))];\n  var init$a = function init$a() {\n    var coupled = {};\n    var lookupCoupled = function lookupCoupled(coupleConfig, coupledName) {\n      var available = keys(coupleConfig.others);\n      if (available.length === 0) {\n        throw new Error('Cannot find any known coupled components');\n      } else {\n        return get$g(coupled, coupledName);\n      }\n    };\n    var getOrCreate = function getOrCreate(component, coupleConfig, name) {\n      return lookupCoupled(coupleConfig, name).getOrThunk(function () {\n        var builder = get$g(coupleConfig.others, name).getOrDie('No information found for coupled component: ' + name);\n        var spec = builder(component);\n        var built = component.getSystem().build(spec);\n        coupled[name] = built;\n        return built;\n      });\n    };\n    var getExisting = function getExisting(component, coupleConfig, name) {\n      return lookupCoupled(coupleConfig, name).orThunk(function () {\n        get$g(coupleConfig.others, name).getOrDie('No information found for coupled component: ' + name);\n        return Optional.none();\n      });\n    };\n    var readState = constant$1({});\n    return nu$8({\n      readState: readState,\n      getExisting: getExisting,\n      getOrCreate: getOrCreate\n    });\n  };\n  var CouplingState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    init: init$a\n  });\n  var Coupling = create$4({\n    fields: CouplingSchema,\n    name: 'coupling',\n    apis: CouplingApis,\n    state: CouplingState\n  });\n  var nu$3 = function nu$3(baseFn) {\n    var data = Optional.none();\n    var callbacks = [];\n    var map = function map(f) {\n      return nu$3(function (nCallback) {\n        get(function (data) {\n          nCallback(f(data));\n        });\n      });\n    };\n    var get = function get(nCallback) {\n      if (isReady()) {\n        call(nCallback);\n      } else {\n        callbacks.push(nCallback);\n      }\n    };\n    var set = function set(x) {\n      if (!isReady()) {\n        data = Optional.some(x);\n        run(callbacks);\n        callbacks = [];\n      }\n    };\n    var isReady = function isReady() {\n      return data.isSome();\n    };\n    var run = function run(cbs) {\n      each$1(cbs, call);\n    };\n    var call = function call(cb) {\n      data.each(function (x) {\n        setTimeout(function () {\n          cb(x);\n        }, 0);\n      });\n    };\n    baseFn(set);\n    return {\n      get: get,\n      map: map,\n      isReady: isReady\n    };\n  };\n  var pure$1 = function pure$1(a) {\n    return nu$3(function (callback) {\n      callback(a);\n    });\n  };\n  var LazyValue = {\n    nu: nu$3,\n    pure: pure$1\n  };\n  var errorReporter = function errorReporter(err) {\n    setTimeout(function () {\n      throw err;\n    }, 0);\n  };\n  var make$5 = function make$5(run) {\n    var get = function get(callback) {\n      run().then(callback, errorReporter);\n    };\n    var map = function map(fab) {\n      return make$5(function () {\n        return run().then(fab);\n      });\n    };\n    var bind = function bind(aFutureB) {\n      return make$5(function () {\n        return run().then(function (v) {\n          return aFutureB(v).toPromise();\n        });\n      });\n    };\n    var anonBind = function anonBind(futureB) {\n      return make$5(function () {\n        return run().then(function () {\n          return futureB.toPromise();\n        });\n      });\n    };\n    var toLazy = function toLazy() {\n      return LazyValue.nu(get);\n    };\n    var toCached = function toCached() {\n      var cache = null;\n      return make$5(function () {\n        if (cache === null) {\n          cache = run();\n        }\n        return cache;\n      });\n    };\n    var toPromise = run;\n    return {\n      map: map,\n      bind: bind,\n      anonBind: anonBind,\n      toLazy: toLazy,\n      toCached: toCached,\n      toPromise: toPromise,\n      get: get\n    };\n  };\n  var nu$2 = function nu$2(baseFn) {\n    return make$5(function () {\n      return new Promise(baseFn);\n    });\n  };\n  var pure = function pure(a) {\n    return make$5(function () {\n      return Promise.resolve(a);\n    });\n  };\n  var Future = {\n    nu: nu$2,\n    pure: pure\n  };\n  var suffix = constant$1('sink');\n  var partType$1 = constant$1(optional({\n    name: suffix(),\n    overrides: constant$1({\n      dom: {\n        tag: 'div'\n      },\n      behaviours: derive$1([Positioning.config({\n        useFixed: always\n      })]),\n      events: derive$2([cutter(keydown()), cutter(mousedown()), cutter(click())])\n    })\n  }));\n  var getAnchor = function getAnchor(detail, component) {\n    var hotspot = detail.getHotspot(component).getOr(component);\n    var type = 'hotspot';\n    var overrides = detail.getAnchorOverrides();\n    return detail.layouts.fold(function () {\n      return {\n        type: type,\n        hotspot: hotspot,\n        overrides: overrides\n      };\n    }, function (layouts) {\n      return {\n        type: type,\n        hotspot: hotspot,\n        overrides: overrides,\n        layouts: layouts\n      };\n    });\n  };\n  var fetch = function fetch(detail, mapFetch, component) {\n    var fetcher = detail.fetch;\n    return fetcher(component).map(mapFetch);\n  };\n  var openF = function openF(detail, mapFetch, anchor, component, sandbox, externals, highlightOnOpen) {\n    var futureData = fetch(detail, mapFetch, component);\n    var getLazySink = getSink(component, detail);\n    return futureData.map(function (tdata) {\n      return tdata.bind(function (data) {\n        return Optional.from(tieredMenu.sketch(_objectSpread({}, externals.menu(), {\n          uid: generate$5(''),\n          data: data,\n          highlightOnOpen: highlightOnOpen,\n          onOpenMenu: function onOpenMenu(tmenu, menu) {\n            var sink = getLazySink().getOrDie();\n            Positioning.position(sink, menu, {\n              anchor: anchor\n            });\n            Sandboxing.decloak(sandbox);\n          },\n          onOpenSubmenu: function onOpenSubmenu(tmenu, item, submenu) {\n            var sink = getLazySink().getOrDie();\n            Positioning.position(sink, submenu, {\n              anchor: {\n                type: 'submenu',\n                item: item\n              }\n            });\n            Sandboxing.decloak(sandbox);\n          },\n          onRepositionMenu: function onRepositionMenu(tmenu, primaryMenu, submenuTriggers) {\n            var sink = getLazySink().getOrDie();\n            Positioning.position(sink, primaryMenu, {\n              anchor: anchor\n            });\n            each$1(submenuTriggers, function (st) {\n              Positioning.position(sink, st.triggeredMenu, {\n                anchor: {\n                  type: 'submenu',\n                  item: st.triggeringItem\n                }\n              });\n            });\n          },\n          onEscape: function onEscape() {\n            Focusing.focus(component);\n            Sandboxing.close(sandbox);\n            return Optional.some(true);\n          }\n        })));\n      });\n    });\n  };\n  var open = function open(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen) {\n    var anchor = getAnchor(detail, hotspot);\n    var processed = openF(detail, mapFetch, anchor, hotspot, sandbox, externals, highlightOnOpen);\n    return processed.map(function (tdata) {\n      tdata.fold(function () {\n        if (Sandboxing.isOpen(sandbox)) {\n          Sandboxing.close(sandbox);\n        }\n      }, function (data) {\n        Sandboxing.cloak(sandbox);\n        Sandboxing.open(sandbox, data);\n        onOpenSync(sandbox);\n      });\n      return sandbox;\n    });\n  };\n  var close = function close(detail, mapFetch, component, sandbox, _externals, _onOpenSync, _highlightOnOpen) {\n    Sandboxing.close(sandbox);\n    return Future.pure(sandbox);\n  };\n  var togglePopup = function togglePopup(detail, mapFetch, hotspot, externals, onOpenSync, highlightOnOpen) {\n    var sandbox = Coupling.getCoupled(hotspot, 'sandbox');\n    var showing = Sandboxing.isOpen(sandbox);\n    var action = showing ? close : open;\n    return action(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen);\n  };\n  var matchWidth = function matchWidth(hotspot, container, useMinWidth) {\n    var menu = Composing.getCurrent(container).getOr(container);\n    var buttonWidth = get$c(hotspot.element);\n    if (useMinWidth) {\n      set$8(menu.element, 'min-width', buttonWidth + 'px');\n    } else {\n      set$7(menu.element, buttonWidth);\n    }\n  };\n  var getSink = function getSink(anyInSystem, sinkDetail) {\n    return anyInSystem.getSystem().getByUid(sinkDetail.uid + '-' + suffix()).map(function (internalSink) {\n      return function () {\n        return Result.value(internalSink);\n      };\n    }).getOrThunk(function () {\n      return sinkDetail.lazySink.fold(function () {\n        return function () {\n          return Result.error(new Error('No internal sink is specified, nor could an external sink be found'));\n        };\n      }, function (lazySinkFn) {\n        return function () {\n          return lazySinkFn(anyInSystem);\n        };\n      });\n    });\n  };\n  var doRepositionMenus = function doRepositionMenus(sandbox) {\n    Sandboxing.getState(sandbox).each(function (tmenu) {\n      tieredMenu.repositionMenus(tmenu);\n    });\n  };\n  var makeSandbox$1 = function makeSandbox$1(detail, hotspot, extras) {\n    var ariaControls = manager();\n    var onOpen = function onOpen(component, menu) {\n      var anchor = getAnchor(detail, hotspot);\n      ariaControls.link(hotspot.element);\n      if (detail.matchWidth) {\n        matchWidth(anchor.hotspot, menu, detail.useMinWidth);\n      }\n      detail.onOpen(anchor, component, menu);\n      if (extras !== undefined && extras.onOpen !== undefined) {\n        extras.onOpen(component, menu);\n      }\n    };\n    var onClose = function onClose(component, menu) {\n      ariaControls.unlink(hotspot.element);\n      if (extras !== undefined && extras.onClose !== undefined) {\n        extras.onClose(component, menu);\n      }\n    };\n    var lazySink = getSink(hotspot, detail);\n    return {\n      dom: {\n        tag: 'div',\n        classes: detail.sandboxClasses,\n        attributes: {\n          id: ariaControls.id,\n          role: 'listbox'\n        }\n      },\n      behaviours: SketchBehaviours.augment(detail.sandboxBehaviours, [Representing.config({\n        store: {\n          mode: 'memory',\n          initialValue: hotspot\n        }\n      }), Sandboxing.config({\n        onOpen: onOpen,\n        onClose: onClose,\n        isPartOf: function isPartOf(container, data, queryElem) {\n          return isPartOf$1(data, queryElem) || isPartOf$1(hotspot, queryElem);\n        },\n        getAttachPoint: function getAttachPoint() {\n          return lazySink().getOrDie();\n        }\n      }), Composing.config({\n        find: function find(sandbox) {\n          return Sandboxing.getState(sandbox).bind(function (menu) {\n            return Composing.getCurrent(menu);\n          });\n        }\n      }), Receiving.config({\n        channels: _objectSpread({}, receivingChannel$1({\n          isExtraPart: never\n        }), receivingChannel({\n          doReposition: doRepositionMenus\n        }))\n      })])\n    };\n  };\n  var _repositionMenus = function repositionMenus(comp) {\n    var sandbox = Coupling.getCoupled(comp, 'sandbox');\n    doRepositionMenus(sandbox);\n  };\n  var sandboxFields = function sandboxFields() {\n    return [defaulted('sandboxClasses', []), SketchBehaviours.field('sandboxBehaviours', [Composing, Receiving, Sandboxing, Representing])];\n  };\n  var schema$k = constant$1([required$1('dom'), required$1('fetch'), onHandler('onOpen'), onKeyboardHandler('onExecute'), defaulted('getHotspot', Optional.some), defaulted('getAnchorOverrides', constant$1({})), schema$y(), field('dropdownBehaviours', [Toggling, Coupling, Keying, Focusing]), required$1('toggleClass'), defaulted('eventOrder', {}), option$3('lazySink'), defaulted('matchWidth', false), defaulted('useMinWidth', false), option$3('role')].concat(sandboxFields()));\n  var parts$e = constant$1([external({\n    schema: [tieredMenuMarkers(), defaulted('fakeFocus', false)],\n    name: 'menu',\n    defaults: function defaults(detail) {\n      return {\n        onExecute: detail.onExecute\n      };\n    }\n  }), partType$1()]);\n  var factory$k = function factory$k(detail, components, _spec, externals) {\n    var lookupAttr = function lookupAttr(attr) {\n      return get$g(detail.dom, 'attributes').bind(function (attrs) {\n        return get$g(attrs, attr);\n      });\n    };\n    var switchToMenu = function switchToMenu(sandbox) {\n      Sandboxing.getState(sandbox).each(function (tmenu) {\n        tieredMenu.highlightPrimary(tmenu);\n      });\n    };\n    var togglePopup$1 = function togglePopup$1(dropdownComp, onOpenSync, highlightOnOpen) {\n      return togglePopup(detail, identity, dropdownComp, externals, onOpenSync, highlightOnOpen);\n    };\n    var action = function action(component) {\n      var onOpenSync = switchToMenu;\n      togglePopup$1(component, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n    };\n    var apis = {\n      expand: function expand(comp) {\n        if (!Toggling.isOn(comp)) {\n          togglePopup$1(comp, noop, HighlightOnOpen.HighlightNone).get(noop);\n        }\n      },\n      open: function open(comp) {\n        if (!Toggling.isOn(comp)) {\n          togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n        }\n      },\n      refetch: function refetch(comp) {\n        var optSandbox = Coupling.getExistingCoupled(comp, 'sandbox');\n        return optSandbox.fold(function () {\n          return togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem).map(noop);\n        }, function (sandboxComp) {\n          return open(detail, identity, comp, sandboxComp, externals, noop, HighlightOnOpen.HighlightMenuAndItem).map(noop);\n        });\n      },\n      isOpen: Toggling.isOn,\n      close: function close(comp) {\n        if (Toggling.isOn(comp)) {\n          togglePopup$1(comp, noop, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n        }\n      },\n      repositionMenus: function repositionMenus(comp) {\n        if (Toggling.isOn(comp)) {\n          _repositionMenus(comp);\n        }\n      }\n    };\n    var triggerExecute = function triggerExecute(comp, _se) {\n      emitExecute(comp);\n      return Optional.some(true);\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      behaviours: augment(detail.dropdownBehaviours, [Toggling.config({\n        toggleClass: detail.toggleClass,\n        aria: {\n          mode: 'expanded'\n        }\n      }), Coupling.config({\n        others: {\n          sandbox: function sandbox(hotspot) {\n            return makeSandbox$1(detail, hotspot, {\n              onOpen: function onOpen() {\n                return Toggling.on(hotspot);\n              },\n              onClose: function onClose() {\n                return Toggling.off(hotspot);\n              }\n            });\n          }\n        }\n      }), Keying.config({\n        mode: 'special',\n        onSpace: triggerExecute,\n        onEnter: triggerExecute,\n        onDown: function onDown(comp, _se) {\n          if (Dropdown.isOpen(comp)) {\n            var sandbox = Coupling.getCoupled(comp, 'sandbox');\n            switchToMenu(sandbox);\n          } else {\n            Dropdown.open(comp);\n          }\n          return Optional.some(true);\n        },\n        onEscape: function onEscape(comp, _se) {\n          if (Dropdown.isOpen(comp)) {\n            Dropdown.close(comp);\n            return Optional.some(true);\n          } else {\n            return Optional.none();\n          }\n        }\n      }), Focusing.config({})]),\n      events: events$a(Optional.some(action)),\n      eventOrder: _objectSpread({}, detail.eventOrder, _defineProperty({}, execute$5(), ['disabling', 'toggling', 'alloy.base.behaviour'])),\n      apis: apis,\n      domModification: {\n        attributes: _objectSpread({\n          'aria-haspopup': 'true'\n        }, detail.role.fold(function () {\n          return {};\n        }, function (role) {\n          return {\n            role: role\n          };\n        }), detail.dom.tag === 'button' ? {\n          type: lookupAttr('type').getOr('button')\n        } : {})\n      }\n    };\n  };\n  var Dropdown = composite({\n    name: 'Dropdown',\n    configFields: schema$k(),\n    partFields: parts$e(),\n    factory: factory$k,\n    apis: {\n      open: function open(apis, comp) {\n        return apis.open(comp);\n      },\n      refetch: function refetch(apis, comp) {\n        return apis.refetch(comp);\n      },\n      expand: function expand(apis, comp) {\n        return apis.expand(comp);\n      },\n      close: function close(apis, comp) {\n        return apis.close(comp);\n      },\n      isOpen: function isOpen(apis, comp) {\n        return apis.isOpen(comp);\n      },\n      repositionMenus: function repositionMenus(apis, comp) {\n        return apis.repositionMenus(comp);\n      }\n    }\n  });\n  var identifyMenuLayout = function identifyMenuLayout(searchMode) {\n    switch (searchMode.searchMode) {\n      case 'no-search':\n        {\n          return {\n            menuType: 'normal'\n          };\n        }\n      default:\n        {\n          return {\n            menuType: 'searchable',\n            searchMode: searchMode\n          };\n        }\n    }\n  };\n  var handleRefetchTrigger = function handleRefetchTrigger(originalSandboxComp) {\n    var dropdown = Representing.getValue(originalSandboxComp);\n    var optSearcherState = findWithinSandbox(originalSandboxComp).map(saveState);\n    Dropdown.refetch(dropdown).get(function () {\n      var newSandboxComp = Coupling.getCoupled(dropdown, 'sandbox');\n      optSearcherState.each(function (searcherState) {\n        return findWithinSandbox(newSandboxComp).each(function (inputComp) {\n          return restoreState(inputComp, searcherState);\n        });\n      });\n    });\n  };\n  var handleRedirectToMenuItem = function handleRedirectToMenuItem(sandboxComp, se) {\n    getActiveMenuItemFrom(sandboxComp).each(function (activeItem) {\n      retargetAndDispatchWith(sandboxComp, activeItem.element, se.event.eventType, se.event.interactionEvent);\n    });\n  };\n  var getActiveMenuItemFrom = function getActiveMenuItemFrom(sandboxComp) {\n    return Sandboxing.getState(sandboxComp).bind(Highlighting.getHighlighted).bind(Highlighting.getHighlighted);\n  };\n  var getSearchResults = function getSearchResults(activeMenuComp) {\n    return has(activeMenuComp.element, searchResultsClass) ? Optional.some(activeMenuComp.element) : descendant(activeMenuComp.element, '.' + searchResultsClass);\n  };\n  var updateAriaOnHighlight = function updateAriaOnHighlight(tmenuComp, menuComp, itemComp) {\n    findWithinMenu(tmenuComp).each(function (inputComp) {\n      setActiveDescendant(inputComp, itemComp);\n      var optActiveResults = getSearchResults(menuComp);\n      optActiveResults.each(function (resultsElem) {\n        getOpt(resultsElem, 'id').each(function (controlledId) {\n          return set$9(inputComp.element, 'aria-controls', controlledId);\n        });\n      });\n    });\n    set$9(itemComp.element, 'aria-selected', 'true');\n  };\n  var updateAriaOnDehighlight = function updateAriaOnDehighlight(tmenuComp, menuComp, itemComp) {\n    set$9(itemComp.element, 'aria-selected', 'false');\n  };\n  var focusSearchField = function focusSearchField(tmenuComp) {\n    findWithinMenu(tmenuComp).each(function (searcherComp) {\n      return Focusing.focus(searcherComp);\n    });\n  };\n  var getSearchPattern = function getSearchPattern(dropdownComp) {\n    var optSandboxComp = Coupling.getExistingCoupled(dropdownComp, 'sandbox');\n    return optSandboxComp.bind(findWithinSandbox).map(saveState).map(function (state) {\n      return state.fetchPattern;\n    }).getOr('');\n  };\n  var FocusMode;\n  (function (FocusMode) {\n    FocusMode[FocusMode['ContentFocus'] = 0] = 'ContentFocus';\n    FocusMode[FocusMode['UiFocus'] = 1] = 'UiFocus';\n  })(FocusMode || (FocusMode = {}));\n  var createMenuItemFromBridge = function createMenuItemFromBridge(item, itemResponse, backstage, menuHasIcons, isHorizontalMenu) {\n    var providersBackstage = backstage.shared.providers;\n    var parseForHorizontalMenu = function parseForHorizontalMenu(menuitem) {\n      return !isHorizontalMenu ? menuitem : _objectSpread({}, menuitem, {\n        shortcut: Optional.none(),\n        icon: menuitem.text.isSome() ? Optional.none() : menuitem.icon\n      });\n    };\n    switch (item.type) {\n      case 'menuitem':\n        return createMenuItem(item).fold(handleError, function (d) {\n          return Optional.some(normal(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons));\n        });\n      case 'nestedmenuitem':\n        return createNestedMenuItem(item).fold(handleError, function (d) {\n          return Optional.some(nested(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons, isHorizontalMenu));\n        });\n      case 'togglemenuitem':\n        return createToggleMenuItem(item).fold(handleError, function (d) {\n          return Optional.some(toggle$1(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons));\n        });\n      case 'separator':\n        return createSeparatorMenuItem(item).fold(handleError, function (d) {\n          return Optional.some(separator$3(d));\n        });\n      case 'fancymenuitem':\n        return createFancyMenuItem(item).fold(handleError, function (d) {\n          return fancy(d, backstage);\n        });\n      default:\n        {\n          console.error('Unknown item in general menu', item);\n          return Optional.none();\n        }\n    }\n  };\n  var createAutocompleteItems = function createAutocompleteItems(items, matchText, onItemValueHandler, columns, itemResponse, sharedBackstage, highlightOn) {\n    var renderText = columns === 1;\n    var renderIcons = !renderText || menuHasIcons(items);\n    return cat(map$2(items, function (item) {\n      switch (item.type) {\n        case 'separator':\n          return createSeparatorItem(item).fold(handleError, function (d) {\n            return Optional.some(separator$3(d));\n          });\n        case 'cardmenuitem':\n          return createCardMenuItem(item).fold(handleError, function (d) {\n            return Optional.some(card(_objectSpread({}, d, {\n              onAction: function onAction(api) {\n                d.onAction(api);\n                onItemValueHandler(d.value, d.meta);\n              }\n            }), itemResponse, sharedBackstage, {\n              itemBehaviours: tooltipBehaviour(d.meta, sharedBackstage),\n              cardText: {\n                matchText: matchText,\n                highlightOn: highlightOn\n              }\n            }));\n          });\n        case 'autocompleteitem':\n        default:\n          return createAutocompleterItem(item).fold(handleError, function (d) {\n            return Optional.some(autocomplete(d, matchText, renderText, 'normal', onItemValueHandler, itemResponse, sharedBackstage, renderIcons));\n          });\n      }\n    }));\n  };\n  var createPartialMenu = function createPartialMenu(value, items, itemResponse, backstage, isHorizontalMenu, searchMode) {\n    var hasIcons = menuHasIcons(items);\n    var alloyItems = cat(map$2(items, function (item) {\n      var itemHasIcon = function itemHasIcon(i) {\n        return isHorizontalMenu ? !has$2(i, 'text') : hasIcons;\n      };\n      var createItem = function createItem(i) {\n        return createMenuItemFromBridge(i, itemResponse, backstage, itemHasIcon(i), isHorizontalMenu);\n      };\n      if (item.type === 'nestedmenuitem' && item.getSubmenuItems().length <= 0) {\n        return createItem(_objectSpread({}, item, {\n          enabled: false\n        }));\n      } else {\n        return createItem(item);\n      }\n    }));\n    var menuLayout = identifyMenuLayout(searchMode);\n    var createPartial = isHorizontalMenu ? createHorizontalPartialMenuWithAlloyItems : createPartialMenuWithAlloyItems;\n    return createPartial(value, hasIcons, alloyItems, 1, menuLayout);\n  };\n  var createTieredDataFrom = function createTieredDataFrom(partialMenu) {\n    return tieredMenu.singleData(partialMenu.value, partialMenu);\n  };\n  var createInlineMenuFrom = function createInlineMenuFrom(partialMenu, columns, focusMode, presets) {\n    var movement = deriveMenuMovement(columns, presets);\n    var menuMarkers = markers(presets);\n    return {\n      data: createTieredDataFrom(_objectSpread({}, partialMenu, {\n        movement: movement,\n        menuBehaviours: SimpleBehaviours.unnamedEvents(columns !== 'auto' ? [] : [runOnAttached(function (comp, _se) {\n          detectSize(comp, 4, menuMarkers.item).each(function (_ref6) {\n            var numColumns = _ref6.numColumns,\n              numRows = _ref6.numRows;\n            Keying.setGridSize(comp, numRows, numColumns);\n          });\n        })])\n      })),\n      menu: {\n        markers: markers(presets),\n        fakeFocus: focusMode === FocusMode.ContentFocus\n      }\n    };\n  };\n  var getAutocompleterRange = function getAutocompleterRange(dom, initRange) {\n    return detect$1(SugarElement.fromDom(initRange.startContainer)).map(function (elm) {\n      var range = dom.createRng();\n      range.selectNode(elm.dom);\n      return range;\n    });\n  };\n  var register$b = function register$b(editor, sharedBackstage) {\n    var autocompleterId = generate$6('autocompleter');\n    var processingAction = Cell(false);\n    var activeState = Cell(false);\n    var autocompleter = build$1(InlineView.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-autocompleter'],\n        attributes: {\n          id: autocompleterId\n        }\n      },\n      components: [],\n      fireDismissalEventInstead: {},\n      inlineBehaviours: derive$1([config('dismissAutocompleter', [run$1(dismissRequested(), function () {\n        return cancelIfNecessary();\n      }), run$1(highlight$1(), function (_, se) {\n        getOpt(se.event.target, 'id').each(function (id) {\n          return set$9(SugarElement.fromDom(editor.getBody()), 'aria-activedescendant', id);\n        });\n      })])]),\n      lazySink: sharedBackstage.getSink\n    }));\n    var isMenuOpen = function isMenuOpen() {\n      return InlineView.isOpen(autocompleter);\n    };\n    var isActive = activeState.get;\n    var hideIfNecessary = function hideIfNecessary() {\n      if (isMenuOpen()) {\n        InlineView.hide(autocompleter);\n        editor.dom.remove(autocompleterId, false);\n        var editorBody = SugarElement.fromDom(editor.getBody());\n        getOpt(editorBody, 'aria-owns').filter(function (ariaOwnsAttr) {\n          return ariaOwnsAttr === autocompleterId;\n        }).each(function () {\n          remove$7(editorBody, 'aria-owns');\n          remove$7(editorBody, 'aria-activedescendant');\n        });\n      }\n    };\n    var getMenu = function getMenu() {\n      return InlineView.getContent(autocompleter).bind(function (tmenu) {\n        return get$h(tmenu.components(), 0);\n      });\n    };\n    var cancelIfNecessary = function cancelIfNecessary() {\n      return editor.execCommand('mceAutocompleterClose');\n    };\n    var getCombinedItems = function getCombinedItems(matches) {\n      var columns = findMap(matches, function (m) {\n        return Optional.from(m.columns);\n      }).getOr(1);\n      return bind$3(matches, function (match) {\n        var choices = match.items;\n        return createAutocompleteItems(choices, match.matchText, function (itemValue, itemMeta) {\n          var nr = editor.selection.getRng();\n          getAutocompleterRange(editor.dom, nr).each(function (range) {\n            var autocompleterApi = {\n              hide: function hide() {\n                return cancelIfNecessary();\n              },\n              reload: function reload(fetchOptions) {\n                hideIfNecessary();\n                editor.execCommand('mceAutocompleterReload', false, {\n                  fetchOptions: fetchOptions\n                });\n              }\n            };\n            processingAction.set(true);\n            match.onAction(autocompleterApi, range, itemValue, itemMeta);\n            processingAction.set(false);\n          });\n        }, columns, ItemResponse$1.BUBBLE_TO_SANDBOX, sharedBackstage, match.highlightOn);\n      });\n    };\n    var display = function display(lookupData, items) {\n      findIn(SugarElement.fromDom(editor.getBody())).each(function (element) {\n        var columns = findMap(lookupData, function (ld) {\n          return Optional.from(ld.columns);\n        }).getOr(1);\n        InlineView.showMenuAt(autocompleter, {\n          anchor: {\n            type: 'node',\n            root: SugarElement.fromDom(editor.getBody()),\n            node: Optional.from(element)\n          }\n        }, createInlineMenuFrom(createPartialMenuWithAlloyItems('autocompleter-value', true, items, columns, {\n          menuType: 'normal'\n        }), columns, FocusMode.ContentFocus, 'normal'));\n      });\n      getMenu().each(Highlighting.highlightFirst);\n    };\n    var updateDisplay = function updateDisplay(lookupData) {\n      var combinedItems = getCombinedItems(lookupData);\n      if (combinedItems.length > 0) {\n        display(lookupData, combinedItems);\n        set$9(SugarElement.fromDom(editor.getBody()), 'aria-owns', autocompleterId);\n        if (!editor.inline) {\n          cloneAutocompleterToEditorDoc();\n        }\n      } else {\n        hideIfNecessary();\n      }\n    };\n    var cloneAutocompleterToEditorDoc = function cloneAutocompleterToEditorDoc() {\n      if (editor.dom.get(autocompleterId)) {\n        editor.dom.remove(autocompleterId, false);\n      }\n      var docElm = editor.getDoc().documentElement;\n      var selection = editor.selection.getNode();\n      var newElm = deep(autocompleter.element);\n      setAll(newElm, {\n        border: '0',\n        clip: 'rect(0 0 0 0)',\n        height: '1px',\n        margin: '-1px',\n        overflow: 'hidden',\n        padding: '0',\n        position: 'absolute',\n        width: '1px',\n        top: \"\".concat(selection.offsetTop, \"px\"),\n        left: \"\".concat(selection.offsetLeft, \"px\")\n      });\n      editor.dom.add(docElm, newElm.dom);\n      descendant(newElm, '[role=\"menu\"]').each(function (child) {\n        remove$6(child, 'position');\n        remove$6(child, 'max-height');\n      });\n    };\n    editor.on('AutocompleterStart', function (_ref7) {\n      var lookupData = _ref7.lookupData;\n      activeState.set(true);\n      processingAction.set(false);\n      updateDisplay(lookupData);\n    });\n    editor.on('AutocompleterUpdate', function (_ref8) {\n      var lookupData = _ref8.lookupData;\n      return updateDisplay(lookupData);\n    });\n    editor.on('AutocompleterEnd', function () {\n      hideIfNecessary();\n      activeState.set(false);\n      processingAction.set(false);\n    });\n    var autocompleterUiApi = {\n      cancelIfNecessary: cancelIfNecessary,\n      isMenuOpen: isMenuOpen,\n      isActive: isActive,\n      isProcessingAction: processingAction.get,\n      getMenu: getMenu\n    };\n    AutocompleterEditorEvents.setup(autocompleterUiApi, editor);\n  };\n  var Autocompleter = {\n    register: register$b\n  };\n  var nonScrollingOverflows = ['visible', 'hidden', 'clip'];\n  var isScrollingOverflowValue = function isScrollingOverflowValue(value) {\n    return trim$1(value).length > 0 && !contains$2(nonScrollingOverflows, value);\n  };\n  var isScroller = function isScroller(elem) {\n    if (isHTMLElement(elem)) {\n      var overflowX = get$e(elem, 'overflow-x');\n      var overflowY = get$e(elem, 'overflow-y');\n      return isScrollingOverflowValue(overflowX) || isScrollingOverflowValue(overflowY);\n    } else {\n      return false;\n    }\n  };\n  var detect = function detect(popupSinkElem) {\n    var ancestorsScrollers = ancestors(popupSinkElem, isScroller);\n    var scrollers = ancestorsScrollers.length === 0 ? getShadowRoot(popupSinkElem).map(getShadowHost).map(function (x) {\n      return ancestors(x, isScroller);\n    }).getOr([]) : ancestorsScrollers;\n    return head(scrollers).map(function (element) {\n      return {\n        element: element,\n        others: scrollers.slice(1)\n      };\n    });\n  };\n  var detectWhenSplitUiMode = function detectWhenSplitUiMode(editor, popupSinkElem) {\n    return isSplitUiMode(editor) ? detect(popupSinkElem) : Optional.none();\n  };\n  var getBoundsFrom = function getBoundsFrom(sc) {\n    var scrollableBoxes = [].concat(_toConsumableArray(map$2(sc.others, box$1)), [win()]);\n    return constrainByMany(box$1(sc.element), scrollableBoxes);\n  };\n  var closest = function closest(scope, selector, isRoot) {\n    return closest$1(scope, selector, isRoot).isSome();\n  };\n  var DelayedFunction = function DelayedFunction(fun, delay) {\n    var ref = null;\n    var schedule = function schedule() {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      ref = setTimeout(function () {\n        fun.apply(null, args);\n        ref = null;\n      }, delay);\n    };\n    var cancel = function cancel() {\n      if (ref !== null) {\n        clearTimeout(ref);\n        ref = null;\n      }\n    };\n    return {\n      cancel: cancel,\n      schedule: schedule\n    };\n  };\n  var SIGNIFICANT_MOVE = 5;\n  var LONGPRESS_DELAY = 400;\n  var getTouch = function getTouch(event) {\n    var raw = event.raw;\n    if (raw.touches === undefined || raw.touches.length !== 1) {\n      return Optional.none();\n    }\n    return Optional.some(raw.touches[0]);\n  };\n  var isFarEnough = function isFarEnough(touch, data) {\n    var distX = Math.abs(touch.clientX - data.x);\n    var distY = Math.abs(touch.clientY - data.y);\n    return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n  };\n  var monitor = function monitor(settings) {\n    var startData = value$2();\n    var longpressFired = Cell(false);\n    var longpress$1 = DelayedFunction(function (event) {\n      settings.triggerEvent(longpress(), event);\n      longpressFired.set(true);\n    }, LONGPRESS_DELAY);\n    var handleTouchstart = function handleTouchstart(event) {\n      getTouch(event).each(function (touch) {\n        longpress$1.cancel();\n        var data = {\n          x: touch.clientX,\n          y: touch.clientY,\n          target: event.target\n        };\n        longpress$1.schedule(event);\n        longpressFired.set(false);\n        startData.set(data);\n      });\n      return Optional.none();\n    };\n    var handleTouchmove = function handleTouchmove(event) {\n      longpress$1.cancel();\n      getTouch(event).each(function (touch) {\n        startData.on(function (data) {\n          if (isFarEnough(touch, data)) {\n            startData.clear();\n          }\n        });\n      });\n      return Optional.none();\n    };\n    var handleTouchend = function handleTouchend(event) {\n      longpress$1.cancel();\n      var isSame = function isSame(data) {\n        return eq(data.target, event.target);\n      };\n      return startData.get().filter(isSame).map(function (_data) {\n        if (longpressFired.get()) {\n          event.prevent();\n          return false;\n        } else {\n          return settings.triggerEvent(tap(), event);\n        }\n      });\n    };\n    var handlers = wrapAll([{\n      key: touchstart(),\n      value: handleTouchstart\n    }, {\n      key: touchmove(),\n      value: handleTouchmove\n    }, {\n      key: touchend(),\n      value: handleTouchend\n    }]);\n    var fireIfReady = function fireIfReady(event, type) {\n      return get$g(handlers, type).bind(function (handler) {\n        return handler(event);\n      });\n    };\n    return {\n      fireIfReady: fireIfReady\n    };\n  };\n  var isDangerous = function isDangerous(event) {\n    var keyEv = event.raw;\n    return keyEv.which === BACKSPACE[0] && !contains$2(['input', 'textarea'], name$3(event.target)) && !closest(event.target, '[contenteditable=\"true\"]');\n  };\n  var setup$d = function setup$d(container, rawSettings) {\n    var settings = _objectSpread({\n      stopBackspace: true\n    }, rawSettings);\n    var pointerEvents = ['touchstart', 'touchmove', 'touchend', 'touchcancel', 'gesturestart', 'mousedown', 'mouseup', 'mouseover', 'mousemove', 'mouseout', 'click'];\n    var tapEvent = monitor(settings);\n    var simpleEvents = map$2(pointerEvents.concat(['selectstart', 'input', 'contextmenu', 'change', 'transitionend', 'transitioncancel', 'drag', 'dragstart', 'dragend', 'dragenter', 'dragleave', 'dragover', 'drop', 'keyup']), function (type) {\n      return bind(container, type, function (event) {\n        tapEvent.fireIfReady(event, type).each(function (tapStopped) {\n          if (tapStopped) {\n            event.kill();\n          }\n        });\n        var stopped = settings.triggerEvent(type, event);\n        if (stopped) {\n          event.kill();\n        }\n      });\n    });\n    var pasteTimeout = value$2();\n    var onPaste = bind(container, 'paste', function (event) {\n      tapEvent.fireIfReady(event, 'paste').each(function (tapStopped) {\n        if (tapStopped) {\n          event.kill();\n        }\n      });\n      var stopped = settings.triggerEvent('paste', event);\n      if (stopped) {\n        event.kill();\n      }\n      pasteTimeout.set(setTimeout(function () {\n        settings.triggerEvent(postPaste(), event);\n      }, 0));\n    });\n    var onKeydown = bind(container, 'keydown', function (event) {\n      var stopped = settings.triggerEvent('keydown', event);\n      if (stopped) {\n        event.kill();\n      } else if (settings.stopBackspace && isDangerous(event)) {\n        event.prevent();\n      }\n    });\n    var onFocusIn = bind(container, 'focusin', function (event) {\n      var stopped = settings.triggerEvent('focusin', event);\n      if (stopped) {\n        event.kill();\n      }\n    });\n    var focusoutTimeout = value$2();\n    var onFocusOut = bind(container, 'focusout', function (event) {\n      var stopped = settings.triggerEvent('focusout', event);\n      if (stopped) {\n        event.kill();\n      }\n      focusoutTimeout.set(setTimeout(function () {\n        settings.triggerEvent(postBlur(), event);\n      }, 0));\n    });\n    var unbind = function unbind() {\n      each$1(simpleEvents, function (e) {\n        e.unbind();\n      });\n      onKeydown.unbind();\n      onFocusIn.unbind();\n      onFocusOut.unbind();\n      onPaste.unbind();\n      pasteTimeout.on(clearTimeout);\n      focusoutTimeout.on(clearTimeout);\n    };\n    return {\n      unbind: unbind\n    };\n  };\n  var derive = function derive(rawEvent, rawTarget) {\n    var source = get$g(rawEvent, 'target').getOr(rawTarget);\n    return Cell(source);\n  };\n  var fromSource = function fromSource(event, source) {\n    var stopper = Cell(false);\n    var cutter = Cell(false);\n    var stop = function stop() {\n      stopper.set(true);\n    };\n    var cut = function cut() {\n      cutter.set(true);\n    };\n    return {\n      stop: stop,\n      cut: cut,\n      isStopped: stopper.get,\n      isCut: cutter.get,\n      event: event,\n      setSource: source.set,\n      getSource: source.get\n    };\n  };\n  var fromExternal = function fromExternal(event) {\n    var stopper = Cell(false);\n    var stop = function stop() {\n      stopper.set(true);\n    };\n    return {\n      stop: stop,\n      cut: noop,\n      isStopped: stopper.get,\n      isCut: never,\n      event: event,\n      setSource: die('Cannot set source of a broadcasted event'),\n      getSource: die('Cannot get source of a broadcasted event')\n    };\n  };\n  var adt$1 = Adt.generate([{\n    stopped: []\n  }, {\n    resume: ['element']\n  }, {\n    complete: []\n  }]);\n  var doTriggerHandler = function doTriggerHandler(lookup, eventType, rawEvent, target, source, logger) {\n    var handler = lookup(eventType, target);\n    var simulatedEvent = fromSource(rawEvent, source);\n    return handler.fold(function () {\n      logger.logEventNoHandlers(eventType, target);\n      return adt$1.complete();\n    }, function (handlerInfo) {\n      var descHandler = handlerInfo.descHandler;\n      var eventHandler = getCurried(descHandler);\n      eventHandler(simulatedEvent);\n      if (simulatedEvent.isStopped()) {\n        logger.logEventStopped(eventType, handlerInfo.element, descHandler.purpose);\n        return adt$1.stopped();\n      } else if (simulatedEvent.isCut()) {\n        logger.logEventCut(eventType, handlerInfo.element, descHandler.purpose);\n        return adt$1.complete();\n      } else {\n        return parent(handlerInfo.element).fold(function () {\n          logger.logNoParent(eventType, handlerInfo.element, descHandler.purpose);\n          return adt$1.complete();\n        }, function (parent) {\n          logger.logEventResponse(eventType, handlerInfo.element, descHandler.purpose);\n          return adt$1.resume(parent);\n        });\n      }\n    });\n  };\n  var doTriggerOnUntilStopped = function doTriggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, source, logger) {\n    return doTriggerHandler(lookup, eventType, rawEvent, rawTarget, source, logger).fold(always, function (parent) {\n      return doTriggerOnUntilStopped(lookup, eventType, rawEvent, parent, source, logger);\n    }, never);\n  };\n  var triggerHandler = function triggerHandler(lookup, eventType, rawEvent, target, logger) {\n    var source = derive(rawEvent, target);\n    return doTriggerHandler(lookup, eventType, rawEvent, target, source, logger);\n  };\n  var broadcast = function broadcast(listeners, rawEvent, _logger) {\n    var simulatedEvent = fromExternal(rawEvent);\n    each$1(listeners, function (listener) {\n      var descHandler = listener.descHandler;\n      var handler = getCurried(descHandler);\n      handler(simulatedEvent);\n    });\n    return simulatedEvent.isStopped();\n  };\n  var triggerUntilStopped = function triggerUntilStopped(lookup, eventType, rawEvent, logger) {\n    return triggerOnUntilStopped(lookup, eventType, rawEvent, rawEvent.target, logger);\n  };\n  var triggerOnUntilStopped = function triggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, logger) {\n    var source = derive(rawEvent, rawTarget);\n    return doTriggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, source, logger);\n  };\n  var eventHandler = function eventHandler(element, descHandler) {\n    return {\n      element: element,\n      descHandler: descHandler\n    };\n  };\n  var broadcastHandler = function broadcastHandler(id, handler) {\n    return {\n      id: id,\n      descHandler: handler\n    };\n  };\n  var EventRegistry = function EventRegistry() {\n    var registry = {};\n    var registerId = function registerId(extraArgs, id, events) {\n      each(events, function (v, k) {\n        var handlers = registry[k] !== undefined ? registry[k] : {};\n        handlers[id] = curryArgs(v, extraArgs);\n        registry[k] = handlers;\n      });\n    };\n    var findHandler = function findHandler(handlers, elem) {\n      return read$1(elem).bind(function (id) {\n        return get$g(handlers, id);\n      }).map(function (descHandler) {\n        return eventHandler(elem, descHandler);\n      });\n    };\n    var filterByType = function filterByType(type) {\n      return get$g(registry, type).map(function (handlers) {\n        return mapToArray(handlers, function (f, id) {\n          return broadcastHandler(id, f);\n        });\n      }).getOr([]);\n    };\n    var find = function find(isAboveRoot, type, target) {\n      return get$g(registry, type).bind(function (handlers) {\n        return closest$4(target, function (elem) {\n          return findHandler(handlers, elem);\n        }, isAboveRoot);\n      });\n    };\n    var unregisterId = function unregisterId(id) {\n      each(registry, function (handlersById, _eventName) {\n        if (has$2(handlersById, id)) {\n          delete handlersById[id];\n        }\n      });\n    };\n    return {\n      registerId: registerId,\n      unregisterId: unregisterId,\n      filterByType: filterByType,\n      find: find\n    };\n  };\n  var Registry = function Registry() {\n    var events = EventRegistry();\n    var components = {};\n    var readOrTag = function readOrTag(component) {\n      var elem = component.element;\n      return read$1(elem).getOrThunk(function () {\n        return write('uid-', component.element);\n      });\n    };\n    var failOnDuplicate = function failOnDuplicate(component, tagId) {\n      var conflict = components[tagId];\n      if (conflict === component) {\n        unregister(component);\n      } else {\n        throw new Error('The tagId \"' + tagId + '\" is already used by: ' + element(conflict.element) + '\\nCannot use it for: ' + element(component.element) + '\\n' + 'The conflicting element is' + (inBody(conflict.element) ? ' ' : ' not ') + 'already in the DOM');\n      }\n    };\n    var register = function register(component) {\n      var tagId = readOrTag(component);\n      if (hasNonNullableKey(components, tagId)) {\n        failOnDuplicate(component, tagId);\n      }\n      var extraArgs = [component];\n      events.registerId(extraArgs, tagId, component.events);\n      components[tagId] = component;\n    };\n    var unregister = function unregister(component) {\n      read$1(component.element).each(function (tagId) {\n        delete components[tagId];\n        events.unregisterId(tagId);\n      });\n    };\n    var filter = function filter(type) {\n      return events.filterByType(type);\n    };\n    var find = function find(isAboveRoot, type, target) {\n      return events.find(isAboveRoot, type, target);\n    };\n    var getById = function getById(id) {\n      return get$g(components, id);\n    };\n    return {\n      find: find,\n      filter: filter,\n      register: register,\n      unregister: unregister,\n      getById: getById\n    };\n  };\n  var factory$j = function factory$j(detail) {\n    var _detail$dom = detail.dom,\n      attributes = _detail$dom.attributes,\n      domWithoutAttributes = _objectWithoutProperties(_detail$dom, [\"attributes\"]);\n    return {\n      uid: detail.uid,\n      dom: _objectSpread({\n        tag: 'div',\n        attributes: _objectSpread({\n          role: 'presentation'\n        }, attributes)\n      }, domWithoutAttributes),\n      components: detail.components,\n      behaviours: get$3(detail.containerBehaviours),\n      events: detail.events,\n      domModification: detail.domModification,\n      eventOrder: detail.eventOrder\n    };\n  };\n  var Container = single({\n    name: 'Container',\n    factory: factory$j,\n    configFields: [defaulted('components', []), field('containerBehaviours', []), defaulted('events', {}), defaulted('domModification', {}), defaulted('eventOrder', {})]\n  });\n  var takeover = function takeover(root) {\n    var isAboveRoot = function isAboveRoot(el) {\n      return parent(root.element).fold(always, function (parent) {\n        return eq(el, parent);\n      });\n    };\n    var registry = Registry();\n    var lookup = function lookup(eventName, target) {\n      return registry.find(isAboveRoot, eventName, target);\n    };\n    var domEvents = setup$d(root.element, {\n      triggerEvent: function triggerEvent(eventName, event) {\n        return monitorEvent(eventName, event.target, function (logger) {\n          return triggerUntilStopped(lookup, eventName, event, logger);\n        });\n      }\n    });\n    var systemApi = {\n      debugInfo: constant$1('real'),\n      triggerEvent: function triggerEvent(eventName, target, data) {\n        monitorEvent(eventName, target, function (logger) {\n          return triggerOnUntilStopped(lookup, eventName, data, target, logger);\n        });\n      },\n      triggerFocus: function triggerFocus(target, originator) {\n        read$1(target).fold(function () {\n          focus$3(target);\n        }, function (_alloyId) {\n          monitorEvent(focus$4(), target, function (logger) {\n            triggerHandler(lookup, focus$4(), {\n              originator: originator,\n              kill: noop,\n              prevent: noop,\n              target: target\n            }, target, logger);\n            return false;\n          });\n        });\n      },\n      triggerEscape: function triggerEscape(comp, simulatedEvent) {\n        systemApi.triggerEvent('keydown', comp.element, simulatedEvent.event);\n      },\n      getByUid: function getByUid(uid) {\n        return _getByUid(uid);\n      },\n      getByDom: function getByDom(elem) {\n        return _getByDom(elem);\n      },\n      build: build$1,\n      buildOrPatch: buildOrPatch,\n      addToGui: function addToGui(c) {\n        add(c);\n      },\n      removeFromGui: function removeFromGui(c) {\n        remove(c);\n      },\n      addToWorld: function addToWorld(c) {\n        _addToWorld(c);\n      },\n      removeFromWorld: function removeFromWorld(c) {\n        _removeFromWorld(c);\n      },\n      broadcast: function broadcast(message) {\n        broadcast$1(message);\n      },\n      broadcastOn: function broadcastOn(channels, message) {\n        _broadcastOn(channels, message);\n      },\n      broadcastEvent: function broadcastEvent(eventName, event) {\n        _broadcastEvent(eventName, event);\n      },\n      isConnected: always\n    };\n    var _addToWorld = function _addToWorld(component) {\n      component.connect(systemApi);\n      if (!isText(component.element)) {\n        registry.register(component);\n        each$1(component.components(), _addToWorld);\n        systemApi.triggerEvent(systemInit(), component.element, {\n          target: component.element\n        });\n      }\n    };\n    var _removeFromWorld = function _removeFromWorld(component) {\n      if (!isText(component.element)) {\n        each$1(component.components(), _removeFromWorld);\n        registry.unregister(component);\n      }\n      component.disconnect();\n    };\n    var add = function add(component) {\n      attach(root, component);\n    };\n    var remove = function remove(component) {\n      detach(component);\n    };\n    var destroy = function destroy() {\n      domEvents.unbind();\n      remove$5(root.element);\n    };\n    var broadcastData = function broadcastData(data) {\n      var receivers = registry.filter(receive());\n      each$1(receivers, function (receiver) {\n        var descHandler = receiver.descHandler;\n        var handler = getCurried(descHandler);\n        handler(data);\n      });\n    };\n    var broadcast$1 = function broadcast$1(message) {\n      broadcastData({\n        universal: true,\n        data: message\n      });\n    };\n    var _broadcastOn = function _broadcastOn(channels, message) {\n      broadcastData({\n        universal: false,\n        channels: channels,\n        data: message\n      });\n    };\n    var _broadcastEvent = function _broadcastEvent(eventName, event) {\n      var listeners = registry.filter(eventName);\n      return broadcast(listeners, event);\n    };\n    var _getByUid = function _getByUid(uid) {\n      return registry.getById(uid).fold(function () {\n        return Result.error(new Error('Could not find component with uid: \"' + uid + '\" in system.'));\n      }, Result.value);\n    };\n    var _getByDom = function _getByDom(elem) {\n      var uid = read$1(elem).getOr('not found');\n      return _getByUid(uid);\n    };\n    _addToWorld(root);\n    return {\n      root: root,\n      element: root.element,\n      destroy: destroy,\n      add: add,\n      remove: remove,\n      getByUid: _getByUid,\n      getByDom: _getByDom,\n      addToWorld: _addToWorld,\n      removeFromWorld: _removeFromWorld,\n      broadcast: broadcast$1,\n      broadcastOn: _broadcastOn,\n      broadcastEvent: _broadcastEvent\n    };\n  };\n  var renderBar = function renderBar(spec, backstage) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-bar', 'tox-form__controls-h-stack']\n      },\n      components: map$2(spec.items, backstage.interpreter)\n    };\n  };\n  var schema$j = constant$1([defaulted('prefix', 'form-field'), field('fieldBehaviours', [Composing, Representing])]);\n  var parts$d = constant$1([optional({\n    schema: [required$1('dom')],\n    name: 'label'\n  }), optional({\n    factory: {\n      sketch: function sketch(spec) {\n        return {\n          uid: spec.uid,\n          dom: {\n            tag: 'span',\n            styles: {\n              display: 'none'\n            },\n            attributes: {\n              'aria-hidden': 'true'\n            },\n            innerHtml: spec.text\n          }\n        };\n      }\n    },\n    schema: [required$1('text')],\n    name: 'aria-descriptor'\n  }), required({\n    factory: {\n      sketch: function sketch(spec) {\n        var excludeFactory = exclude(spec, ['factory']);\n        return spec.factory.sketch(excludeFactory);\n      }\n    },\n    schema: [required$1('factory')],\n    name: 'field'\n  })]);\n  var factory$i = function factory$i(detail, components, _spec, _externals) {\n    var behaviours = augment(detail.fieldBehaviours, [Composing.config({\n      find: function find(container) {\n        return getPart(container, detail, 'field');\n      }\n    }), Representing.config({\n      store: {\n        mode: 'manual',\n        getValue: function getValue(field) {\n          return Composing.getCurrent(field).bind(Representing.getValue);\n        },\n        setValue: function setValue(field, value) {\n          Composing.getCurrent(field).each(function (current) {\n            Representing.setValue(current, value);\n          });\n        }\n      }\n    })]);\n    var events = derive$2([runOnAttached(function (component, _simulatedEvent) {\n      var ps = getParts(component, detail, ['label', 'field', 'aria-descriptor']);\n      ps.field().each(function (field) {\n        var id = generate$6(detail.prefix);\n        ps.label().each(function (label) {\n          set$9(label.element, 'for', id);\n          set$9(field.element, 'id', id);\n        });\n        ps['aria-descriptor']().each(function (descriptor) {\n          var descriptorId = generate$6(detail.prefix);\n          set$9(descriptor.element, 'id', descriptorId);\n          set$9(field.element, 'aria-describedby', descriptorId);\n        });\n      });\n    })]);\n    var apis = {\n      getField: function getField(container) {\n        return getPart(container, detail, 'field');\n      },\n      getLabel: function getLabel(container) {\n        return getPart(container, detail, 'label');\n      }\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      behaviours: behaviours,\n      events: events,\n      apis: apis\n    };\n  };\n  var FormField = composite({\n    name: 'FormField',\n    configFields: schema$j(),\n    partFields: parts$d(),\n    factory: factory$i,\n    apis: {\n      getField: function getField(apis, comp) {\n        return apis.getField(comp);\n      },\n      getLabel: function getLabel(apis, comp) {\n        return apis.getLabel(comp);\n      }\n    }\n  });\n  var exhibit$2 = function exhibit$2(base, tabConfig) {\n    return nu$7({\n      attributes: wrapAll([{\n        key: tabConfig.tabAttr,\n        value: 'true'\n      }])\n    });\n  };\n  var ActiveTabstopping = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    exhibit: exhibit$2\n  });\n  var TabstopSchema = [defaulted('tabAttr', 'data-alloy-tabstop')];\n  var Tabstopping = create$4({\n    fields: TabstopSchema,\n    name: 'tabstopping',\n    active: ActiveTabstopping\n  });\n  var global$3 = tinymce.util.Tools.resolve('tinymce.html.Entities');\n  var renderFormFieldWith = function renderFormFieldWith(pLabel, pField, extraClasses, extraBehaviours) {\n    var spec = renderFormFieldSpecWith(pLabel, pField, extraClasses, extraBehaviours);\n    return FormField.sketch(spec);\n  };\n  var renderFormField = function renderFormField(pLabel, pField) {\n    return renderFormFieldWith(pLabel, pField, [], []);\n  };\n  var renderFormFieldSpecWith = function renderFormFieldSpecWith(pLabel, pField, extraClasses, extraBehaviours) {\n    return {\n      dom: renderFormFieldDomWith(extraClasses),\n      components: pLabel.toArray().concat([pField]),\n      fieldBehaviours: derive$1(extraBehaviours)\n    };\n  };\n  var renderFormFieldDom = function renderFormFieldDom() {\n    return renderFormFieldDomWith([]);\n  };\n  var renderFormFieldDomWith = function renderFormFieldDomWith(extraClasses) {\n    return {\n      tag: 'div',\n      classes: ['tox-form__group'].concat(extraClasses)\n    };\n  };\n  var renderLabel$3 = function renderLabel$3(label, providersBackstage) {\n    return FormField.parts.label({\n      dom: {\n        tag: 'label',\n        classes: ['tox-label']\n      },\n      components: [text$2(providersBackstage.translate(label))]\n    });\n  };\n  var formChangeEvent = generate$6('form-component-change');\n  var formCloseEvent = generate$6('form-close');\n  var formCancelEvent = generate$6('form-cancel');\n  var formActionEvent = generate$6('form-action');\n  var formSubmitEvent = generate$6('form-submit');\n  var formBlockEvent = generate$6('form-block');\n  var formUnblockEvent = generate$6('form-unblock');\n  var formTabChangeEvent = generate$6('form-tabchange');\n  var formResizeEvent = generate$6('form-resize');\n  var renderCollection = function renderCollection(spec, providersBackstage, initialData) {\n    var pLabel = spec.label.map(function (label) {\n      return renderLabel$3(label, providersBackstage);\n    });\n    var icons = providersBackstage.icons();\n    var getIcon = function getIcon(icon) {\n      var _a;\n      return (_a = icons[icon]) !== null && _a !== void 0 ? _a : icon;\n    };\n    var runOnItem = function runOnItem(f) {\n      return function (comp, se) {\n        closest$1(se.event.target, '[data-collection-item-value]').each(function (target) {\n          f(comp, se, target, get$f(target, 'data-collection-item-value'));\n        });\n      };\n    };\n    var setContents = function setContents(comp, items) {\n      var htmlLines = map$2(items, function (item) {\n        var itemText = global$8.translate(item.text);\n        var textContent = spec.columns === 1 ? \"<div class=\\\"tox-collection__item-label\\\">\".concat(itemText, \"</div>\") : '';\n        var iconContent = \"<div class=\\\"tox-collection__item-icon\\\">\".concat(getIcon(item.icon), \"</div>\");\n        var mapItemName = {\n          '_': ' ',\n          ' - ': ' ',\n          '-': ' '\n        };\n        var ariaLabel = itemText.replace(/\\_| \\- |\\-/g, function (match) {\n          return mapItemName[match];\n        });\n        var disabledClass = providersBackstage.isDisabled() ? ' tox-collection__item--state-disabled' : '';\n        return \"<div class=\\\"tox-collection__item\".concat(disabledClass, \"\\\" tabindex=\\\"-1\\\" data-collection-item-value=\\\"\").concat(global$3.encodeAllRaw(item.value), \"\\\" title=\\\"\").concat(ariaLabel, \"\\\" aria-label=\\\"\").concat(ariaLabel, \"\\\">\").concat(iconContent).concat(textContent, \"</div>\");\n      });\n      var chunks = spec.columns !== 'auto' && spec.columns > 1 ? chunk$1(htmlLines, spec.columns) : [htmlLines];\n      var html = map$2(chunks, function (ch) {\n        return \"<div class=\\\"tox-collection__group\\\">\".concat(ch.join(''), \"</div>\");\n      });\n      set$6(comp.element, html.join(''));\n    };\n    var onClick = runOnItem(function (comp, se, tgt, itemValue) {\n      se.stop();\n      if (!providersBackstage.isDisabled()) {\n        emitWith(comp, formActionEvent, {\n          name: spec.name,\n          value: itemValue\n        });\n      }\n    });\n    var collectionEvents = [run$1(mouseover(), runOnItem(function (comp, se, tgt) {\n      focus$3(tgt);\n    })), run$1(click(), onClick), run$1(tap(), onClick), run$1(focusin(), runOnItem(function (comp, se, tgt) {\n      descendant(comp.element, '.' + activeClass).each(function (currentActive) {\n        remove$2(currentActive, activeClass);\n      });\n      add$2(tgt, activeClass);\n    })), run$1(focusout(), runOnItem(function (comp) {\n      descendant(comp.element, '.' + activeClass).each(function (currentActive) {\n        remove$2(currentActive, activeClass);\n      });\n    })), runOnExecute$1(runOnItem(function (comp, se, tgt, itemValue) {\n      emitWith(comp, formActionEvent, {\n        name: spec.name,\n        value: itemValue\n      });\n    }))];\n    var iterCollectionItems = function iterCollectionItems(comp, applyAttributes) {\n      return map$2(descendants(comp.element, '.tox-collection__item'), applyAttributes);\n    };\n    var pField = FormField.parts.field({\n      dom: {\n        tag: 'div',\n        classes: ['tox-collection'].concat(spec.columns !== 1 ? ['tox-collection--grid'] : ['tox-collection--list'])\n      },\n      components: [],\n      factory: {\n        sketch: identity\n      },\n      behaviours: derive$1([Disabling.config({\n        disabled: providersBackstage.isDisabled,\n        onDisabled: function onDisabled(comp) {\n          iterCollectionItems(comp, function (childElm) {\n            add$2(childElm, 'tox-collection__item--state-disabled');\n            set$9(childElm, 'aria-disabled', true);\n          });\n        },\n        onEnabled: function onEnabled(comp) {\n          iterCollectionItems(comp, function (childElm) {\n            remove$2(childElm, 'tox-collection__item--state-disabled');\n            remove$7(childElm, 'aria-disabled');\n          });\n        }\n      }), receivingConfig(), Replacing.config({}), Representing.config({\n        store: {\n          mode: 'memory',\n          initialValue: initialData.getOr([])\n        },\n        onSetValue: function onSetValue(comp, items) {\n          setContents(comp, items);\n          if (spec.columns === 'auto') {\n            detectSize(comp, 5, 'tox-collection__item').each(function (_ref9) {\n              var numRows = _ref9.numRows,\n                numColumns = _ref9.numColumns;\n              Keying.setGridSize(comp, numRows, numColumns);\n            });\n          }\n          emit(comp, formResizeEvent);\n        }\n      }), Tabstopping.config({}), Keying.config(deriveCollectionMovement(spec.columns, 'normal')), config('collection-events', collectionEvents)]),\n      eventOrder: _defineProperty({}, execute$5(), ['disabling', 'alloy.base.behaviour', 'collection-events'])\n    });\n    var extraClasses = ['tox-form__group--collection'];\n    return renderFormFieldWith(pLabel, pField, extraClasses, []);\n  };\n  var ariaElements = ['input', 'textarea'];\n  var isAriaElement = function isAriaElement(elem) {\n    var name = name$3(elem);\n    return contains$2(ariaElements, name);\n  };\n  var markValid = function markValid(component, invalidConfig) {\n    var elem = invalidConfig.getRoot(component).getOr(component.element);\n    remove$2(elem, invalidConfig.invalidClass);\n    invalidConfig.notify.each(function (notifyInfo) {\n      if (isAriaElement(component.element)) {\n        set$9(component.element, 'aria-invalid', false);\n      }\n      notifyInfo.getContainer(component).each(function (container) {\n        set$6(container, notifyInfo.validHtml);\n      });\n      notifyInfo.onValid(component);\n    });\n  };\n  var markInvalid = function markInvalid(component, invalidConfig, invalidState, text) {\n    var elem = invalidConfig.getRoot(component).getOr(component.element);\n    add$2(elem, invalidConfig.invalidClass);\n    invalidConfig.notify.each(function (notifyInfo) {\n      if (isAriaElement(component.element)) {\n        set$9(component.element, 'aria-invalid', true);\n      }\n      notifyInfo.getContainer(component).each(function (container) {\n        set$6(container, text);\n      });\n      notifyInfo.onInvalid(component, text);\n    });\n  };\n  var query = function query(component, invalidConfig, _invalidState) {\n    return invalidConfig.validator.fold(function () {\n      return Future.pure(Result.value(true));\n    }, function (validatorInfo) {\n      return validatorInfo.validate(component);\n    });\n  };\n  var run = function run(component, invalidConfig, invalidState) {\n    invalidConfig.notify.each(function (notifyInfo) {\n      notifyInfo.onValidate(component);\n    });\n    return query(component, invalidConfig).map(function (valid) {\n      if (component.getSystem().isConnected()) {\n        return valid.fold(function (err) {\n          markInvalid(component, invalidConfig, invalidState, err);\n          return Result.error(err);\n        }, function (v) {\n          markValid(component, invalidConfig);\n          return Result.value(v);\n        });\n      } else {\n        return Result.error('No longer in system');\n      }\n    });\n  };\n  var isInvalid = function isInvalid(component, invalidConfig) {\n    var elem = invalidConfig.getRoot(component).getOr(component.element);\n    return has(elem, invalidConfig.invalidClass);\n  };\n  var InvalidateApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    markValid: markValid,\n    markInvalid: markInvalid,\n    query: query,\n    run: run,\n    isInvalid: isInvalid\n  });\n  var events$8 = function events$8(invalidConfig, invalidState) {\n    return invalidConfig.validator.map(function (validatorInfo) {\n      return derive$2([run$1(validatorInfo.onEvent, function (component) {\n        run(component, invalidConfig, invalidState).get(identity);\n      })].concat(validatorInfo.validateOnLoad ? [runOnAttached(function (component) {\n        run(component, invalidConfig, invalidState).get(noop);\n      })] : []));\n    }).getOr({});\n  };\n  var ActiveInvalidate = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    events: events$8\n  });\n  var InvalidateSchema = [required$1('invalidClass'), defaulted('getRoot', Optional.none), optionObjOf('notify', [defaulted('aria', 'alert'), defaulted('getContainer', Optional.none), defaulted('validHtml', ''), onHandler('onValid'), onHandler('onInvalid'), onHandler('onValidate')]), optionObjOf('validator', [required$1('validate'), defaulted('onEvent', 'input'), defaulted('validateOnLoad', true)])];\n  var Invalidating = create$4({\n    fields: InvalidateSchema,\n    name: 'invalidating',\n    active: ActiveInvalidate,\n    apis: InvalidateApis,\n    extra: {\n      validation: function validation(validator) {\n        return function (component) {\n          var v = Representing.getValue(component);\n          return Future.pure(validator(v));\n        };\n      }\n    }\n  });\n  var exhibit$1 = function exhibit$1() {\n    return nu$7({\n      styles: {\n        '-webkit-user-select': 'none',\n        'user-select': 'none',\n        '-ms-user-select': 'none',\n        '-moz-user-select': '-moz-none'\n      },\n      attributes: {\n        unselectable: 'on'\n      }\n    });\n  };\n  var events$7 = function events$7() {\n    return derive$2([abort(selectstart(), always)]);\n  };\n  var ActiveUnselecting = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    events: events$7,\n    exhibit: exhibit$1\n  });\n  var Unselecting = create$4({\n    fields: [],\n    name: 'unselecting',\n    active: ActiveUnselecting\n  });\n  var renderPanelButton = function renderPanelButton(spec, sharedBackstage) {\n    return Dropdown.sketch({\n      dom: spec.dom,\n      components: spec.components,\n      toggleClass: 'mce-active',\n      dropdownBehaviours: derive$1([DisablingConfigs.button(sharedBackstage.providers.isDisabled), receivingConfig(), Unselecting.config({}), Tabstopping.config({})]),\n      layouts: spec.layouts,\n      sandboxClasses: ['tox-dialog__popups'],\n      lazySink: sharedBackstage.getSink,\n      fetch: function fetch(comp) {\n        return Future.nu(function (callback) {\n          return spec.fetch(callback);\n        }).map(function (items) {\n          return Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, function (value) {\n            spec.onItemAction(comp, value);\n          }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, never, sharedBackstage.providers), {\n            movement: deriveMenuMovement(spec.columns, spec.presets)\n          })));\n        });\n      },\n      parts: {\n        menu: part(false, 1, spec.presets)\n      }\n    });\n  };\n  var colorInputChangeEvent = generate$6('color-input-change');\n  var colorSwatchChangeEvent = generate$6('color-swatch-change');\n  var colorPickerCancelEvent = generate$6('color-picker-cancel');\n  var renderColorInput = function renderColorInput(spec, sharedBackstage, colorInputBackstage, initialData) {\n    var pField = FormField.parts.field({\n      factory: Input,\n      inputClasses: ['tox-textfield'],\n      data: initialData,\n      onSetValue: function onSetValue(c) {\n        return Invalidating.run(c).get(noop);\n      },\n      inputBehaviours: derive$1([Disabling.config({\n        disabled: sharedBackstage.providers.isDisabled\n      }), receivingConfig(), Tabstopping.config({}), Invalidating.config({\n        invalidClass: 'tox-textbox-field-invalid',\n        getRoot: function getRoot(comp) {\n          return parentElement(comp.element);\n        },\n        notify: {\n          onValid: function onValid(comp) {\n            var val = Representing.getValue(comp);\n            emitWith(comp, colorInputChangeEvent, {\n              color: val\n            });\n          }\n        },\n        validator: {\n          validateOnLoad: false,\n          validate: function validate(input) {\n            var inputValue = Representing.getValue(input);\n            if (inputValue.length === 0) {\n              return Future.pure(Result.value(true));\n            } else {\n              var span = SugarElement.fromTag('span');\n              set$8(span, 'background-color', inputValue);\n              var res = getRaw(span, 'background-color').fold(function () {\n                return Result.error('blah');\n              }, function (_) {\n                return Result.value(inputValue);\n              });\n              return Future.pure(res);\n            }\n          }\n        }\n      })]),\n      selectOnFocus: false\n    });\n    var pLabel = spec.label.map(function (label) {\n      return renderLabel$3(label, sharedBackstage.providers);\n    });\n    var emitSwatchChange = function emitSwatchChange(colorBit, value) {\n      emitWith(colorBit, colorSwatchChangeEvent, {\n        value: value\n      });\n    };\n    var onItemAction = function onItemAction(comp, value) {\n      memColorButton.getOpt(comp).each(function (colorBit) {\n        if (value === 'custom') {\n          colorInputBackstage.colorPicker(function (valueOpt) {\n            valueOpt.fold(function () {\n              return emit(colorBit, colorPickerCancelEvent);\n            }, function (value) {\n              emitSwatchChange(colorBit, value);\n              addColor(spec.storageKey, value);\n            });\n          }, '#ffffff');\n        } else if (value === 'remove') {\n          emitSwatchChange(colorBit, '');\n        } else {\n          emitSwatchChange(colorBit, value);\n        }\n      });\n    };\n    var memColorButton = record(renderPanelButton({\n      dom: {\n        tag: 'span',\n        attributes: {\n          'aria-label': sharedBackstage.providers.translate('Color swatch')\n        }\n      },\n      layouts: {\n        onRtl: function onRtl() {\n          return [southwest$2, southeast$2, south$2];\n        },\n        onLtr: function onLtr() {\n          return [southeast$2, southwest$2, south$2];\n        }\n      },\n      components: [],\n      fetch: getFetch$1(colorInputBackstage.getColors(spec.storageKey), spec.storageKey, colorInputBackstage.hasCustomColors()),\n      columns: colorInputBackstage.getColorCols(spec.storageKey),\n      presets: 'color',\n      onItemAction: onItemAction\n    }, sharedBackstage));\n    return FormField.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-form__group']\n      },\n      components: pLabel.toArray().concat([{\n        dom: {\n          tag: 'div',\n          classes: ['tox-color-input']\n        },\n        components: [pField, memColorButton.asSpec()]\n      }]),\n      fieldBehaviours: derive$1([config('form-field-events', [run$1(colorInputChangeEvent, function (comp, se) {\n        memColorButton.getOpt(comp).each(function (colorButton) {\n          set$8(colorButton.element, 'background-color', se.event.color);\n        });\n        emitWith(comp, formChangeEvent, {\n          name: spec.name\n        });\n      }), run$1(colorSwatchChangeEvent, function (comp, se) {\n        FormField.getField(comp).each(function (field) {\n          Representing.setValue(field, se.event.value);\n          Composing.getCurrent(comp).each(Focusing.focus);\n        });\n      }), run$1(colorPickerCancelEvent, function (comp, _se) {\n        FormField.getField(comp).each(function (_field) {\n          Composing.getCurrent(comp).each(Focusing.focus);\n        });\n      })])])\n    });\n  };\n  var labelPart = optional({\n    schema: [required$1('dom')],\n    name: 'label'\n  });\n  var edgePart = function edgePart(name) {\n    return optional({\n      name: '' + name + '-edge',\n      overrides: function overrides(detail) {\n        var action = detail.model.manager.edgeActions[name];\n        return action.fold(function () {\n          return {};\n        }, function (a) {\n          return {\n            events: derive$2([runActionExtra(touchstart(), function (comp, se, d) {\n              return a(comp, d);\n            }, [detail]), runActionExtra(mousedown(), function (comp, se, d) {\n              return a(comp, d);\n            }, [detail]), runActionExtra(mousemove(), function (comp, se, det) {\n              if (det.mouseIsDown.get()) {\n                a(comp, det);\n              }\n            }, [detail])])\n          };\n        });\n      }\n    });\n  };\n  var tlEdgePart = edgePart('top-left');\n  var tedgePart = edgePart('top');\n  var trEdgePart = edgePart('top-right');\n  var redgePart = edgePart('right');\n  var brEdgePart = edgePart('bottom-right');\n  var bedgePart = edgePart('bottom');\n  var blEdgePart = edgePart('bottom-left');\n  var ledgePart = edgePart('left');\n  var thumbPart = required({\n    name: 'thumb',\n    defaults: constant$1({\n      dom: {\n        styles: {\n          position: 'absolute'\n        }\n      }\n    }),\n    overrides: function overrides(detail) {\n      return {\n        events: derive$2([redirectToPart(touchstart(), detail, 'spectrum'), redirectToPart(touchmove(), detail, 'spectrum'), redirectToPart(touchend(), detail, 'spectrum'), redirectToPart(mousedown(), detail, 'spectrum'), redirectToPart(mousemove(), detail, 'spectrum'), redirectToPart(mouseup(), detail, 'spectrum')])\n      };\n    }\n  });\n  var spectrumPart = required({\n    schema: [customField('mouseIsDown', function () {\n      return Cell(false);\n    })],\n    name: 'spectrum',\n    overrides: function overrides(detail) {\n      var modelDetail = detail.model;\n      var model = modelDetail.manager;\n      var setValueFrom = function setValueFrom(component, simulatedEvent) {\n        return model.getValueFromEvent(simulatedEvent).map(function (value) {\n          return model.setValueFrom(component, detail, value);\n        });\n      };\n      return {\n        behaviours: derive$1([Keying.config({\n          mode: 'special',\n          onLeft: function onLeft(spectrum) {\n            return model.onLeft(spectrum, detail);\n          },\n          onRight: function onRight(spectrum) {\n            return model.onRight(spectrum, detail);\n          },\n          onUp: function onUp(spectrum) {\n            return model.onUp(spectrum, detail);\n          },\n          onDown: function onDown(spectrum) {\n            return model.onDown(spectrum, detail);\n          }\n        }), Focusing.config({})]),\n        events: derive$2([run$1(touchstart(), setValueFrom), run$1(touchmove(), setValueFrom), run$1(mousedown(), setValueFrom), run$1(mousemove(), function (spectrum, se) {\n          if (detail.mouseIsDown.get()) {\n            setValueFrom(spectrum, se);\n          }\n        })])\n      };\n    }\n  });\n  var SliderParts = [labelPart, ledgePart, redgePart, tedgePart, bedgePart, tlEdgePart, trEdgePart, blEdgePart, brEdgePart, thumbPart, spectrumPart];\n  var _sliderChangeEvent = 'slider.change.value';\n  var sliderChangeEvent = constant$1(_sliderChangeEvent);\n  var isTouchEvent$2 = function isTouchEvent$2(evt) {\n    return evt.type.indexOf('touch') !== -1;\n  };\n  var getEventSource = function getEventSource(simulatedEvent) {\n    var evt = simulatedEvent.event.raw;\n    if (isTouchEvent$2(evt)) {\n      var touchEvent = evt;\n      return touchEvent.touches !== undefined && touchEvent.touches.length === 1 ? Optional.some(touchEvent.touches[0]).map(function (t) {\n        return SugarPosition(t.clientX, t.clientY);\n      }) : Optional.none();\n    } else {\n      var mouseEvent = evt;\n      return mouseEvent.clientX !== undefined ? Optional.some(mouseEvent).map(function (me) {\n        return SugarPosition(me.clientX, me.clientY);\n      }) : Optional.none();\n    }\n  };\n  var t = 'top',\n    r = 'right',\n    b = 'bottom',\n    l = 'left';\n  var minX = function minX(detail) {\n    return detail.model.minX;\n  };\n  var minY = function minY(detail) {\n    return detail.model.minY;\n  };\n  var min1X = function min1X(detail) {\n    return detail.model.minX - 1;\n  };\n  var min1Y = function min1Y(detail) {\n    return detail.model.minY - 1;\n  };\n  var maxX = function maxX(detail) {\n    return detail.model.maxX;\n  };\n  var maxY = function maxY(detail) {\n    return detail.model.maxY;\n  };\n  var max1X = function max1X(detail) {\n    return detail.model.maxX + 1;\n  };\n  var max1Y = function max1Y(detail) {\n    return detail.model.maxY + 1;\n  };\n  var range = function range(detail, max, min) {\n    return max(detail) - min(detail);\n  };\n  var xRange = function xRange(detail) {\n    return range(detail, maxX, minX);\n  };\n  var yRange = function yRange(detail) {\n    return range(detail, maxY, minY);\n  };\n  var halfX = function halfX(detail) {\n    return xRange(detail) / 2;\n  };\n  var halfY = function halfY(detail) {\n    return yRange(detail) / 2;\n  };\n  var step = function step(detail) {\n    return detail.stepSize;\n  };\n  var snap = function snap(detail) {\n    return detail.snapToGrid;\n  };\n  var snapStart = function snapStart(detail) {\n    return detail.snapStart;\n  };\n  var rounded = function rounded(detail) {\n    return detail.rounded;\n  };\n  var hasEdge = function hasEdge(detail, edgeName) {\n    return detail[edgeName + '-edge'] !== undefined;\n  };\n  var hasLEdge = function hasLEdge(detail) {\n    return hasEdge(detail, l);\n  };\n  var hasREdge = function hasREdge(detail) {\n    return hasEdge(detail, r);\n  };\n  var hasTEdge = function hasTEdge(detail) {\n    return hasEdge(detail, t);\n  };\n  var hasBEdge = function hasBEdge(detail) {\n    return hasEdge(detail, b);\n  };\n  var currentValue = function currentValue(detail) {\n    return detail.model.value.get();\n  };\n  var xyValue = function xyValue(x, y) {\n    return {\n      x: x,\n      y: y\n    };\n  };\n  var fireSliderChange$3 = function fireSliderChange$3(component, value) {\n    emitWith(component, sliderChangeEvent(), {\n      value: value\n    });\n  };\n  var setToTLEdgeXY = function setToTLEdgeXY(edge, detail) {\n    fireSliderChange$3(edge, xyValue(min1X(detail), min1Y(detail)));\n  };\n  var setToTEdge = function setToTEdge(edge, detail) {\n    fireSliderChange$3(edge, min1Y(detail));\n  };\n  var setToTEdgeXY = function setToTEdgeXY(edge, detail) {\n    fireSliderChange$3(edge, xyValue(halfX(detail), min1Y(detail)));\n  };\n  var setToTREdgeXY = function setToTREdgeXY(edge, detail) {\n    fireSliderChange$3(edge, xyValue(max1X(detail), min1Y(detail)));\n  };\n  var setToREdge = function setToREdge(edge, detail) {\n    fireSliderChange$3(edge, max1X(detail));\n  };\n  var setToREdgeXY = function setToREdgeXY(edge, detail) {\n    fireSliderChange$3(edge, xyValue(max1X(detail), halfY(detail)));\n  };\n  var setToBREdgeXY = function setToBREdgeXY(edge, detail) {\n    fireSliderChange$3(edge, xyValue(max1X(detail), max1Y(detail)));\n  };\n  var setToBEdge = function setToBEdge(edge, detail) {\n    fireSliderChange$3(edge, max1Y(detail));\n  };\n  var setToBEdgeXY = function setToBEdgeXY(edge, detail) {\n    fireSliderChange$3(edge, xyValue(halfX(detail), max1Y(detail)));\n  };\n  var setToBLEdgeXY = function setToBLEdgeXY(edge, detail) {\n    fireSliderChange$3(edge, xyValue(min1X(detail), max1Y(detail)));\n  };\n  var setToLEdge = function setToLEdge(edge, detail) {\n    fireSliderChange$3(edge, min1X(detail));\n  };\n  var setToLEdgeXY = function setToLEdgeXY(edge, detail) {\n    fireSliderChange$3(edge, xyValue(min1X(detail), halfY(detail)));\n  };\n  var reduceBy = function reduceBy(value, min, max, step) {\n    if (value < min) {\n      return value;\n    } else if (value > max) {\n      return max;\n    } else if (value === min) {\n      return min - 1;\n    } else {\n      return Math.max(min, value - step);\n    }\n  };\n  var increaseBy = function increaseBy(value, min, max, step) {\n    if (value > max) {\n      return value;\n    } else if (value < min) {\n      return min;\n    } else if (value === max) {\n      return max + 1;\n    } else {\n      return Math.min(max, value + step);\n    }\n  };\n  var capValue = function capValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n  };\n  var snapValueOf = function snapValueOf(value, min, max, step, snapStart) {\n    return snapStart.fold(function () {\n      var initValue = value - min;\n      var extraValue = Math.round(initValue / step) * step;\n      return capValue(min + extraValue, min - 1, max + 1);\n    }, function (start) {\n      var remainder = (value - start) % step;\n      var adjustment = Math.round(remainder / step);\n      var rawSteps = Math.floor((value - start) / step);\n      var maxSteps = Math.floor((max - start) / step);\n      var numSteps = Math.min(maxSteps, rawSteps + adjustment);\n      var r = start + numSteps * step;\n      return Math.max(start, r);\n    });\n  };\n  var findOffsetOf = function findOffsetOf(value, min, max) {\n    return Math.min(max, Math.max(value, min)) - min;\n  };\n  var findValueOf = function findValueOf(args) {\n    var min = args.min,\n      max = args.max,\n      range = args.range,\n      value = args.value,\n      step = args.step,\n      snap = args.snap,\n      snapStart = args.snapStart,\n      rounded = args.rounded,\n      hasMinEdge = args.hasMinEdge,\n      hasMaxEdge = args.hasMaxEdge,\n      minBound = args.minBound,\n      maxBound = args.maxBound,\n      screenRange = args.screenRange;\n    var capMin = hasMinEdge ? min - 1 : min;\n    var capMax = hasMaxEdge ? max + 1 : max;\n    if (value < minBound) {\n      return capMin;\n    } else if (value > maxBound) {\n      return capMax;\n    } else {\n      var _offset = findOffsetOf(value, minBound, maxBound);\n      var newValue = capValue(_offset / screenRange * range + min, capMin, capMax);\n      if (snap && newValue >= min && newValue <= max) {\n        return snapValueOf(newValue, min, max, step, snapStart);\n      } else if (rounded) {\n        return Math.round(newValue);\n      } else {\n        return newValue;\n      }\n    }\n  };\n  var findOffsetOfValue$2 = function findOffsetOfValue$2(args) {\n    var min = args.min,\n      max = args.max,\n      range = args.range,\n      value = args.value,\n      hasMinEdge = args.hasMinEdge,\n      hasMaxEdge = args.hasMaxEdge,\n      maxBound = args.maxBound,\n      maxOffset = args.maxOffset,\n      centerMinEdge = args.centerMinEdge,\n      centerMaxEdge = args.centerMaxEdge;\n    if (value < min) {\n      return hasMinEdge ? 0 : centerMinEdge;\n    } else if (value > max) {\n      return hasMaxEdge ? maxBound : centerMaxEdge;\n    } else {\n      return (value - min) / range * maxOffset;\n    }\n  };\n  var top = 'top',\n    right = 'right',\n    bottom = 'bottom',\n    left = 'left',\n    width = 'width',\n    height = 'height';\n  var getBounds = function getBounds(component) {\n    return component.element.dom.getBoundingClientRect();\n  };\n  var getBoundsProperty = function getBoundsProperty(bounds, property) {\n    return bounds[property];\n  };\n  var getMinXBounds = function getMinXBounds(component) {\n    var bounds = getBounds(component);\n    return getBoundsProperty(bounds, left);\n  };\n  var getMaxXBounds = function getMaxXBounds(component) {\n    var bounds = getBounds(component);\n    return getBoundsProperty(bounds, right);\n  };\n  var getMinYBounds = function getMinYBounds(component) {\n    var bounds = getBounds(component);\n    return getBoundsProperty(bounds, top);\n  };\n  var getMaxYBounds = function getMaxYBounds(component) {\n    var bounds = getBounds(component);\n    return getBoundsProperty(bounds, bottom);\n  };\n  var getXScreenRange = function getXScreenRange(component) {\n    var bounds = getBounds(component);\n    return getBoundsProperty(bounds, width);\n  };\n  var getYScreenRange = function getYScreenRange(component) {\n    var bounds = getBounds(component);\n    return getBoundsProperty(bounds, height);\n  };\n  var getCenterOffsetOf = function getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge) {\n    return (componentMinEdge + componentMaxEdge) / 2 - spectrumMinEdge;\n  };\n  var getXCenterOffSetOf = function getXCenterOffSetOf(component, spectrum) {\n    var componentBounds = getBounds(component);\n    var spectrumBounds = getBounds(spectrum);\n    var componentMinEdge = getBoundsProperty(componentBounds, left);\n    var componentMaxEdge = getBoundsProperty(componentBounds, right);\n    var spectrumMinEdge = getBoundsProperty(spectrumBounds, left);\n    return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);\n  };\n  var getYCenterOffSetOf = function getYCenterOffSetOf(component, spectrum) {\n    var componentBounds = getBounds(component);\n    var spectrumBounds = getBounds(spectrum);\n    var componentMinEdge = getBoundsProperty(componentBounds, top);\n    var componentMaxEdge = getBoundsProperty(componentBounds, bottom);\n    var spectrumMinEdge = getBoundsProperty(spectrumBounds, top);\n    return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);\n  };\n  var fireSliderChange$2 = function fireSliderChange$2(spectrum, value) {\n    emitWith(spectrum, sliderChangeEvent(), {\n      value: value\n    });\n  };\n  var findValueOfOffset$1 = function findValueOfOffset$1(spectrum, detail, left) {\n    var args = {\n      min: minX(detail),\n      max: maxX(detail),\n      range: xRange(detail),\n      value: left,\n      step: step(detail),\n      snap: snap(detail),\n      snapStart: snapStart(detail),\n      rounded: rounded(detail),\n      hasMinEdge: hasLEdge(detail),\n      hasMaxEdge: hasREdge(detail),\n      minBound: getMinXBounds(spectrum),\n      maxBound: getMaxXBounds(spectrum),\n      screenRange: getXScreenRange(spectrum)\n    };\n    return findValueOf(args);\n  };\n  var setValueFrom$2 = function setValueFrom$2(spectrum, detail, value) {\n    var xValue = findValueOfOffset$1(spectrum, detail, value);\n    var sliderVal = xValue;\n    fireSliderChange$2(spectrum, sliderVal);\n    return xValue;\n  };\n  var setToMin$2 = function setToMin$2(spectrum, detail) {\n    var min = minX(detail);\n    fireSliderChange$2(spectrum, min);\n  };\n  var setToMax$2 = function setToMax$2(spectrum, detail) {\n    var max = maxX(detail);\n    fireSliderChange$2(spectrum, max);\n  };\n  var moveBy$2 = function moveBy$2(direction, spectrum, detail) {\n    var f = direction > 0 ? increaseBy : reduceBy;\n    var xValue = f(currentValue(detail), minX(detail), maxX(detail), step(detail));\n    fireSliderChange$2(spectrum, xValue);\n    return Optional.some(xValue);\n  };\n  var handleMovement$2 = function handleMovement$2(direction) {\n    return function (spectrum, detail) {\n      return moveBy$2(direction, spectrum, detail).map(always);\n    };\n  };\n  var getValueFromEvent$2 = function getValueFromEvent$2(simulatedEvent) {\n    var pos = getEventSource(simulatedEvent);\n    return pos.map(function (p) {\n      return p.left;\n    });\n  };\n  var findOffsetOfValue$1 = function findOffsetOfValue$1(spectrum, detail, value, minEdge, maxEdge) {\n    var minOffset = 0;\n    var maxOffset = getXScreenRange(spectrum);\n    var centerMinEdge = minEdge.bind(function (edge) {\n      return Optional.some(getXCenterOffSetOf(edge, spectrum));\n    }).getOr(minOffset);\n    var centerMaxEdge = maxEdge.bind(function (edge) {\n      return Optional.some(getXCenterOffSetOf(edge, spectrum));\n    }).getOr(maxOffset);\n    var args = {\n      min: minX(detail),\n      max: maxX(detail),\n      range: xRange(detail),\n      value: value,\n      hasMinEdge: hasLEdge(detail),\n      hasMaxEdge: hasREdge(detail),\n      minBound: getMinXBounds(spectrum),\n      minOffset: minOffset,\n      maxBound: getMaxXBounds(spectrum),\n      maxOffset: maxOffset,\n      centerMinEdge: centerMinEdge,\n      centerMaxEdge: centerMaxEdge\n    };\n    return findOffsetOfValue$2(args);\n  };\n  var findPositionOfValue$1 = function findPositionOfValue$1(slider, spectrum, value, minEdge, maxEdge, detail) {\n    var offset = findOffsetOfValue$1(spectrum, detail, value, minEdge, maxEdge);\n    return getMinXBounds(spectrum) - getMinXBounds(slider) + offset;\n  };\n  var setPositionFromValue$2 = function setPositionFromValue$2(slider, thumb, detail, edges) {\n    var value = currentValue(detail);\n    var pos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);\n    var thumbRadius = get$c(thumb.element) / 2;\n    set$8(thumb.element, 'left', pos - thumbRadius + 'px');\n  };\n  var onLeft$2 = handleMovement$2(-1);\n  var onRight$2 = handleMovement$2(1);\n  var onUp$2 = Optional.none;\n  var onDown$2 = Optional.none;\n  var edgeActions$2 = {\n    'top-left': Optional.none(),\n    'top': Optional.none(),\n    'top-right': Optional.none(),\n    'right': Optional.some(setToREdge),\n    'bottom-right': Optional.none(),\n    'bottom': Optional.none(),\n    'bottom-left': Optional.none(),\n    'left': Optional.some(setToLEdge)\n  };\n  var HorizontalModel = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setValueFrom: setValueFrom$2,\n    setToMin: setToMin$2,\n    setToMax: setToMax$2,\n    findValueOfOffset: findValueOfOffset$1,\n    getValueFromEvent: getValueFromEvent$2,\n    findPositionOfValue: findPositionOfValue$1,\n    setPositionFromValue: setPositionFromValue$2,\n    onLeft: onLeft$2,\n    onRight: onRight$2,\n    onUp: onUp$2,\n    onDown: onDown$2,\n    edgeActions: edgeActions$2\n  });\n  var fireSliderChange$1 = function fireSliderChange$1(spectrum, value) {\n    emitWith(spectrum, sliderChangeEvent(), {\n      value: value\n    });\n  };\n  var findValueOfOffset = function findValueOfOffset(spectrum, detail, top) {\n    var args = {\n      min: minY(detail),\n      max: maxY(detail),\n      range: yRange(detail),\n      value: top,\n      step: step(detail),\n      snap: snap(detail),\n      snapStart: snapStart(detail),\n      rounded: rounded(detail),\n      hasMinEdge: hasTEdge(detail),\n      hasMaxEdge: hasBEdge(detail),\n      minBound: getMinYBounds(spectrum),\n      maxBound: getMaxYBounds(spectrum),\n      screenRange: getYScreenRange(spectrum)\n    };\n    return findValueOf(args);\n  };\n  var setValueFrom$1 = function setValueFrom$1(spectrum, detail, value) {\n    var yValue = findValueOfOffset(spectrum, detail, value);\n    var sliderVal = yValue;\n    fireSliderChange$1(spectrum, sliderVal);\n    return yValue;\n  };\n  var setToMin$1 = function setToMin$1(spectrum, detail) {\n    var min = minY(detail);\n    fireSliderChange$1(spectrum, min);\n  };\n  var setToMax$1 = function setToMax$1(spectrum, detail) {\n    var max = maxY(detail);\n    fireSliderChange$1(spectrum, max);\n  };\n  var moveBy$1 = function moveBy$1(direction, spectrum, detail) {\n    var f = direction > 0 ? increaseBy : reduceBy;\n    var yValue = f(currentValue(detail), minY(detail), maxY(detail), step(detail));\n    fireSliderChange$1(spectrum, yValue);\n    return Optional.some(yValue);\n  };\n  var handleMovement$1 = function handleMovement$1(direction) {\n    return function (spectrum, detail) {\n      return moveBy$1(direction, spectrum, detail).map(always);\n    };\n  };\n  var getValueFromEvent$1 = function getValueFromEvent$1(simulatedEvent) {\n    var pos = getEventSource(simulatedEvent);\n    return pos.map(function (p) {\n      return p.top;\n    });\n  };\n  var findOffsetOfValue = function findOffsetOfValue(spectrum, detail, value, minEdge, maxEdge) {\n    var minOffset = 0;\n    var maxOffset = getYScreenRange(spectrum);\n    var centerMinEdge = minEdge.bind(function (edge) {\n      return Optional.some(getYCenterOffSetOf(edge, spectrum));\n    }).getOr(minOffset);\n    var centerMaxEdge = maxEdge.bind(function (edge) {\n      return Optional.some(getYCenterOffSetOf(edge, spectrum));\n    }).getOr(maxOffset);\n    var args = {\n      min: minY(detail),\n      max: maxY(detail),\n      range: yRange(detail),\n      value: value,\n      hasMinEdge: hasTEdge(detail),\n      hasMaxEdge: hasBEdge(detail),\n      minBound: getMinYBounds(spectrum),\n      minOffset: minOffset,\n      maxBound: getMaxYBounds(spectrum),\n      maxOffset: maxOffset,\n      centerMinEdge: centerMinEdge,\n      centerMaxEdge: centerMaxEdge\n    };\n    return findOffsetOfValue$2(args);\n  };\n  var findPositionOfValue = function findPositionOfValue(slider, spectrum, value, minEdge, maxEdge, detail) {\n    var offset = findOffsetOfValue(spectrum, detail, value, minEdge, maxEdge);\n    return getMinYBounds(spectrum) - getMinYBounds(slider) + offset;\n  };\n  var setPositionFromValue$1 = function setPositionFromValue$1(slider, thumb, detail, edges) {\n    var value = currentValue(detail);\n    var pos = findPositionOfValue(slider, edges.getSpectrum(slider), value, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);\n    var thumbRadius = get$d(thumb.element) / 2;\n    set$8(thumb.element, 'top', pos - thumbRadius + 'px');\n  };\n  var onLeft$1 = Optional.none;\n  var onRight$1 = Optional.none;\n  var onUp$1 = handleMovement$1(-1);\n  var onDown$1 = handleMovement$1(1);\n  var edgeActions$1 = {\n    'top-left': Optional.none(),\n    'top': Optional.some(setToTEdge),\n    'top-right': Optional.none(),\n    'right': Optional.none(),\n    'bottom-right': Optional.none(),\n    'bottom': Optional.some(setToBEdge),\n    'bottom-left': Optional.none(),\n    'left': Optional.none()\n  };\n  var VerticalModel = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setValueFrom: setValueFrom$1,\n    setToMin: setToMin$1,\n    setToMax: setToMax$1,\n    findValueOfOffset: findValueOfOffset,\n    getValueFromEvent: getValueFromEvent$1,\n    findPositionOfValue: findPositionOfValue,\n    setPositionFromValue: setPositionFromValue$1,\n    onLeft: onLeft$1,\n    onRight: onRight$1,\n    onUp: onUp$1,\n    onDown: onDown$1,\n    edgeActions: edgeActions$1\n  });\n  var fireSliderChange = function fireSliderChange(spectrum, value) {\n    emitWith(spectrum, sliderChangeEvent(), {\n      value: value\n    });\n  };\n  var sliderValue = function sliderValue(x, y) {\n    return {\n      x: x,\n      y: y\n    };\n  };\n  var setValueFrom = function setValueFrom(spectrum, detail, value) {\n    var xValue = findValueOfOffset$1(spectrum, detail, value.left);\n    var yValue = findValueOfOffset(spectrum, detail, value.top);\n    var val = sliderValue(xValue, yValue);\n    fireSliderChange(spectrum, val);\n    return val;\n  };\n  var moveBy = function moveBy(direction, isVerticalMovement, spectrum, detail) {\n    var f = direction > 0 ? increaseBy : reduceBy;\n    var xValue = isVerticalMovement ? currentValue(detail).x : f(currentValue(detail).x, minX(detail), maxX(detail), step(detail));\n    var yValue = !isVerticalMovement ? currentValue(detail).y : f(currentValue(detail).y, minY(detail), maxY(detail), step(detail));\n    fireSliderChange(spectrum, sliderValue(xValue, yValue));\n    return Optional.some(xValue);\n  };\n  var handleMovement = function handleMovement(direction, isVerticalMovement) {\n    return function (spectrum, detail) {\n      return moveBy(direction, isVerticalMovement, spectrum, detail).map(always);\n    };\n  };\n  var setToMin = function setToMin(spectrum, detail) {\n    var mX = minX(detail);\n    var mY = minY(detail);\n    fireSliderChange(spectrum, sliderValue(mX, mY));\n  };\n  var setToMax = function setToMax(spectrum, detail) {\n    var mX = maxX(detail);\n    var mY = maxY(detail);\n    fireSliderChange(spectrum, sliderValue(mX, mY));\n  };\n  var getValueFromEvent = function getValueFromEvent(simulatedEvent) {\n    return getEventSource(simulatedEvent);\n  };\n  var setPositionFromValue = function setPositionFromValue(slider, thumb, detail, edges) {\n    var value = currentValue(detail);\n    var xPos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value.x, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);\n    var yPos = findPositionOfValue(slider, edges.getSpectrum(slider), value.y, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);\n    var thumbXRadius = get$c(thumb.element) / 2;\n    var thumbYRadius = get$d(thumb.element) / 2;\n    set$8(thumb.element, 'left', xPos - thumbXRadius + 'px');\n    set$8(thumb.element, 'top', yPos - thumbYRadius + 'px');\n  };\n  var onLeft = handleMovement(-1, false);\n  var onRight = handleMovement(1, false);\n  var onUp = handleMovement(-1, true);\n  var onDown = handleMovement(1, true);\n  var edgeActions = {\n    'top-left': Optional.some(setToTLEdgeXY),\n    'top': Optional.some(setToTEdgeXY),\n    'top-right': Optional.some(setToTREdgeXY),\n    'right': Optional.some(setToREdgeXY),\n    'bottom-right': Optional.some(setToBREdgeXY),\n    'bottom': Optional.some(setToBEdgeXY),\n    'bottom-left': Optional.some(setToBLEdgeXY),\n    'left': Optional.some(setToLEdgeXY)\n  };\n  var TwoDModel = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setValueFrom: setValueFrom,\n    setToMin: setToMin,\n    setToMax: setToMax,\n    getValueFromEvent: getValueFromEvent,\n    setPositionFromValue: setPositionFromValue,\n    onLeft: onLeft,\n    onRight: onRight,\n    onUp: onUp,\n    onDown: onDown,\n    edgeActions: edgeActions\n  });\n  var SliderSchema = [defaulted('stepSize', 1), defaulted('onChange', noop), defaulted('onChoose', noop), defaulted('onInit', noop), defaulted('onDragStart', noop), defaulted('onDragEnd', noop), defaulted('snapToGrid', false), defaulted('rounded', true), option$3('snapStart'), requiredOf('model', choose$1('mode', {\n    x: [defaulted('minX', 0), defaulted('maxX', 100), customField('value', function (spec) {\n      return Cell(spec.mode.minX);\n    }), required$1('getInitialValue'), output$1('manager', HorizontalModel)],\n    y: [defaulted('minY', 0), defaulted('maxY', 100), customField('value', function (spec) {\n      return Cell(spec.mode.minY);\n    }), required$1('getInitialValue'), output$1('manager', VerticalModel)],\n    xy: [defaulted('minX', 0), defaulted('maxX', 100), defaulted('minY', 0), defaulted('maxY', 100), customField('value', function (spec) {\n      return Cell({\n        x: spec.mode.minX,\n        y: spec.mode.minY\n      });\n    }), required$1('getInitialValue'), output$1('manager', TwoDModel)]\n  })), field('sliderBehaviours', [Keying, Representing]), customField('mouseIsDown', function () {\n    return Cell(false);\n  })];\n  var sketch$2 = function sketch$2(detail, components, _spec, _externals) {\n    var getThumb = function getThumb(component) {\n      return getPartOrDie(component, detail, 'thumb');\n    };\n    var getSpectrum = function getSpectrum(component) {\n      return getPartOrDie(component, detail, 'spectrum');\n    };\n    var getLeftEdge = function getLeftEdge(component) {\n      return getPart(component, detail, 'left-edge');\n    };\n    var getRightEdge = function getRightEdge(component) {\n      return getPart(component, detail, 'right-edge');\n    };\n    var getTopEdge = function getTopEdge(component) {\n      return getPart(component, detail, 'top-edge');\n    };\n    var getBottomEdge = function getBottomEdge(component) {\n      return getPart(component, detail, 'bottom-edge');\n    };\n    var modelDetail = detail.model;\n    var model = modelDetail.manager;\n    var refresh = function refresh(slider, thumb) {\n      model.setPositionFromValue(slider, thumb, detail, {\n        getLeftEdge: getLeftEdge,\n        getRightEdge: getRightEdge,\n        getTopEdge: getTopEdge,\n        getBottomEdge: getBottomEdge,\n        getSpectrum: getSpectrum\n      });\n    };\n    var setValue = function setValue(slider, newValue) {\n      modelDetail.value.set(newValue);\n      var thumb = getThumb(slider);\n      refresh(slider, thumb);\n    };\n    var changeValue = function changeValue(slider, newValue) {\n      setValue(slider, newValue);\n      var thumb = getThumb(slider);\n      detail.onChange(slider, thumb, newValue);\n      return Optional.some(true);\n    };\n    var resetToMin = function resetToMin(slider) {\n      model.setToMin(slider, detail);\n    };\n    var resetToMax = function resetToMax(slider) {\n      model.setToMax(slider, detail);\n    };\n    var choose = function choose(slider) {\n      var fireOnChoose = function fireOnChoose() {\n        getPart(slider, detail, 'thumb').each(function (thumb) {\n          var value = modelDetail.value.get();\n          detail.onChoose(slider, thumb, value);\n        });\n      };\n      var wasDown = detail.mouseIsDown.get();\n      detail.mouseIsDown.set(false);\n      if (wasDown) {\n        fireOnChoose();\n      }\n    };\n    var onDragStart = function onDragStart(slider, simulatedEvent) {\n      simulatedEvent.stop();\n      detail.mouseIsDown.set(true);\n      detail.onDragStart(slider, getThumb(slider));\n    };\n    var onDragEnd = function onDragEnd(slider, simulatedEvent) {\n      simulatedEvent.stop();\n      detail.onDragEnd(slider, getThumb(slider));\n      choose(slider);\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      behaviours: augment(detail.sliderBehaviours, [Keying.config({\n        mode: 'special',\n        focusIn: function focusIn(slider) {\n          return getPart(slider, detail, 'spectrum').map(Keying.focusIn).map(always);\n        }\n      }), Representing.config({\n        store: {\n          mode: 'manual',\n          getValue: function getValue(_) {\n            return modelDetail.value.get();\n          },\n          setValue: setValue\n        }\n      }), Receiving.config({\n        channels: _defineProperty({}, mouseReleased(), {\n          onReceive: choose\n        })\n      })]),\n      events: derive$2([run$1(sliderChangeEvent(), function (slider, simulatedEvent) {\n        changeValue(slider, simulatedEvent.event.value);\n      }), runOnAttached(function (slider, _simulatedEvent) {\n        var getInitial = modelDetail.getInitialValue();\n        modelDetail.value.set(getInitial);\n        var thumb = getThumb(slider);\n        refresh(slider, thumb);\n        var spectrum = getSpectrum(slider);\n        detail.onInit(slider, thumb, spectrum, modelDetail.value.get());\n      }), run$1(touchstart(), onDragStart), run$1(touchend(), onDragEnd), run$1(mousedown(), onDragStart), run$1(mouseup(), onDragEnd)]),\n      apis: {\n        resetToMin: resetToMin,\n        resetToMax: resetToMax,\n        setValue: setValue,\n        refresh: refresh\n      },\n      domModification: {\n        styles: {\n          position: 'relative'\n        }\n      }\n    };\n  };\n  var Slider = composite({\n    name: 'Slider',\n    configFields: SliderSchema,\n    partFields: SliderParts,\n    factory: sketch$2,\n    apis: {\n      setValue: function setValue(apis, slider, value) {\n        apis.setValue(slider, value);\n      },\n      resetToMin: function resetToMin(apis, slider) {\n        apis.resetToMin(slider);\n      },\n      resetToMax: function resetToMax(apis, slider) {\n        apis.resetToMax(slider);\n      },\n      refresh: function refresh(apis, slider) {\n        apis.refresh(slider);\n      }\n    }\n  });\n  var fieldsUpdate = generate$6('rgb-hex-update');\n  var sliderUpdate = generate$6('slider-update');\n  var paletteUpdate = generate$6('palette-update');\n  var sliderFactory = function sliderFactory(translate, getClass) {\n    var spectrum = Slider.parts.spectrum({\n      dom: {\n        tag: 'div',\n        classes: [getClass('hue-slider-spectrum')],\n        attributes: {\n          role: 'presentation'\n        }\n      }\n    });\n    var thumb = Slider.parts.thumb({\n      dom: {\n        tag: 'div',\n        classes: [getClass('hue-slider-thumb')],\n        attributes: {\n          role: 'presentation'\n        }\n      }\n    });\n    return Slider.sketch({\n      dom: {\n        tag: 'div',\n        classes: [getClass('hue-slider')],\n        attributes: {\n          role: 'presentation'\n        }\n      },\n      rounded: false,\n      model: {\n        mode: 'y',\n        getInitialValue: constant$1(0)\n      },\n      components: [spectrum, thumb],\n      sliderBehaviours: derive$1([Focusing.config({})]),\n      onChange: function onChange(slider, _thumb, value) {\n        emitWith(slider, sliderUpdate, {\n          value: value\n        });\n      }\n    });\n  };\n  var owner$1 = 'form';\n  var schema$i = [field('formBehaviours', [Representing])];\n  var getPartName$1 = function getPartName$1(name) {\n    return '<alloy.field.' + name + '>';\n  };\n  var sketch$1 = function sketch$1(fSpec) {\n    var parts = function () {\n      var record = [];\n      var field = function field(name, config) {\n        record.push(name);\n        return generateOne$1(owner$1, getPartName$1(name), config);\n      };\n      return {\n        field: field,\n        record: constant$1(record)\n      };\n    }();\n    var spec = fSpec(parts);\n    var partNames = parts.record();\n    var fieldParts = map$2(partNames, function (n) {\n      return required({\n        name: n,\n        pname: getPartName$1(n)\n      });\n    });\n    return composite$1(owner$1, schema$i, fieldParts, make$4, spec);\n  };\n  var toResult = function toResult(o, e) {\n    return o.fold(function () {\n      return Result.error(e);\n    }, Result.value);\n  };\n  var make$4 = function make$4(detail, components) {\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      behaviours: augment(detail.formBehaviours, [Representing.config({\n        store: {\n          mode: 'manual',\n          getValue: function getValue(form) {\n            var resPs = getAllParts(form, detail);\n            return map$1(resPs, function (resPThunk, pName) {\n              return resPThunk().bind(function (v) {\n                var opt = Composing.getCurrent(v);\n                return toResult(opt, new Error(\"Cannot find a current component to extract the value from for form part '\".concat(pName, \"': \") + element(v.element)));\n              }).map(Representing.getValue);\n            });\n          },\n          setValue: function setValue(form, values) {\n            each(values, function (newValue, key) {\n              getPart(form, detail, key).each(function (wrapper) {\n                Composing.getCurrent(wrapper).each(function (field) {\n                  Representing.setValue(field, newValue);\n                });\n              });\n            });\n          }\n        }\n      })]),\n      apis: {\n        getField: function getField(form, key) {\n          return getPart(form, detail, key).bind(Composing.getCurrent);\n        }\n      }\n    };\n  };\n  var Form = {\n    getField: makeApi(function (apis, component, key) {\n      return apis.getField(component, key);\n    }),\n    sketch: sketch$1\n  };\n  var validInput = generate$6('valid-input');\n  var invalidInput = generate$6('invalid-input');\n  var validatingInput = generate$6('validating-input');\n  var translatePrefix = 'colorcustom.rgb.';\n  var rgbFormFactory = function rgbFormFactory(translate, getClass, onValidHexx, onInvalidHexx) {\n    var invalidation = function invalidation(label, isValid) {\n      return Invalidating.config({\n        invalidClass: getClass('invalid'),\n        notify: {\n          onValidate: function onValidate(comp) {\n            emitWith(comp, validatingInput, {\n              type: label\n            });\n          },\n          onValid: function onValid(comp) {\n            emitWith(comp, validInput, {\n              type: label,\n              value: Representing.getValue(comp)\n            });\n          },\n          onInvalid: function onInvalid(comp) {\n            emitWith(comp, invalidInput, {\n              type: label,\n              value: Representing.getValue(comp)\n            });\n          }\n        },\n        validator: {\n          validate: function validate(comp) {\n            var value = Representing.getValue(comp);\n            var res = isValid(value) ? Result.value(true) : Result.error(translate('aria.input.invalid'));\n            return Future.pure(res);\n          },\n          validateOnLoad: false\n        }\n      });\n    };\n    var renderTextField = function renderTextField(isValid, name, label, description, data) {\n      var helptext = translate(translatePrefix + 'range');\n      var pLabel = FormField.parts.label({\n        dom: {\n          tag: 'label',\n          attributes: {\n            'aria-label': description\n          }\n        },\n        components: [text$2(label)]\n      });\n      var pField = FormField.parts.field({\n        data: data,\n        factory: Input,\n        inputAttributes: _objectSpread({\n          type: 'text'\n        }, name === 'hex' ? {\n          'aria-live': 'polite'\n        } : {}),\n        inputClasses: [getClass('textfield')],\n        inputBehaviours: derive$1([invalidation(name, isValid), Tabstopping.config({})]),\n        onSetValue: function onSetValue(input) {\n          if (Invalidating.isInvalid(input)) {\n            var _run = Invalidating.run(input);\n            _run.get(noop);\n          }\n        }\n      });\n      var comps = [pLabel, pField];\n      var concats = name !== 'hex' ? [FormField.parts['aria-descriptor']({\n        text: helptext\n      })] : [];\n      var components = comps.concat(concats);\n      return {\n        dom: {\n          tag: 'div',\n          attributes: {\n            role: 'presentation'\n          }\n        },\n        components: components\n      };\n    };\n    var copyRgbToHex = function copyRgbToHex(form, rgba) {\n      var hex = fromRgba(rgba);\n      Form.getField(form, 'hex').each(function (hexField) {\n        if (!Focusing.isFocused(hexField)) {\n          Representing.setValue(form, {\n            hex: hex.value\n          });\n        }\n      });\n      return hex;\n    };\n    var copyRgbToForm = function copyRgbToForm(form, rgb) {\n      var red = rgb.red;\n      var green = rgb.green;\n      var blue = rgb.blue;\n      Representing.setValue(form, {\n        red: red,\n        green: green,\n        blue: blue\n      });\n    };\n    var memPreview = record({\n      dom: {\n        tag: 'div',\n        classes: [getClass('rgba-preview')],\n        styles: {\n          'background-color': 'white'\n        },\n        attributes: {\n          role: 'presentation'\n        }\n      }\n    });\n    var updatePreview = function updatePreview(anyInSystem, hex) {\n      memPreview.getOpt(anyInSystem).each(function (preview) {\n        set$8(preview.element, 'background-color', '#' + hex.value);\n      });\n    };\n    var factory = function factory() {\n      var state = {\n        red: Cell(Optional.some(255)),\n        green: Cell(Optional.some(255)),\n        blue: Cell(Optional.some(255)),\n        hex: Cell(Optional.some('ffffff'))\n      };\n      var copyHexToRgb = function copyHexToRgb(form, hex) {\n        var rgb = fromHex(hex);\n        copyRgbToForm(form, rgb);\n        setValueRgb(rgb);\n      };\n      var get = function get(prop) {\n        return state[prop].get();\n      };\n      var set = function set(prop, value) {\n        state[prop].set(value);\n      };\n      var getValueRgb = function getValueRgb() {\n        return get('red').bind(function (red) {\n          return get('green').bind(function (green) {\n            return get('blue').map(function (blue) {\n              return rgbaColour(red, green, blue, 1);\n            });\n          });\n        });\n      };\n      var setValueRgb = function setValueRgb(rgb) {\n        var red = rgb.red;\n        var green = rgb.green;\n        var blue = rgb.blue;\n        set('red', Optional.some(red));\n        set('green', Optional.some(green));\n        set('blue', Optional.some(blue));\n      };\n      var onInvalidInput = function onInvalidInput(form, simulatedEvent) {\n        var data = simulatedEvent.event;\n        if (data.type !== 'hex') {\n          set(data.type, Optional.none());\n        } else {\n          onInvalidHexx(form);\n        }\n      };\n      var onValidHex = function onValidHex(form, value) {\n        onValidHexx(form);\n        var hex = hexColour(value);\n        set('hex', Optional.some(hex.value));\n        var rgb = fromHex(hex);\n        copyRgbToForm(form, rgb);\n        setValueRgb(rgb);\n        emitWith(form, fieldsUpdate, {\n          hex: hex\n        });\n        updatePreview(form, hex);\n      };\n      var onValidRgb = function onValidRgb(form, prop, value) {\n        var val = parseInt(value, 10);\n        set(prop, Optional.some(val));\n        getValueRgb().each(function (rgb) {\n          var hex = copyRgbToHex(form, rgb);\n          emitWith(form, fieldsUpdate, {\n            hex: hex\n          });\n          updatePreview(form, hex);\n        });\n      };\n      var isHexInputEvent = function isHexInputEvent(data) {\n        return data.type === 'hex';\n      };\n      var onValidInput = function onValidInput(form, simulatedEvent) {\n        var data = simulatedEvent.event;\n        if (isHexInputEvent(data)) {\n          onValidHex(form, data.value);\n        } else {\n          onValidRgb(form, data.type, data.value);\n        }\n      };\n      var formPartStrings = function formPartStrings(key) {\n        return {\n          label: translate(translatePrefix + key + '.label'),\n          description: translate(translatePrefix + key + '.description')\n        };\n      };\n      var redStrings = formPartStrings('red');\n      var greenStrings = formPartStrings('green');\n      var blueStrings = formPartStrings('blue');\n      var hexStrings = formPartStrings('hex');\n      return deepMerge(Form.sketch(function (parts) {\n        return {\n          dom: {\n            tag: 'form',\n            classes: [getClass('rgb-form')],\n            attributes: {\n              'aria-label': translate('aria.color.picker')\n            }\n          },\n          components: [parts.field('red', FormField.sketch(renderTextField(isRgbaComponent, 'red', redStrings.label, redStrings.description, 255))), parts.field('green', FormField.sketch(renderTextField(isRgbaComponent, 'green', greenStrings.label, greenStrings.description, 255))), parts.field('blue', FormField.sketch(renderTextField(isRgbaComponent, 'blue', blueStrings.label, blueStrings.description, 255))), parts.field('hex', FormField.sketch(renderTextField(isHexString, 'hex', hexStrings.label, hexStrings.description, 'ffffff'))), memPreview.asSpec()],\n          formBehaviours: derive$1([Invalidating.config({\n            invalidClass: getClass('form-invalid')\n          }), config('rgb-form-events', [run$1(validInput, onValidInput), run$1(invalidInput, onInvalidInput), run$1(validatingInput, onInvalidInput)])])\n        };\n      }), {\n        apis: {\n          updateHex: function updateHex(form, hex) {\n            Representing.setValue(form, {\n              hex: hex.value\n            });\n            copyHexToRgb(form, hex);\n            updatePreview(form, hex);\n          }\n        }\n      });\n    };\n    var rgbFormSketcher = single({\n      factory: factory,\n      name: 'RgbForm',\n      configFields: [],\n      apis: {\n        updateHex: function updateHex(apis, form, hex) {\n          apis.updateHex(form, hex);\n        }\n      },\n      extraApis: {}\n    });\n    return rgbFormSketcher;\n  };\n  var paletteFactory = function paletteFactory(_translate, getClass) {\n    var spectrumPart = Slider.parts.spectrum({\n      dom: {\n        tag: 'canvas',\n        attributes: {\n          role: 'presentation'\n        },\n        classes: [getClass('sv-palette-spectrum')]\n      }\n    });\n    var thumbPart = Slider.parts.thumb({\n      dom: {\n        tag: 'div',\n        attributes: {\n          role: 'presentation'\n        },\n        classes: [getClass('sv-palette-thumb')],\n        innerHtml: \"<div class=\".concat(getClass('sv-palette-inner-thumb'), \" role=\\\"presentation\\\"></div>\")\n      }\n    });\n    var setColour = function setColour(canvas, rgba) {\n      var width = canvas.width,\n        height = canvas.height;\n      var ctx = canvas.getContext('2d');\n      if (ctx === null) {\n        return;\n      }\n      ctx.fillStyle = rgba;\n      ctx.fillRect(0, 0, width, height);\n      var grdWhite = ctx.createLinearGradient(0, 0, width, 0);\n      grdWhite.addColorStop(0, 'rgba(255,255,255,1)');\n      grdWhite.addColorStop(1, 'rgba(255,255,255,0)');\n      ctx.fillStyle = grdWhite;\n      ctx.fillRect(0, 0, width, height);\n      var grdBlack = ctx.createLinearGradient(0, 0, 0, height);\n      grdBlack.addColorStop(0, 'rgba(0,0,0,0)');\n      grdBlack.addColorStop(1, 'rgba(0,0,0,1)');\n      ctx.fillStyle = grdBlack;\n      ctx.fillRect(0, 0, width, height);\n    };\n    var setPaletteHue = function setPaletteHue(slider, hue) {\n      var canvas = slider.components()[0].element.dom;\n      var hsv = hsvColour(hue, 100, 100);\n      var rgba = fromHsv(hsv);\n      setColour(canvas, toString(rgba));\n    };\n    var setPaletteThumb = function setPaletteThumb(slider, hex) {\n      var hsv = fromRgb(fromHex(hex));\n      Slider.setValue(slider, {\n        x: hsv.saturation,\n        y: 100 - hsv.value\n      });\n    };\n    var factory = function factory(_detail) {\n      var getInitialValue = constant$1({\n        x: 0,\n        y: 0\n      });\n      var onChange = function onChange(slider, _thumb, value) {\n        emitWith(slider, paletteUpdate, {\n          value: value\n        });\n      };\n      var onInit = function onInit(_slider, _thumb, spectrum, _value) {\n        setColour(spectrum.element.dom, toString(red));\n      };\n      var sliderBehaviours = derive$1([Composing.config({\n        find: Optional.some\n      }), Focusing.config({})]);\n      return Slider.sketch({\n        dom: {\n          tag: 'div',\n          attributes: {\n            role: 'presentation'\n          },\n          classes: [getClass('sv-palette')]\n        },\n        model: {\n          mode: 'xy',\n          getInitialValue: getInitialValue\n        },\n        rounded: false,\n        components: [spectrumPart, thumbPart],\n        onChange: onChange,\n        onInit: onInit,\n        sliderBehaviours: sliderBehaviours\n      });\n    };\n    var saturationBrightnessPaletteSketcher = single({\n      factory: factory,\n      name: 'SaturationBrightnessPalette',\n      configFields: [],\n      apis: {\n        setHue: function setHue(_apis, slider, hue) {\n          setPaletteHue(slider, hue);\n        },\n        setThumb: function setThumb(_apis, slider, hex) {\n          setPaletteThumb(slider, hex);\n        }\n      },\n      extraApis: {}\n    });\n    return saturationBrightnessPaletteSketcher;\n  };\n  var makeFactory = function makeFactory(translate, getClass) {\n    var factory = function factory(detail) {\n      var rgbForm = rgbFormFactory(translate, getClass, detail.onValidHex, detail.onInvalidHex);\n      var sbPalette = paletteFactory(translate, getClass);\n      var hueSliderToDegrees = function hueSliderToDegrees(hue) {\n        return (100 - hue) / 100 * 360;\n      };\n      var hueDegreesToSlider = function hueDegreesToSlider(hue) {\n        return 100 - hue / 360 * 100;\n      };\n      var state = {\n        paletteRgba: Cell(red),\n        paletteHue: Cell(0)\n      };\n      var memSlider = record(sliderFactory(translate, getClass));\n      var memPalette = record(sbPalette.sketch({}));\n      var memRgb = record(rgbForm.sketch({}));\n      var updatePalette = function updatePalette(anyInSystem, _hex, hue) {\n        memPalette.getOpt(anyInSystem).each(function (palette) {\n          sbPalette.setHue(palette, hue);\n        });\n      };\n      var updateFields = function updateFields(anyInSystem, hex) {\n        memRgb.getOpt(anyInSystem).each(function (form) {\n          rgbForm.updateHex(form, hex);\n        });\n      };\n      var updateSlider = function updateSlider(anyInSystem, _hex, hue) {\n        memSlider.getOpt(anyInSystem).each(function (slider) {\n          Slider.setValue(slider, hueDegreesToSlider(hue));\n        });\n      };\n      var updatePaletteThumb = function updatePaletteThumb(anyInSystem, hex) {\n        memPalette.getOpt(anyInSystem).each(function (palette) {\n          sbPalette.setThumb(palette, hex);\n        });\n      };\n      var updateState = function updateState(hex, hue) {\n        var rgba = fromHex(hex);\n        state.paletteRgba.set(rgba);\n        state.paletteHue.set(hue);\n      };\n      var runUpdates = function runUpdates(anyInSystem, hex, hue, updates) {\n        updateState(hex, hue);\n        each$1(updates, function (update) {\n          update(anyInSystem, hex, hue);\n        });\n      };\n      var onPaletteUpdate = function onPaletteUpdate() {\n        var updates = [updateFields];\n        return function (form, simulatedEvent) {\n          var value = simulatedEvent.event.value;\n          var oldHue = state.paletteHue.get();\n          var newHsv = hsvColour(oldHue, value.x, 100 - value.y);\n          var newHex = hsvToHex(newHsv);\n          runUpdates(form, newHex, oldHue, updates);\n        };\n      };\n      var onSliderUpdate = function onSliderUpdate() {\n        var updates = [updatePalette, updateFields];\n        return function (form, simulatedEvent) {\n          var hue = hueSliderToDegrees(simulatedEvent.event.value);\n          var oldRgb = state.paletteRgba.get();\n          var oldHsv = fromRgb(oldRgb);\n          var newHsv = hsvColour(hue, oldHsv.saturation, oldHsv.value);\n          var newHex = hsvToHex(newHsv);\n          runUpdates(form, newHex, hue, updates);\n        };\n      };\n      var onFieldsUpdate = function onFieldsUpdate() {\n        var updates = [updatePalette, updateSlider, updatePaletteThumb];\n        return function (form, simulatedEvent) {\n          var hex = simulatedEvent.event.hex;\n          var hsv = hexToHsv(hex);\n          runUpdates(form, hex, hsv.hue, updates);\n        };\n      };\n      return {\n        uid: detail.uid,\n        dom: detail.dom,\n        components: [memPalette.asSpec(), memSlider.asSpec(), memRgb.asSpec()],\n        behaviours: derive$1([config('colour-picker-events', [run$1(fieldsUpdate, onFieldsUpdate()), run$1(paletteUpdate, onPaletteUpdate()), run$1(sliderUpdate, onSliderUpdate())]), Composing.config({\n          find: function find(comp) {\n            return memRgb.getOpt(comp);\n          }\n        }), Keying.config({\n          mode: 'acyclic'\n        })])\n      };\n    };\n    var colourPickerSketcher = single({\n      name: 'ColourPicker',\n      configFields: [required$1('dom'), defaulted('onValidHex', noop), defaulted('onInvalidHex', noop)],\n      factory: factory\n    });\n    return colourPickerSketcher;\n  };\n  var self = function self() {\n    return Composing.config({\n      find: Optional.some\n    });\n  };\n  var memento$1 = function memento$1(mem) {\n    return Composing.config({\n      find: mem.getOpt\n    });\n  };\n  var childAt = function childAt(index) {\n    return Composing.config({\n      find: function find(comp) {\n        return child$2(comp.element, index).bind(function (element) {\n          return comp.getSystem().getByDom(element).toOptional();\n        });\n      }\n    });\n  };\n  var ComposingConfigs = {\n    self: self,\n    memento: memento$1,\n    childAt: childAt\n  };\n  var processors = objOf([defaulted('preprocess', identity), defaulted('postprocess', identity)]);\n  var memento = function memento(mem, rawProcessors) {\n    var ps = asRawOrDie$1('RepresentingConfigs.memento processors', processors, rawProcessors);\n    return Representing.config({\n      store: {\n        mode: 'manual',\n        getValue: function getValue(comp) {\n          var other = mem.get(comp);\n          var rawValue = Representing.getValue(other);\n          return ps.postprocess(rawValue);\n        },\n        setValue: function setValue(comp, rawValue) {\n          var newValue = ps.preprocess(rawValue);\n          var other = mem.get(comp);\n          Representing.setValue(other, newValue);\n        }\n      }\n    });\n  };\n  var withComp = function withComp(optInitialValue, getter, setter) {\n    return Representing.config({\n      store: _objectSpread({\n        mode: 'manual'\n      }, optInitialValue.map(function (initialValue) {\n        return {\n          initialValue: initialValue\n        };\n      }).getOr({}), {\n        getValue: getter,\n        setValue: setter\n      })\n    });\n  };\n  var withElement = function withElement(initialValue, getter, setter) {\n    return withComp(initialValue, function (c) {\n      return getter(c.element);\n    }, function (c, v) {\n      return setter(c.element, v);\n    });\n  };\n  var domHtml = function domHtml(optInitialValue) {\n    return withElement(optInitialValue, get$9, set$6);\n  };\n  var memory = function memory(initialValue) {\n    return Representing.config({\n      store: {\n        mode: 'memory',\n        initialValue: initialValue\n      }\n    });\n  };\n  var english = {\n    'colorcustom.rgb.red.label': 'R',\n    'colorcustom.rgb.red.description': 'Red component',\n    'colorcustom.rgb.green.label': 'G',\n    'colorcustom.rgb.green.description': 'Green component',\n    'colorcustom.rgb.blue.label': 'B',\n    'colorcustom.rgb.blue.description': 'Blue component',\n    'colorcustom.rgb.hex.label': '#',\n    'colorcustom.rgb.hex.description': 'Hex color code',\n    'colorcustom.rgb.range': 'Range 0 to 255',\n    'aria.color.picker': 'Color Picker',\n    'aria.input.invalid': 'Invalid input'\n  };\n  var translate$1 = function translate$1(providerBackstage) {\n    return function (key) {\n      return providerBackstage.translate(english[key]);\n    };\n  };\n  var renderColorPicker = function renderColorPicker(_spec, providerBackstage, initialData) {\n    var getClass = function getClass(key) {\n      return 'tox-' + key;\n    };\n    var colourPickerFactory = makeFactory(translate$1(providerBackstage), getClass);\n    var onValidHex = function onValidHex(form) {\n      emitWith(form, formActionEvent, {\n        name: 'hex-valid',\n        value: true\n      });\n    };\n    var onInvalidHex = function onInvalidHex(form) {\n      emitWith(form, formActionEvent, {\n        name: 'hex-valid',\n        value: false\n      });\n    };\n    var memPicker = record(colourPickerFactory.sketch({\n      dom: {\n        tag: 'div',\n        classes: [getClass('color-picker-container')],\n        attributes: {\n          role: 'presentation'\n        }\n      },\n      onValidHex: onValidHex,\n      onInvalidHex: onInvalidHex\n    }));\n    return {\n      dom: {\n        tag: 'div'\n      },\n      components: [memPicker.asSpec()],\n      behaviours: derive$1([withComp(initialData, function (comp) {\n        var picker = memPicker.get(comp);\n        var optRgbForm = Composing.getCurrent(picker);\n        var optHex = optRgbForm.bind(function (rgbForm) {\n          var formValues = Representing.getValue(rgbForm);\n          return formValues.hex;\n        });\n        return optHex.map(function (hex) {\n          return '#' + removeLeading(hex, '#');\n        }).getOr('');\n      }, function (comp, newValue) {\n        var pattern = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/;\n        var valOpt = Optional.from(pattern.exec(newValue)).bind(function (matches) {\n          return get$h(matches, 1);\n        });\n        var picker = memPicker.get(comp);\n        var optRgbForm = Composing.getCurrent(picker);\n        optRgbForm.fold(function () {\n          console.log('Can not find form');\n        }, function (rgbForm) {\n          Representing.setValue(rgbForm, {\n            hex: valOpt.getOr('')\n          });\n          Form.getField(rgbForm, 'hex').each(function (hexField) {\n            emit(hexField, input());\n          });\n        });\n      }), ComposingConfigs.self()])\n    };\n  };\n  var global$2 = tinymce.util.Tools.resolve('tinymce.Resource');\n  var isOldCustomEditor = function isOldCustomEditor(spec) {\n    return has$2(spec, 'init');\n  };\n  var renderCustomEditor = function renderCustomEditor(spec) {\n    var editorApi = value$2();\n    var memReplaced = record({\n      dom: {\n        tag: spec.tag\n      }\n    });\n    var initialValue = value$2();\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-custom-editor']\n      },\n      behaviours: derive$1([config('custom-editor-events', [runOnAttached(function (component) {\n        memReplaced.getOpt(component).each(function (ta) {\n          (isOldCustomEditor(spec) ? spec.init(ta.element.dom) : global$2.load(spec.scriptId, spec.scriptUrl).then(function (init) {\n            return init(ta.element.dom, spec.settings);\n          })).then(function (ea) {\n            initialValue.on(function (cvalue) {\n              ea.setValue(cvalue);\n            });\n            initialValue.clear();\n            editorApi.set(ea);\n          });\n        });\n      })]), withComp(Optional.none(), function () {\n        return editorApi.get().fold(function () {\n          return initialValue.get().getOr('');\n        }, function (ed) {\n          return ed.getValue();\n        });\n      }, function (component, value) {\n        editorApi.get().fold(function () {\n          return initialValue.set(value);\n        }, function (ed) {\n          return ed.setValue(value);\n        });\n      }), ComposingConfigs.self()]),\n      components: [memReplaced.asSpec()]\n    };\n  };\n  var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n  var filterByExtension = function filterByExtension(files, providersBackstage) {\n    var allowedImageFileTypes = global$1.explode(providersBackstage.getOption('images_file_types'));\n    var isFileInAllowedTypes = function isFileInAllowedTypes(file) {\n      return exists(allowedImageFileTypes, function (type) {\n        return endsWith(file.name.toLowerCase(), \".\".concat(type.toLowerCase()));\n      });\n    };\n    return filter$2(from(files), isFileInAllowedTypes);\n  };\n  var renderDropZone = function renderDropZone(spec, providersBackstage, initialData) {\n    var stopper = function stopper(_, se) {\n      se.stop();\n    };\n    var sequence = function sequence(actions) {\n      return function (comp, se) {\n        each$1(actions, function (a) {\n          a(comp, se);\n        });\n      };\n    };\n    var onDrop = function onDrop(comp, se) {\n      var _a;\n      if (!Disabling.isDisabled(comp)) {\n        var transferEvent = se.event.raw;\n        handleFiles(comp, (_a = transferEvent.dataTransfer) === null || _a === void 0 ? void 0 : _a.files);\n      }\n    };\n    var onSelect = function onSelect(component, simulatedEvent) {\n      var input = simulatedEvent.event.raw.target;\n      handleFiles(component, input.files);\n    };\n    var handleFiles = function handleFiles(component, files) {\n      if (files) {\n        Representing.setValue(component, filterByExtension(files, providersBackstage));\n        emitWith(component, formChangeEvent, {\n          name: spec.name\n        });\n      }\n    };\n    var memInput = record({\n      dom: {\n        tag: 'input',\n        attributes: {\n          type: 'file',\n          accept: 'image/*'\n        },\n        styles: {\n          display: 'none'\n        }\n      },\n      behaviours: derive$1([config('input-file-events', [cutter(click()), cutter(tap())])])\n    });\n    var renderField = function renderField(s) {\n      return {\n        uid: s.uid,\n        dom: {\n          tag: 'div',\n          classes: ['tox-dropzone-container']\n        },\n        behaviours: derive$1([memory(initialData.getOr([])), ComposingConfigs.self(), Disabling.config({}), Toggling.config({\n          toggleClass: 'dragenter',\n          toggleOnExecute: false\n        }), config('dropzone-events', [run$1('dragenter', sequence([stopper, Toggling.toggle])), run$1('dragleave', sequence([stopper, Toggling.toggle])), run$1('dragover', stopper), run$1('drop', sequence([stopper, onDrop])), run$1(change(), onSelect)])]),\n        components: [{\n          dom: {\n            tag: 'div',\n            classes: ['tox-dropzone'],\n            styles: {}\n          },\n          components: [{\n            dom: {\n              tag: 'p'\n            },\n            components: [text$2(providersBackstage.translate('Drop an image here'))]\n          }, Button.sketch({\n            dom: {\n              tag: 'button',\n              styles: {\n                position: 'relative'\n              },\n              classes: ['tox-button', 'tox-button--secondary']\n            },\n            components: [text$2(providersBackstage.translate('Browse for an image')), memInput.asSpec()],\n            action: function action(comp) {\n              var inputComp = memInput.get(comp);\n              inputComp.element.dom.click();\n            },\n            buttonBehaviours: derive$1([Tabstopping.config({}), DisablingConfigs.button(providersBackstage.isDisabled), receivingConfig()])\n          })]\n        }]\n      };\n    };\n    var pLabel = spec.label.map(function (label) {\n      return renderLabel$3(label, providersBackstage);\n    });\n    var pField = FormField.parts.field({\n      factory: {\n        sketch: renderField\n      }\n    });\n    return renderFormFieldWith(pLabel, pField, ['tox-form__group--stretched'], []);\n  };\n  var renderGrid = function renderGrid(spec, backstage) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-form__grid', \"tox-form__grid--\".concat(spec.columns, \"col\")]\n      },\n      components: map$2(spec.items, backstage.interpreter)\n    };\n  };\n  var adaptable = function adaptable(fn, rate) {\n    var timer = null;\n    var args = null;\n    var cancel = function cancel() {\n      if (!isNull(timer)) {\n        clearTimeout(timer);\n        timer = null;\n        args = null;\n      }\n    };\n    var throttle = function throttle() {\n      for (var _len17 = arguments.length, newArgs = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        newArgs[_key17] = arguments[_key17];\n      }\n      args = newArgs;\n      if (isNull(timer)) {\n        timer = setTimeout(function () {\n          var tempArgs = args;\n          timer = null;\n          args = null;\n          fn.apply(null, tempArgs);\n        }, rate);\n      }\n    };\n    return {\n      cancel: cancel,\n      throttle: throttle\n    };\n  };\n  var first = function first(fn, rate) {\n    var timer = null;\n    var cancel = function cancel() {\n      if (!isNull(timer)) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    };\n    var throttle = function throttle() {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      if (isNull(timer)) {\n        timer = setTimeout(function () {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      }\n    };\n    return {\n      cancel: cancel,\n      throttle: throttle\n    };\n  };\n  var last = function last(fn, rate) {\n    var timer = null;\n    var cancel = function cancel() {\n      if (!isNull(timer)) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    };\n    var throttle = function throttle() {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      cancel();\n      timer = setTimeout(function () {\n        timer = null;\n        fn.apply(null, args);\n      }, rate);\n    };\n    return {\n      cancel: cancel,\n      throttle: throttle\n    };\n  };\n  var beforeObject = generate$6('alloy-fake-before-tabstop');\n  var afterObject = generate$6('alloy-fake-after-tabstop');\n  var craftWithClasses = function craftWithClasses(classes) {\n    return {\n      dom: {\n        tag: 'div',\n        styles: {\n          width: '1px',\n          height: '1px',\n          outline: 'none'\n        },\n        attributes: {\n          tabindex: '0'\n        },\n        classes: classes\n      },\n      behaviours: derive$1([Focusing.config({\n        ignore: true\n      }), Tabstopping.config({})])\n    };\n  };\n  var craft = function craft(containerClasses, spec) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-navobj'].concat(_toConsumableArray(containerClasses.getOr([])))\n      },\n      components: [craftWithClasses([beforeObject]), spec, craftWithClasses([afterObject])],\n      behaviours: derive$1([ComposingConfigs.childAt(1)])\n    };\n  };\n  var triggerTab = function triggerTab(placeholder, shiftKey) {\n    emitWith(placeholder, keydown(), {\n      raw: {\n        which: 9,\n        shiftKey: shiftKey\n      }\n    });\n  };\n  var onFocus = function onFocus(container, targetComp) {\n    var target = targetComp.element;\n    if (has(target, beforeObject)) {\n      triggerTab(container, true);\n    } else if (has(target, afterObject)) {\n      triggerTab(container, false);\n    }\n  };\n  var isPseudoStop = function isPseudoStop(element) {\n    return closest(element, ['.' + beforeObject, '.' + afterObject].join(','), never);\n  };\n  var dialogChannel = generate$6('update-dialog');\n  var titleChannel = generate$6('update-title');\n  var bodyChannel = generate$6('update-body');\n  var footerChannel = generate$6('update-footer');\n  var bodySendMessageChannel = generate$6('body-send-message');\n  var dialogFocusShiftedChannel = generate$6('dialog-focus-shifted');\n  var browser = detect$2().browser;\n  var isSafari = browser.isSafari();\n  var isFirefox = browser.isFirefox();\n  var isSafariOrFirefox = isSafari || isFirefox;\n  var isChromium = browser.isChromium();\n  var isElementScrollAtBottom = function isElementScrollAtBottom(_ref10) {\n    var scrollTop = _ref10.scrollTop,\n      scrollHeight = _ref10.scrollHeight,\n      clientHeight = _ref10.clientHeight;\n    return Math.ceil(scrollTop) + clientHeight >= scrollHeight;\n  };\n  var scrollToY = function scrollToY(win, y) {\n    return win.scrollTo(0, y === 'bottom' ? 99999999 : y);\n  };\n  var getScrollingElement = function getScrollingElement(doc, html) {\n    var body = doc.body;\n    return Optional.from(!/^<!DOCTYPE (html|HTML)/.test(html) && (!isChromium && !isSafari || isNonNullable(body) && (body.scrollTop !== 0 || Math.abs(body.scrollHeight - body.clientHeight) > 1)) ? body : doc.documentElement);\n  };\n  var writeValue = function writeValue(iframeElement, html, fallbackFn) {\n    var iframe = iframeElement.dom;\n    Optional.from(iframe.contentDocument).fold(fallbackFn, function (doc) {\n      var lastScrollTop = 0;\n      var isScrollAtBottom = getScrollingElement(doc, html).map(function (el) {\n        lastScrollTop = el.scrollTop;\n        return el;\n      }).forall(isElementScrollAtBottom);\n      var scrollAfterWrite = function scrollAfterWrite() {\n        var win = iframe.contentWindow;\n        if (isNonNullable(win)) {\n          if (isScrollAtBottom) {\n            scrollToY(win, 'bottom');\n          } else if (!isScrollAtBottom && isSafariOrFirefox && lastScrollTop !== 0) {\n            scrollToY(win, lastScrollTop);\n          }\n        }\n      };\n      if (isSafari) {\n        iframe.addEventListener('load', scrollAfterWrite, {\n          once: true\n        });\n      }\n      doc.open();\n      doc.write(html);\n      doc.close();\n      if (!isSafari) {\n        scrollAfterWrite();\n      }\n    });\n  };\n  var throttleInterval = someIf(isSafariOrFirefox, isSafari ? 500 : 200);\n  var writeValueThrottler = throttleInterval.map(function (interval) {\n    return adaptable(writeValue, interval);\n  });\n  var getDynamicSource = function getDynamicSource(initialData, stream) {\n    var cachedValue = Cell(initialData.getOr(''));\n    return {\n      getValue: function getValue(_frameComponent) {\n        return cachedValue.get();\n      },\n      setValue: function setValue(frameComponent, html) {\n        if (cachedValue.get() !== html) {\n          var iframeElement = frameComponent.element;\n          var setSrcdocValue = function setSrcdocValue() {\n            return set$9(iframeElement, 'srcdoc', html);\n          };\n          if (stream) {\n            writeValueThrottler.fold(constant$1(writeValue), function (throttler) {\n              return throttler.throttle;\n            })(iframeElement, html, setSrcdocValue);\n          } else {\n            setSrcdocValue();\n          }\n        }\n        cachedValue.set(html);\n      }\n    };\n  };\n  var renderIFrame = function renderIFrame(spec, providersBackstage, initialData) {\n    var baseClass = 'tox-dialog__iframe';\n    var opaqueClass = spec.transparent ? [] : [\"\".concat(baseClass, \"--opaque\")];\n    var containerBorderedClass = spec.border ? [\"tox-navobj-bordered\"] : [];\n    var attributes = _objectSpread({}, spec.label.map(function (title) {\n      return {\n        title: title\n      };\n    }).getOr({}), initialData.map(function (html) {\n      return {\n        srcdoc: html\n      };\n    }).getOr({}), spec.sandboxed ? {\n      sandbox: 'allow-scripts allow-same-origin'\n    } : {});\n    var sourcing = getDynamicSource(initialData, spec.streamContent);\n    var pLabel = spec.label.map(function (label) {\n      return renderLabel$3(label, providersBackstage);\n    });\n    var factory = function factory(newSpec) {\n      return craft(Optional.from(containerBorderedClass), {\n        uid: newSpec.uid,\n        dom: {\n          tag: 'iframe',\n          attributes: attributes,\n          classes: [baseClass].concat(opaqueClass)\n        },\n        behaviours: derive$1([Tabstopping.config({}), Focusing.config({}), withComp(initialData, sourcing.getValue, sourcing.setValue), Receiving.config({\n          channels: _defineProperty({}, dialogFocusShiftedChannel, {\n            onReceive: function onReceive(comp, message) {\n              message.newFocus.each(function (newFocus) {\n                parentElement(comp.element).each(function (parent) {\n                  var f = eq(comp.element, newFocus) ? add$2 : remove$2;\n                  f(parent, 'tox-navobj-bordered-focus');\n                });\n              });\n            }\n          })\n        })])\n      });\n    };\n    var pField = FormField.parts.field({\n      factory: {\n        sketch: factory\n      }\n    });\n    return renderFormFieldWith(pLabel, pField, ['tox-form__group--stretched'], []);\n  };\n  var image = function image(_image) {\n    return new Promise(function (resolve, reject) {\n      var loaded = function loaded() {\n        destroy();\n        resolve(_image);\n      };\n      var listeners = [bind(_image, 'load', loaded), bind(_image, 'error', function () {\n        destroy();\n        reject('Unable to load data from image: ' + _image.dom.src);\n      })];\n      var destroy = function destroy() {\n        return each$1(listeners, function (l) {\n          return l.unbind();\n        });\n      };\n      if (_image.dom.complete) {\n        loaded();\n      }\n    });\n  };\n  var calculateImagePosition = function calculateImagePosition(panelWidth, panelHeight, imageWidth, imageHeight, zoom) {\n    var width = imageWidth * zoom;\n    var height = imageHeight * zoom;\n    var left = Math.max(0, panelWidth / 2 - width / 2);\n    var top = Math.max(0, panelHeight / 2 - height / 2);\n    return {\n      left: left.toString() + 'px',\n      top: top.toString() + 'px',\n      width: width.toString() + 'px',\n      height: height.toString() + 'px'\n    };\n  };\n  var zoomToFit = function zoomToFit(panel, width, height) {\n    var panelW = get$c(panel);\n    var panelH = get$d(panel);\n    return Math.min(panelW / width, panelH / height, 1);\n  };\n  var renderImagePreview = function renderImagePreview(spec, initialData) {\n    var cachedData = Cell(initialData.getOr({\n      url: ''\n    }));\n    var memImage = record({\n      dom: {\n        tag: 'img',\n        classes: ['tox-imagepreview__image'],\n        attributes: initialData.map(function (data) {\n          return {\n            src: data.url\n          };\n        }).getOr({})\n      }\n    });\n    var memContainer = record({\n      dom: {\n        tag: 'div',\n        classes: ['tox-imagepreview__container'],\n        attributes: {\n          role: 'presentation'\n        }\n      },\n      components: [memImage.asSpec()]\n    });\n    var setValue = function setValue(frameComponent, data) {\n      var translatedData = {\n        url: data.url\n      };\n      data.zoom.each(function (z) {\n        return translatedData.zoom = z;\n      });\n      data.cachedWidth.each(function (z) {\n        return translatedData.cachedWidth = z;\n      });\n      data.cachedHeight.each(function (z) {\n        return translatedData.cachedHeight = z;\n      });\n      cachedData.set(translatedData);\n      var applyFramePositioning = function applyFramePositioning() {\n        var cachedWidth = translatedData.cachedWidth,\n          cachedHeight = translatedData.cachedHeight,\n          zoom = translatedData.zoom;\n        if (!isUndefined(cachedWidth) && !isUndefined(cachedHeight)) {\n          if (isUndefined(zoom)) {\n            var z = zoomToFit(frameComponent.element, cachedWidth, cachedHeight);\n            translatedData.zoom = z;\n          }\n          var _position = calculateImagePosition(get$c(frameComponent.element), get$d(frameComponent.element), cachedWidth, cachedHeight, translatedData.zoom);\n          memContainer.getOpt(frameComponent).each(function (container) {\n            setAll(container.element, _position);\n          });\n        }\n      };\n      memImage.getOpt(frameComponent).each(function (imageComponent) {\n        var img = imageComponent.element;\n        if (data.url !== get$f(img, 'src')) {\n          set$9(img, 'src', data.url);\n          remove$2(frameComponent.element, 'tox-imagepreview__loaded');\n        }\n        applyFramePositioning();\n        image(img).then(function (img) {\n          if (frameComponent.getSystem().isConnected()) {\n            add$2(frameComponent.element, 'tox-imagepreview__loaded');\n            translatedData.cachedWidth = img.dom.naturalWidth;\n            translatedData.cachedHeight = img.dom.naturalHeight;\n            applyFramePositioning();\n          }\n        });\n      });\n    };\n    var styles = {};\n    spec.height.each(function (h) {\n      return styles.height = h;\n    });\n    var fakeValidatedData = initialData.map(function (d) {\n      return {\n        url: d.url,\n        zoom: Optional.from(d.zoom),\n        cachedWidth: Optional.from(d.cachedWidth),\n        cachedHeight: Optional.from(d.cachedHeight)\n      };\n    });\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-imagepreview'],\n        styles: styles,\n        attributes: {\n          role: 'presentation'\n        }\n      },\n      components: [memContainer.asSpec()],\n      behaviours: derive$1([ComposingConfigs.self(), withComp(fakeValidatedData, function () {\n        return cachedData.get();\n      }, setValue)])\n    };\n  };\n  var renderLabel$2 = function renderLabel$2(spec, backstageShared) {\n    var baseClass = 'tox-label';\n    var centerClass = spec.align === 'center' ? [\"\".concat(baseClass, \"--center\")] : [];\n    var endClass = spec.align === 'end' ? [\"\".concat(baseClass, \"--end\")] : [];\n    var label = {\n      dom: {\n        tag: 'label',\n        classes: [baseClass].concat(centerClass, endClass)\n      },\n      components: [text$2(backstageShared.providers.translate(spec.label))]\n    };\n    var comps = map$2(spec.items, backstageShared.interpreter);\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-form__group']\n      },\n      components: [label].concat(_toConsumableArray(comps)),\n      behaviours: derive$1([ComposingConfigs.self(), Replacing.config({}), domHtml(Optional.none()), Keying.config({\n        mode: 'acyclic'\n      })])\n    };\n  };\n  var internalToolbarButtonExecute = generate$6('toolbar.button.execute');\n  var onToolbarButtonExecute = function onToolbarButtonExecute(info) {\n    return runOnExecute$1(function (comp, _simulatedEvent) {\n      runWithApi(info, comp)(function (itemApi) {\n        emitWith(comp, internalToolbarButtonExecute, {\n          buttonApi: itemApi\n        });\n        info.onAction(itemApi);\n      });\n    });\n  };\n  var commonButtonDisplayEvent = generate$6('common-button-display-events');\n  var toolbarButtonEventOrder = (_toolbarButtonEventOr = {}, _defineProperty(_toolbarButtonEventOr, execute$5(), ['disabling', 'alloy.base.behaviour', 'toggling', 'toolbar-button-events']), _defineProperty(_toolbarButtonEventOr, attachedToDom(), ['toolbar-button-events', commonButtonDisplayEvent]), _defineProperty(_toolbarButtonEventOr, mousedown(), ['focusing', 'alloy.base.behaviour', commonButtonDisplayEvent]), _toolbarButtonEventOr);\n  var forceInitialSize = function forceInitialSize(comp) {\n    return set$8(comp.element, 'width', get$e(comp.element, 'width'));\n  };\n  var renderIcon$1 = function renderIcon$1(iconName, iconsProvider, behaviours) {\n    return render$3(iconName, {\n      tag: 'span',\n      classes: ['tox-icon', 'tox-tbtn__icon-wrap'],\n      behaviours: behaviours\n    }, iconsProvider);\n  };\n  var renderIconFromPack$1 = function renderIconFromPack$1(iconName, iconsProvider) {\n    return renderIcon$1(iconName, iconsProvider, []);\n  };\n  var renderReplaceableIconFromPack = function renderReplaceableIconFromPack(iconName, iconsProvider) {\n    return renderIcon$1(iconName, iconsProvider, [Replacing.config({})]);\n  };\n  var renderLabel$1 = function renderLabel$1(text, prefix, providersBackstage) {\n    return {\n      dom: {\n        tag: 'span',\n        classes: [\"\".concat(prefix, \"__select-label\")]\n      },\n      components: [text$2(providersBackstage.translate(text))],\n      behaviours: derive$1([Replacing.config({})])\n    };\n  };\n  var updateMenuText = generate$6('update-menu-text');\n  var updateMenuIcon = generate$6('update-menu-icon');\n  var renderCommonDropdown = function renderCommonDropdown(spec, prefix, sharedBackstage) {\n    var editorOffCell = Cell(noop);\n    var optMemDisplayText = spec.text.map(function (text) {\n      return record(renderLabel$1(text, prefix, sharedBackstage.providers));\n    });\n    var optMemDisplayIcon = spec.icon.map(function (iconName) {\n      return record(renderReplaceableIconFromPack(iconName, sharedBackstage.providers.icons));\n    });\n    var onLeftOrRightInMenu = function onLeftOrRightInMenu(comp, se) {\n      var dropdown = Representing.getValue(comp);\n      Focusing.focus(dropdown);\n      emitWith(dropdown, 'keydown', {\n        raw: se.event.raw\n      });\n      Dropdown.close(dropdown);\n      return Optional.some(true);\n    };\n    var role = spec.role.fold(function () {\n      return {};\n    }, function (role) {\n      return {\n        role: role\n      };\n    });\n    var tooltipAttributes = spec.tooltip.fold(function () {\n      return {};\n    }, function (tooltip) {\n      var translatedTooltip = sharedBackstage.providers.translate(tooltip);\n      return {\n        'title': translatedTooltip,\n        'aria-label': translatedTooltip\n      };\n    });\n    var iconSpec = render$3('chevron-down', {\n      tag: 'div',\n      classes: [\"\".concat(prefix, \"__select-chevron\")]\n    }, sharedBackstage.providers.icons);\n    var fixWidthBehaviourName = generate$6('common-button-display-events');\n    var memDropdown = record(Dropdown.sketch(_objectSpread({}, spec.uid ? {\n      uid: spec.uid\n    } : {}, role, {\n      dom: {\n        tag: 'button',\n        classes: [prefix, \"\".concat(prefix, \"--select\")].concat(map$2(spec.classes, function (c) {\n          return \"\".concat(prefix, \"--\").concat(c);\n        })),\n        attributes: _objectSpread({}, tooltipAttributes)\n      },\n      components: componentRenderPipeline([optMemDisplayIcon.map(function (mem) {\n        return mem.asSpec();\n      }), optMemDisplayText.map(function (mem) {\n        return mem.asSpec();\n      }), Optional.some(iconSpec)]),\n      matchWidth: true,\n      useMinWidth: true,\n      onOpen: function onOpen(anchor, dropdownComp, tmenuComp) {\n        if (spec.searchable) {\n          focusSearchField(tmenuComp);\n        }\n      },\n      dropdownBehaviours: derive$1([].concat(_toConsumableArray(spec.dropdownBehaviours), [DisablingConfigs.button(function () {\n        return spec.disabled || sharedBackstage.providers.isDisabled();\n      }), receivingConfig(), Unselecting.config({}), Replacing.config({}), config('dropdown-events', [onControlAttached(spec, editorOffCell), onControlDetached(spec, editorOffCell)]), config(fixWidthBehaviourName, [runOnAttached(function (comp, _se) {\n        return forceInitialSize(comp);\n      })]), config('menubutton-update-display-text', [run$1(updateMenuText, function (comp, se) {\n        optMemDisplayText.bind(function (mem) {\n          return mem.getOpt(comp);\n        }).each(function (displayText) {\n          Replacing.set(displayText, [text$2(sharedBackstage.providers.translate(se.event.text))]);\n        });\n      }), run$1(updateMenuIcon, function (comp, se) {\n        optMemDisplayIcon.bind(function (mem) {\n          return mem.getOpt(comp);\n        }).each(function (displayIcon) {\n          Replacing.set(displayIcon, [renderReplaceableIconFromPack(se.event.icon, sharedBackstage.providers.icons)]);\n        });\n      })])])),\n      eventOrder: deepMerge(toolbarButtonEventOrder, _defineProperty({\n        mousedown: ['focusing', 'alloy.base.behaviour', 'item-type-events', 'normal-dropdown-events']\n      }, attachedToDom(), ['toolbar-button-events', 'dropdown-events', fixWidthBehaviourName])),\n      sandboxBehaviours: derive$1([Keying.config({\n        mode: 'special',\n        onLeft: onLeftOrRightInMenu,\n        onRight: onLeftOrRightInMenu\n      }), config('dropdown-sandbox-events', [run$1(refetchTriggerEvent, function (originalSandboxComp, se) {\n        handleRefetchTrigger(originalSandboxComp);\n        se.stop();\n      }), run$1(redirectMenuItemInteractionEvent, function (sandboxComp, se) {\n        handleRedirectToMenuItem(sandboxComp, se);\n        se.stop();\n      })])]),\n      lazySink: sharedBackstage.getSink,\n      toggleClass: \"\".concat(prefix, \"--active\"),\n      parts: {\n        menu: _objectSpread({}, part(false, spec.columns, spec.presets), {\n          fakeFocus: spec.searchable,\n          onHighlightItem: updateAriaOnHighlight,\n          onCollapseMenu: function onCollapseMenu(tmenuComp, itemCompCausingCollapse, nowActiveMenuComp) {\n            Highlighting.getHighlighted(nowActiveMenuComp).each(function (itemComp) {\n              updateAriaOnHighlight(tmenuComp, nowActiveMenuComp, itemComp);\n            });\n          },\n          onDehighlightItem: updateAriaOnDehighlight\n        })\n      },\n      getAnchorOverrides: function getAnchorOverrides() {\n        return {\n          maxHeightFunction: function maxHeightFunction(element, available) {\n            anchored()(element, available - 10);\n          }\n        };\n      },\n      fetch: function fetch(comp) {\n        return Future.nu(curry(spec.fetch, comp));\n      }\n    })));\n    return memDropdown.asSpec();\n  };\n  var isMenuItemReference = function isMenuItemReference(item) {\n    return isString(item);\n  };\n  var isSeparator$2 = function isSeparator$2(item) {\n    return item.type === 'separator';\n  };\n  var isExpandingMenuItem = function isExpandingMenuItem(item) {\n    return has$2(item, 'getSubmenuItems');\n  };\n  var separator$2 = {\n    type: 'separator'\n  };\n  var unwrapReferences = function unwrapReferences(items, menuItems) {\n    var realItems = foldl(items, function (acc, item) {\n      if (isMenuItemReference(item)) {\n        if (item === '') {\n          return acc;\n        } else if (item === '|') {\n          return acc.length > 0 && !isSeparator$2(acc[acc.length - 1]) ? acc.concat([separator$2]) : acc;\n        } else if (has$2(menuItems, item.toLowerCase())) {\n          return acc.concat([menuItems[item.toLowerCase()]]);\n        } else {\n          return acc;\n        }\n      } else {\n        return acc.concat([item]);\n      }\n    }, []);\n    if (realItems.length > 0 && isSeparator$2(realItems[realItems.length - 1])) {\n      realItems.pop();\n    }\n    return realItems;\n  };\n  var getFromExpandingItem = function getFromExpandingItem(item, menuItems) {\n    var submenuItems = item.getSubmenuItems();\n    var rest = expand(submenuItems, menuItems);\n    var newMenus = deepMerge(rest.menus, _defineProperty({}, item.value, rest.items));\n    var newExpansions = deepMerge(rest.expansions, _defineProperty({}, item.value, item.value));\n    return {\n      item: item,\n      menus: newMenus,\n      expansions: newExpansions\n    };\n  };\n  var generateValueIfRequired = function generateValueIfRequired(item) {\n    var itemValue = get$g(item, 'value').getOrThunk(function () {\n      return generate$6('generated-menu-item');\n    });\n    return deepMerge({\n      value: itemValue\n    }, item);\n  };\n  var expand = function expand(items, menuItems) {\n    var realItems = unwrapReferences(isString(items) ? items.split(' ') : items, menuItems);\n    return foldr(realItems, function (acc, item) {\n      if (isExpandingMenuItem(item)) {\n        var itemWithValue = generateValueIfRequired(item);\n        var newData = getFromExpandingItem(itemWithValue, menuItems);\n        return {\n          menus: deepMerge(acc.menus, newData.menus),\n          items: [newData.item].concat(_toConsumableArray(acc.items)),\n          expansions: deepMerge(acc.expansions, newData.expansions)\n        };\n      } else {\n        return _objectSpread({}, acc, {\n          items: [item].concat(_toConsumableArray(acc.items))\n        });\n      }\n    }, {\n      menus: {},\n      expansions: {},\n      items: []\n    });\n  };\n  var getSearchModeForField = function getSearchModeForField(settings) {\n    return settings.search.fold(function () {\n      return {\n        searchMode: 'no-search'\n      };\n    }, function (searchSettings) {\n      return {\n        searchMode: 'search-with-field',\n        placeholder: searchSettings.placeholder\n      };\n    });\n  };\n  var getSearchModeForResults = function getSearchModeForResults(settings) {\n    return settings.search.fold(function () {\n      return {\n        searchMode: 'no-search'\n      };\n    }, function (_) {\n      return {\n        searchMode: 'search-with-results'\n      };\n    });\n  };\n  var build = function build(items, itemResponse, backstage, settings) {\n    var primary = generate$6('primary-menu');\n    var data = expand(items, backstage.shared.providers.menuItems());\n    if (data.items.length === 0) {\n      return Optional.none();\n    }\n    var mainMenuSearchMode = getSearchModeForField(settings);\n    var mainMenu = createPartialMenu(primary, data.items, itemResponse, backstage, settings.isHorizontalMenu, mainMenuSearchMode);\n    var submenuSearchMode = getSearchModeForResults(settings);\n    var submenus = map$1(data.menus, function (menuItems, menuName) {\n      return createPartialMenu(menuName, menuItems, itemResponse, backstage, false, submenuSearchMode);\n    });\n    var menus = deepMerge(submenus, wrap$1(primary, mainMenu));\n    return Optional.from(tieredMenu.tieredData(primary, menus, data.expansions));\n  };\n  var isSingleListItem = function isSingleListItem(item) {\n    return !has$2(item, 'items');\n  };\n  var dataAttribute = 'data-value';\n  var fetchItems = function fetchItems(dropdownComp, name, items, selectedValue) {\n    return map$2(items, function (item) {\n      if (!isSingleListItem(item)) {\n        return {\n          type: 'nestedmenuitem',\n          text: item.text,\n          getSubmenuItems: function getSubmenuItems() {\n            return fetchItems(dropdownComp, name, item.items, selectedValue);\n          }\n        };\n      } else {\n        return {\n          type: 'togglemenuitem',\n          text: item.text,\n          value: item.value,\n          active: item.value === selectedValue,\n          onAction: function onAction() {\n            Representing.setValue(dropdownComp, item.value);\n            emitWith(dropdownComp, formChangeEvent, {\n              name: name\n            });\n            Focusing.focus(dropdownComp);\n          }\n        };\n      }\n    });\n  };\n  var findItemByValue = function findItemByValue(items, value) {\n    return findMap(items, function (item) {\n      if (!isSingleListItem(item)) {\n        return findItemByValue(item.items, value);\n      } else {\n        return someIf(item.value === value, item);\n      }\n    });\n  };\n  var renderListBox = function renderListBox(spec, backstage, initialData) {\n    var providersBackstage = backstage.shared.providers;\n    var initialItem = initialData.bind(function (value) {\n      return findItemByValue(spec.items, value);\n    }).orThunk(function () {\n      return head(spec.items).filter(isSingleListItem);\n    });\n    var pLabel = spec.label.map(function (label) {\n      return renderLabel$3(label, providersBackstage);\n    });\n    var pField = FormField.parts.field({\n      dom: {},\n      factory: {\n        sketch: function sketch(sketchSpec) {\n          return renderCommonDropdown({\n            uid: sketchSpec.uid,\n            text: initialItem.map(function (item) {\n              return item.text;\n            }),\n            icon: Optional.none(),\n            tooltip: spec.label,\n            role: Optional.none(),\n            fetch: function fetch(comp, callback) {\n              var items = fetchItems(comp, spec.name, spec.items, Representing.getValue(comp));\n              callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {\n                isHorizontalMenu: false,\n                search: Optional.none()\n              }));\n            },\n            onSetup: constant$1(noop),\n            getApi: constant$1({}),\n            columns: 1,\n            presets: 'normal',\n            classes: [],\n            dropdownBehaviours: [Tabstopping.config({}), withComp(initialItem.map(function (item) {\n              return item.value;\n            }), function (comp) {\n              return get$f(comp.element, dataAttribute);\n            }, function (comp, data) {\n              findItemByValue(spec.items, data).each(function (item) {\n                set$9(comp.element, dataAttribute, item.value);\n                emitWith(comp, updateMenuText, {\n                  text: item.text\n                });\n              });\n            })]\n          }, 'tox-listbox', backstage.shared);\n        }\n      }\n    });\n    var listBoxWrap = {\n      dom: {\n        tag: 'div',\n        classes: ['tox-listboxfield']\n      },\n      components: [pField]\n    };\n    return FormField.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-form__group']\n      },\n      components: flatten([pLabel.toArray(), [listBoxWrap]]),\n      fieldBehaviours: derive$1([Disabling.config({\n        disabled: constant$1(!spec.enabled),\n        onDisabled: function onDisabled(comp) {\n          FormField.getField(comp).each(Disabling.disable);\n        },\n        onEnabled: function onEnabled(comp) {\n          FormField.getField(comp).each(Disabling.enable);\n        }\n      })])\n    });\n  };\n  var renderPanel = function renderPanel(spec, backstage) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: spec.classes\n      },\n      components: map$2(spec.items, backstage.shared.interpreter)\n    };\n  };\n  var factory$h = function factory$h(detail, _spec) {\n    var options = map$2(detail.options, function (option) {\n      return {\n        dom: {\n          tag: 'option',\n          value: option.value,\n          innerHtml: option.text\n        }\n      };\n    });\n    var initialValues = detail.data.map(function (v) {\n      return wrap$1('initialValue', v);\n    }).getOr({});\n    return {\n      uid: detail.uid,\n      dom: {\n        tag: 'select',\n        classes: detail.selectClasses,\n        attributes: detail.selectAttributes\n      },\n      components: options,\n      behaviours: augment(detail.selectBehaviours, [Focusing.config({}), Representing.config({\n        store: _objectSpread({\n          mode: 'manual',\n          getValue: function getValue(select) {\n            return get$6(select.element);\n          },\n          setValue: function setValue(select, newValue) {\n            var firstOption = head(detail.options);\n            var found = find$5(detail.options, function (opt) {\n              return opt.value === newValue;\n            });\n            if (found.isSome()) {\n              set$5(select.element, newValue);\n            } else if (select.element.dom.selectedIndex === -1 && newValue === '') {\n              firstOption.each(function (value) {\n                return set$5(select.element, value.value);\n              });\n            }\n          }\n        }, initialValues)\n      })])\n    };\n  };\n  var HtmlSelect = single({\n    name: 'HtmlSelect',\n    configFields: [required$1('options'), field('selectBehaviours', [Focusing, Representing]), defaulted('selectClasses', []), defaulted('selectAttributes', {}), option$3('data')],\n    factory: factory$h\n  });\n  var renderSelectBox = function renderSelectBox(spec, providersBackstage, initialData) {\n    var translatedOptions = map$2(spec.items, function (item) {\n      return {\n        text: providersBackstage.translate(item.text),\n        value: item.value\n      };\n    });\n    var pLabel = spec.label.map(function (label) {\n      return renderLabel$3(label, providersBackstage);\n    });\n    var pField = FormField.parts.field(_objectSpread({\n      dom: {}\n    }, initialData.map(function (data) {\n      return {\n        data: data\n      };\n    }).getOr({}), {\n      selectAttributes: {\n        size: spec.size\n      },\n      options: translatedOptions,\n      factory: HtmlSelect,\n      selectBehaviours: derive$1([Disabling.config({\n        disabled: function disabled() {\n          return !spec.enabled || providersBackstage.isDisabled();\n        }\n      }), Tabstopping.config({}), config('selectbox-change', [run$1(change(), function (component, _) {\n        emitWith(component, formChangeEvent, {\n          name: spec.name\n        });\n      })])])\n    }));\n    var chevron = spec.size > 1 ? Optional.none() : Optional.some(render$3('chevron-down', {\n      tag: 'div',\n      classes: ['tox-selectfield__icon-js']\n    }, providersBackstage.icons));\n    var selectWrap = {\n      dom: {\n        tag: 'div',\n        classes: ['tox-selectfield']\n      },\n      components: flatten([[pField], chevron.toArray()])\n    };\n    return FormField.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-form__group']\n      },\n      components: flatten([pLabel.toArray(), [selectWrap]]),\n      fieldBehaviours: derive$1([Disabling.config({\n        disabled: function disabled() {\n          return !spec.enabled || providersBackstage.isDisabled();\n        },\n        onDisabled: function onDisabled(comp) {\n          FormField.getField(comp).each(Disabling.disable);\n        },\n        onEnabled: function onEnabled(comp) {\n          FormField.getField(comp).each(Disabling.enable);\n        }\n      }), receivingConfig()])\n    });\n  };\n  var schema$h = constant$1([defaulted('field1Name', 'field1'), defaulted('field2Name', 'field2'), onStrictHandler('onLockedChange'), markers$1(['lockClass']), defaulted('locked', false), SketchBehaviours.field('coupledFieldBehaviours', [Composing, Representing])]);\n  var getField = function getField(comp, detail, partName) {\n    return getPart(comp, detail, partName).bind(Composing.getCurrent);\n  };\n  var coupledPart = function coupledPart(selfName, otherName) {\n    return required({\n      factory: FormField,\n      name: selfName,\n      overrides: function overrides(detail) {\n        return {\n          fieldBehaviours: derive$1([config('coupled-input-behaviour', [run$1(input(), function (me) {\n            getField(me, detail, otherName).each(function (other) {\n              getPart(me, detail, 'lock').each(function (lock) {\n                if (Toggling.isOn(lock)) {\n                  detail.onLockedChange(me, other, lock);\n                }\n              });\n            });\n          })])])\n        };\n      }\n    });\n  };\n  var parts$c = constant$1([coupledPart('field1', 'field2'), coupledPart('field2', 'field1'), required({\n    factory: Button,\n    schema: [required$1('dom')],\n    name: 'lock',\n    overrides: function overrides(detail) {\n      return {\n        buttonBehaviours: derive$1([Toggling.config({\n          selected: detail.locked,\n          toggleClass: detail.markers.lockClass,\n          aria: {\n            mode: 'pressed'\n          }\n        })])\n      };\n    }\n  })]);\n  var factory$g = function factory$g(detail, components, _spec, _externals) {\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      behaviours: SketchBehaviours.augment(detail.coupledFieldBehaviours, [Composing.config({\n        find: Optional.some\n      }), Representing.config({\n        store: {\n          mode: 'manual',\n          getValue: function getValue(comp) {\n            var _ref11;\n            var parts = getPartsOrDie(comp, detail, ['field1', 'field2']);\n            return _ref11 = {}, _defineProperty(_ref11, detail.field1Name, Representing.getValue(parts.field1())), _defineProperty(_ref11, detail.field2Name, Representing.getValue(parts.field2())), _ref11;\n          },\n          setValue: function setValue(comp, value) {\n            var parts = getPartsOrDie(comp, detail, ['field1', 'field2']);\n            if (hasNonNullableKey(value, detail.field1Name)) {\n              Representing.setValue(parts.field1(), value[detail.field1Name]);\n            }\n            if (hasNonNullableKey(value, detail.field2Name)) {\n              Representing.setValue(parts.field2(), value[detail.field2Name]);\n            }\n          }\n        }\n      })]),\n      apis: {\n        getField1: function getField1(component) {\n          return getPart(component, detail, 'field1');\n        },\n        getField2: function getField2(component) {\n          return getPart(component, detail, 'field2');\n        },\n        getLock: function getLock(component) {\n          return getPart(component, detail, 'lock');\n        }\n      }\n    };\n  };\n  var FormCoupledInputs = composite({\n    name: 'FormCoupledInputs',\n    configFields: schema$h(),\n    partFields: parts$c(),\n    factory: factory$g,\n    apis: {\n      getField1: function getField1(apis, component) {\n        return apis.getField1(component);\n      },\n      getField2: function getField2(apis, component) {\n        return apis.getField2(component);\n      },\n      getLock: function getLock(apis, component) {\n        return apis.getLock(component);\n      }\n    }\n  });\n  var formatSize = function formatSize(size) {\n    var unitDec = {\n      '': 0,\n      'px': 0,\n      'pt': 1,\n      'mm': 1,\n      'pc': 2,\n      'ex': 2,\n      'em': 2,\n      'ch': 2,\n      'rem': 2,\n      'cm': 3,\n      'in': 4,\n      '%': 4\n    };\n    var maxDecimal = function maxDecimal(unit) {\n      return unit in unitDec ? unitDec[unit] : 1;\n    };\n    var numText = size.value.toFixed(maxDecimal(size.unit));\n    if (numText.indexOf('.') !== -1) {\n      numText = numText.replace(/\\.?0*$/, '');\n    }\n    return numText + size.unit;\n  };\n  var parseSize = function parseSize(sizeText) {\n    var numPattern = /^\\s*(\\d+(?:\\.\\d+)?)\\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\\s*$/;\n    var match = numPattern.exec(sizeText);\n    if (match !== null) {\n      var _value4 = parseFloat(match[1]);\n      var unit = match[2];\n      return Result.value({\n        value: _value4,\n        unit: unit\n      });\n    } else {\n      return Result.error(sizeText);\n    }\n  };\n  var convertUnit = function convertUnit(size, unit) {\n    var inInch = {\n      '': 96,\n      'px': 96,\n      'pt': 72,\n      'cm': 2.54,\n      'pc': 12,\n      'mm': 25.4,\n      'in': 1\n    };\n    var supported = function supported(u) {\n      return has$2(inInch, u);\n    };\n    if (size.unit === unit) {\n      return Optional.some(size.value);\n    } else if (supported(size.unit) && supported(unit)) {\n      if (inInch[size.unit] === inInch[unit]) {\n        return Optional.some(size.value);\n      } else {\n        return Optional.some(size.value / inInch[size.unit] * inInch[unit]);\n      }\n    } else {\n      return Optional.none();\n    }\n  };\n  var noSizeConversion = function noSizeConversion(_input) {\n    return Optional.none();\n  };\n  var ratioSizeConversion = function ratioSizeConversion(scale, unit) {\n    return function (size) {\n      return convertUnit(size, unit).map(function (value) {\n        return {\n          value: value * scale,\n          unit: unit\n        };\n      });\n    };\n  };\n  var makeRatioConverter = function makeRatioConverter(currentFieldText, otherFieldText) {\n    var cValue = parseSize(currentFieldText).toOptional();\n    var oValue = parseSize(otherFieldText).toOptional();\n    return lift2(cValue, oValue, function (cSize, oSize) {\n      return convertUnit(cSize, oSize.unit).map(function (val) {\n        return oSize.value / val;\n      }).map(function (r) {\n        return ratioSizeConversion(r, oSize.unit);\n      }).getOr(noSizeConversion);\n    }).getOr(noSizeConversion);\n  };\n  var renderSizeInput = function renderSizeInput(spec, providersBackstage) {\n    var converter = noSizeConversion;\n    var ratioEvent = generate$6('ratio-event');\n    var makeIcon = function makeIcon(iconName) {\n      return render$3(iconName, {\n        tag: 'span',\n        classes: ['tox-icon', 'tox-lock-icon__' + iconName]\n      }, providersBackstage.icons);\n    };\n    var pLock = FormCoupledInputs.parts.lock({\n      dom: {\n        tag: 'button',\n        classes: ['tox-lock', 'tox-button', 'tox-button--naked', 'tox-button--icon'],\n        attributes: {\n          title: providersBackstage.translate(spec.label.getOr('Constrain proportions'))\n        }\n      },\n      components: [makeIcon('lock'), makeIcon('unlock')],\n      buttonBehaviours: derive$1([Disabling.config({\n        disabled: function disabled() {\n          return !spec.enabled || providersBackstage.isDisabled();\n        }\n      }), receivingConfig(), Tabstopping.config({})])\n    });\n    var formGroup = function formGroup(components) {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__group']\n        },\n        components: components\n      };\n    };\n    var getFieldPart = function getFieldPart(isField1) {\n      return FormField.parts.field({\n        factory: Input,\n        inputClasses: ['tox-textfield'],\n        inputBehaviours: derive$1([Disabling.config({\n          disabled: function disabled() {\n            return !spec.enabled || providersBackstage.isDisabled();\n          }\n        }), receivingConfig(), Tabstopping.config({}), config('size-input-events', [run$1(focusin(), function (component, _simulatedEvent) {\n          emitWith(component, ratioEvent, {\n            isField1: isField1\n          });\n        }), run$1(change(), function (component, _simulatedEvent) {\n          emitWith(component, formChangeEvent, {\n            name: spec.name\n          });\n        })])]),\n        selectOnFocus: false\n      });\n    };\n    var getLabel = function getLabel(label) {\n      return {\n        dom: {\n          tag: 'label',\n          classes: ['tox-label']\n        },\n        components: [text$2(providersBackstage.translate(label))]\n      };\n    };\n    var widthField = FormCoupledInputs.parts.field1(formGroup([FormField.parts.label(getLabel('Width')), getFieldPart(true)]));\n    var heightField = FormCoupledInputs.parts.field2(formGroup([FormField.parts.label(getLabel('Height')), getFieldPart(false)]));\n    return FormCoupledInputs.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-form__group']\n      },\n      components: [{\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__controls-h-stack']\n        },\n        components: [widthField, heightField, formGroup([getLabel(nbsp), pLock])]\n      }],\n      field1Name: 'width',\n      field2Name: 'height',\n      locked: true,\n      markers: {\n        lockClass: 'tox-locked'\n      },\n      onLockedChange: function onLockedChange(current, other, _lock) {\n        parseSize(Representing.getValue(current)).each(function (size) {\n          converter(size).each(function (newSize) {\n            Representing.setValue(other, formatSize(newSize));\n          });\n        });\n      },\n      coupledFieldBehaviours: derive$1([Disabling.config({\n        disabled: function disabled() {\n          return !spec.enabled || providersBackstage.isDisabled();\n        },\n        onDisabled: function onDisabled(comp) {\n          FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.disable);\n          FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.disable);\n          FormCoupledInputs.getLock(comp).each(Disabling.disable);\n        },\n        onEnabled: function onEnabled(comp) {\n          FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.enable);\n          FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.enable);\n          FormCoupledInputs.getLock(comp).each(Disabling.enable);\n        }\n      }), receivingConfig(), config('size-input-events2', [run$1(ratioEvent, function (component, simulatedEvent) {\n        var isField1 = simulatedEvent.event.isField1;\n        var optCurrent = isField1 ? FormCoupledInputs.getField1(component) : FormCoupledInputs.getField2(component);\n        var optOther = isField1 ? FormCoupledInputs.getField2(component) : FormCoupledInputs.getField1(component);\n        var value1 = optCurrent.map(Representing.getValue).getOr('');\n        var value2 = optOther.map(Representing.getValue).getOr('');\n        converter = makeRatioConverter(value1, value2);\n      })])])\n    });\n  };\n  var renderSlider = function renderSlider(spec, providerBackstage, initialData) {\n    var labelPart = Slider.parts.label({\n      dom: {\n        tag: 'label',\n        classes: ['tox-label']\n      },\n      components: [text$2(providerBackstage.translate(spec.label))]\n    });\n    var spectrum = Slider.parts.spectrum({\n      dom: {\n        tag: 'div',\n        classes: ['tox-slider__rail'],\n        attributes: {\n          role: 'presentation'\n        }\n      }\n    });\n    var thumb = Slider.parts.thumb({\n      dom: {\n        tag: 'div',\n        classes: ['tox-slider__handle'],\n        attributes: {\n          role: 'presentation'\n        }\n      }\n    });\n    return Slider.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-slider'],\n        attributes: {\n          role: 'presentation'\n        }\n      },\n      model: {\n        mode: 'x',\n        minX: spec.min,\n        maxX: spec.max,\n        getInitialValue: constant$1(initialData.getOrThunk(function () {\n          return (Math.abs(spec.max) - Math.abs(spec.min)) / 2;\n        }))\n      },\n      components: [labelPart, spectrum, thumb],\n      sliderBehaviours: derive$1([ComposingConfigs.self(), Focusing.config({})]),\n      onChoose: function onChoose(component, thumb, value) {\n        emitWith(component, formChangeEvent, {\n          name: spec.name,\n          value: value\n        });\n      }\n    });\n  };\n  var renderTable = function renderTable(spec, providersBackstage) {\n    var renderTh = function renderTh(text) {\n      return {\n        dom: {\n          tag: 'th',\n          innerHtml: providersBackstage.translate(text)\n        }\n      };\n    };\n    var renderHeader = function renderHeader(header) {\n      return {\n        dom: {\n          tag: 'thead'\n        },\n        components: [{\n          dom: {\n            tag: 'tr'\n          },\n          components: map$2(header, renderTh)\n        }]\n      };\n    };\n    var renderTd = function renderTd(text) {\n      return {\n        dom: {\n          tag: 'td',\n          innerHtml: providersBackstage.translate(text)\n        }\n      };\n    };\n    var renderTr = function renderTr(row) {\n      return {\n        dom: {\n          tag: 'tr'\n        },\n        components: map$2(row, renderTd)\n      };\n    };\n    var renderRows = function renderRows(rows) {\n      return {\n        dom: {\n          tag: 'tbody'\n        },\n        components: map$2(rows, renderTr)\n      };\n    };\n    return {\n      dom: {\n        tag: 'table',\n        classes: ['tox-dialog__table']\n      },\n      components: [renderHeader(spec.header), renderRows(spec.cells)],\n      behaviours: derive$1([Tabstopping.config({}), Focusing.config({})])\n    };\n  };\n  var renderTextField = function renderTextField(spec, providersBackstage) {\n    var pLabel = spec.label.map(function (label) {\n      return renderLabel$3(label, providersBackstage);\n    });\n    var baseInputBehaviours = [Disabling.config({\n      disabled: function disabled() {\n        return spec.disabled || providersBackstage.isDisabled();\n      }\n    }), receivingConfig(), Keying.config({\n      mode: 'execution',\n      useEnter: spec.multiline !== true,\n      useControlEnter: spec.multiline === true,\n      execute: function execute(comp) {\n        emit(comp, formSubmitEvent);\n        return Optional.some(true);\n      }\n    }), config('textfield-change', [run$1(input(), function (component, _) {\n      emitWith(component, formChangeEvent, {\n        name: spec.name\n      });\n    }), run$1(postPaste(), function (component, _) {\n      emitWith(component, formChangeEvent, {\n        name: spec.name\n      });\n    })]), Tabstopping.config({})];\n    var validatingBehaviours = spec.validation.map(function (vl) {\n      return Invalidating.config({\n        getRoot: function getRoot(input) {\n          return parentElement(input.element);\n        },\n        invalidClass: 'tox-invalid',\n        validator: {\n          validate: function validate(input) {\n            var v = Representing.getValue(input);\n            var result = vl.validator(v);\n            return Future.pure(result === true ? Result.value(v) : Result.error(result));\n          },\n          validateOnLoad: vl.validateOnLoad\n        }\n      });\n    }).toArray();\n    var placeholder = spec.placeholder.fold(constant$1({}), function (p) {\n      return {\n        placeholder: providersBackstage.translate(p)\n      };\n    });\n    var inputMode = spec.inputMode.fold(constant$1({}), function (mode) {\n      return {\n        inputmode: mode\n      };\n    });\n    var inputAttributes = _objectSpread({}, placeholder, inputMode);\n    var pField = FormField.parts.field(_objectSpread({\n      tag: spec.multiline === true ? 'textarea' : 'input'\n    }, spec.data.map(function (data) {\n      return {\n        data: data\n      };\n    }).getOr({}), {\n      inputAttributes: inputAttributes,\n      inputClasses: [spec.classname],\n      inputBehaviours: derive$1(flatten([baseInputBehaviours, validatingBehaviours])),\n      selectOnFocus: false,\n      factory: Input\n    }));\n    var pTextField = spec.multiline ? {\n      dom: {\n        tag: 'div',\n        classes: ['tox-textarea-wrap']\n      },\n      components: [pField]\n    } : pField;\n    var extraClasses = spec.flex ? ['tox-form__group--stretched'] : [];\n    var extraClasses2 = extraClasses.concat(spec.maximized ? ['tox-form-group--maximize'] : []);\n    var extraBehaviours = [Disabling.config({\n      disabled: function disabled() {\n        return spec.disabled || providersBackstage.isDisabled();\n      },\n      onDisabled: function onDisabled(comp) {\n        FormField.getField(comp).each(Disabling.disable);\n      },\n      onEnabled: function onEnabled(comp) {\n        FormField.getField(comp).each(Disabling.enable);\n      }\n    }), receivingConfig()];\n    return renderFormFieldWith(pLabel, pTextField, extraClasses2, extraBehaviours);\n  };\n  var renderInput = function renderInput(spec, providersBackstage, initialData) {\n    return renderTextField({\n      name: spec.name,\n      multiline: false,\n      label: spec.label,\n      inputMode: spec.inputMode,\n      placeholder: spec.placeholder,\n      flex: false,\n      disabled: !spec.enabled,\n      classname: 'tox-textfield',\n      validation: Optional.none(),\n      maximized: spec.maximized,\n      data: initialData\n    }, providersBackstage);\n  };\n  var renderTextarea = function renderTextarea(spec, providersBackstage, initialData) {\n    return renderTextField({\n      name: spec.name,\n      multiline: true,\n      label: spec.label,\n      inputMode: Optional.none(),\n      placeholder: spec.placeholder,\n      flex: true,\n      disabled: !spec.enabled,\n      classname: 'tox-textarea',\n      validation: Optional.none(),\n      maximized: spec.maximized,\n      data: initialData\n    }, providersBackstage);\n  };\n  var getAnimationRoot = function getAnimationRoot(component, slideConfig) {\n    return slideConfig.getAnimationRoot.fold(function () {\n      return component.element;\n    }, function (get) {\n      return get(component);\n    });\n  };\n  var getDimensionProperty = function getDimensionProperty(slideConfig) {\n    return slideConfig.dimension.property;\n  };\n  var getDimension = function getDimension(slideConfig, elem) {\n    return slideConfig.dimension.getDimension(elem);\n  };\n  var disableTransitions = function disableTransitions(component, slideConfig) {\n    var root = getAnimationRoot(component, slideConfig);\n    remove$1(root, [slideConfig.shrinkingClass, slideConfig.growingClass]);\n  };\n  var setShrunk = function setShrunk(component, slideConfig) {\n    remove$2(component.element, slideConfig.openClass);\n    add$2(component.element, slideConfig.closedClass);\n    set$8(component.element, getDimensionProperty(slideConfig), '0px');\n    reflow(component.element);\n  };\n  var setGrown = function setGrown(component, slideConfig) {\n    remove$2(component.element, slideConfig.closedClass);\n    add$2(component.element, slideConfig.openClass);\n    remove$6(component.element, getDimensionProperty(slideConfig));\n  };\n  var doImmediateShrink = function doImmediateShrink(component, slideConfig, slideState, _calculatedSize) {\n    slideState.setCollapsed();\n    set$8(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));\n    disableTransitions(component, slideConfig);\n    setShrunk(component, slideConfig);\n    slideConfig.onStartShrink(component);\n    slideConfig.onShrunk(component);\n  };\n  var doStartShrink = function doStartShrink(component, slideConfig, slideState, calculatedSize) {\n    var size = calculatedSize.getOrThunk(function () {\n      return getDimension(slideConfig, component.element);\n    });\n    slideState.setCollapsed();\n    set$8(component.element, getDimensionProperty(slideConfig), size);\n    reflow(component.element);\n    var root = getAnimationRoot(component, slideConfig);\n    remove$2(root, slideConfig.growingClass);\n    add$2(root, slideConfig.shrinkingClass);\n    setShrunk(component, slideConfig);\n    slideConfig.onStartShrink(component);\n  };\n  var doStartSmartShrink = function doStartSmartShrink(component, slideConfig, slideState) {\n    var size = getDimension(slideConfig, component.element);\n    var shrinker = size === '0px' ? doImmediateShrink : doStartShrink;\n    shrinker(component, slideConfig, slideState, Optional.some(size));\n  };\n  var doStartGrow = function doStartGrow(component, slideConfig, slideState) {\n    var root = getAnimationRoot(component, slideConfig);\n    var wasShrinking = has(root, slideConfig.shrinkingClass);\n    var beforeSize = getDimension(slideConfig, component.element);\n    setGrown(component, slideConfig);\n    var fullSize = getDimension(slideConfig, component.element);\n    var startPartialGrow = function startPartialGrow() {\n      set$8(component.element, getDimensionProperty(slideConfig), beforeSize);\n      reflow(component.element);\n    };\n    var startCompleteGrow = function startCompleteGrow() {\n      setShrunk(component, slideConfig);\n    };\n    var setStartSize = wasShrinking ? startPartialGrow : startCompleteGrow;\n    setStartSize();\n    remove$2(root, slideConfig.shrinkingClass);\n    add$2(root, slideConfig.growingClass);\n    setGrown(component, slideConfig);\n    set$8(component.element, getDimensionProperty(slideConfig), fullSize);\n    slideState.setExpanded();\n    slideConfig.onStartGrow(component);\n  };\n  var refresh$4 = function refresh$4(component, slideConfig, slideState) {\n    if (slideState.isExpanded()) {\n      remove$6(component.element, getDimensionProperty(slideConfig));\n      var fullSize = getDimension(slideConfig, component.element);\n      set$8(component.element, getDimensionProperty(slideConfig), fullSize);\n    }\n  };\n  var grow = function grow(component, slideConfig, slideState) {\n    if (!slideState.isExpanded()) {\n      doStartGrow(component, slideConfig, slideState);\n    }\n  };\n  var shrink = function shrink(component, slideConfig, slideState) {\n    if (slideState.isExpanded()) {\n      doStartSmartShrink(component, slideConfig, slideState);\n    }\n  };\n  var immediateShrink = function immediateShrink(component, slideConfig, slideState) {\n    if (slideState.isExpanded()) {\n      doImmediateShrink(component, slideConfig, slideState);\n    }\n  };\n  var hasGrown = function hasGrown(component, slideConfig, slideState) {\n    return slideState.isExpanded();\n  };\n  var hasShrunk = function hasShrunk(component, slideConfig, slideState) {\n    return slideState.isCollapsed();\n  };\n  var isGrowing = function isGrowing(component, slideConfig, _slideState) {\n    var root = getAnimationRoot(component, slideConfig);\n    return has(root, slideConfig.growingClass) === true;\n  };\n  var isShrinking = function isShrinking(component, slideConfig, _slideState) {\n    var root = getAnimationRoot(component, slideConfig);\n    return has(root, slideConfig.shrinkingClass) === true;\n  };\n  var isTransitioning = function isTransitioning(component, slideConfig, slideState) {\n    return isGrowing(component, slideConfig) || isShrinking(component, slideConfig);\n  };\n  var toggleGrow = function toggleGrow(component, slideConfig, slideState) {\n    var f = slideState.isExpanded() ? doStartSmartShrink : doStartGrow;\n    f(component, slideConfig, slideState);\n  };\n  var immediateGrow = function immediateGrow(component, slideConfig, slideState) {\n    if (!slideState.isExpanded()) {\n      setGrown(component, slideConfig);\n      set$8(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));\n      disableTransitions(component, slideConfig);\n      slideState.setExpanded();\n      slideConfig.onStartGrow(component);\n      slideConfig.onGrown(component);\n    }\n  };\n  var SlidingApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    refresh: refresh$4,\n    grow: grow,\n    shrink: shrink,\n    immediateShrink: immediateShrink,\n    hasGrown: hasGrown,\n    hasShrunk: hasShrunk,\n    isGrowing: isGrowing,\n    isShrinking: isShrinking,\n    isTransitioning: isTransitioning,\n    toggleGrow: toggleGrow,\n    disableTransitions: disableTransitions,\n    immediateGrow: immediateGrow\n  });\n  var exhibit = function exhibit(base, slideConfig, _slideState) {\n    var expanded = slideConfig.expanded;\n    return expanded ? nu$7({\n      classes: [slideConfig.openClass],\n      styles: {}\n    }) : nu$7({\n      classes: [slideConfig.closedClass],\n      styles: wrap$1(slideConfig.dimension.property, '0px')\n    });\n  };\n  var events$6 = function events$6(slideConfig, slideState) {\n    return derive$2([runOnSource(transitionend(), function (component, simulatedEvent) {\n      var raw = simulatedEvent.event.raw;\n      if (raw.propertyName === slideConfig.dimension.property) {\n        disableTransitions(component, slideConfig);\n        if (slideState.isExpanded()) {\n          remove$6(component.element, slideConfig.dimension.property);\n        }\n        var notify = slideState.isExpanded() ? slideConfig.onGrown : slideConfig.onShrunk;\n        notify(component);\n      }\n    })]);\n  };\n  var ActiveSliding = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    exhibit: exhibit,\n    events: events$6\n  });\n  var SlidingSchema = [required$1('closedClass'), required$1('openClass'), required$1('shrinkingClass'), required$1('growingClass'), option$3('getAnimationRoot'), onHandler('onShrunk'), onHandler('onStartShrink'), onHandler('onGrown'), onHandler('onStartGrow'), defaulted('expanded', false), requiredOf('dimension', choose$1('property', {\n    width: [output$1('property', 'width'), output$1('getDimension', function (elem) {\n      return get$c(elem) + 'px';\n    })],\n    height: [output$1('property', 'height'), output$1('getDimension', function (elem) {\n      return get$d(elem) + 'px';\n    })]\n  }))];\n  var init$9 = function init$9(spec) {\n    var state = Cell(spec.expanded);\n    var readState = function readState() {\n      return 'expanded: ' + state.get();\n    };\n    return nu$8({\n      isExpanded: function isExpanded() {\n        return state.get() === true;\n      },\n      isCollapsed: function isCollapsed() {\n        return state.get() === false;\n      },\n      setCollapsed: curry(state.set, false),\n      setExpanded: curry(state.set, true),\n      readState: readState\n    });\n  };\n  var SlidingState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    init: init$9\n  });\n  var Sliding = create$4({\n    fields: SlidingSchema,\n    name: 'sliding',\n    active: ActiveSliding,\n    apis: SlidingApis,\n    state: SlidingState\n  });\n  var getMenuButtonApi = function getMenuButtonApi(component) {\n    return {\n      isEnabled: function isEnabled() {\n        return !Disabling.isDisabled(component);\n      },\n      setEnabled: function setEnabled(state) {\n        return Disabling.set(component, !state);\n      },\n      setActive: function setActive(state) {\n        var elm = component.element;\n        if (state) {\n          add$2(elm, 'tox-tbtn--enabled');\n          set$9(elm, 'aria-pressed', true);\n        } else {\n          remove$2(elm, 'tox-tbtn--enabled');\n          remove$7(elm, 'aria-pressed');\n        }\n      },\n      isActive: function isActive() {\n        return has(component.element, 'tox-tbtn--enabled');\n      },\n      setText: function setText(text) {\n        emitWith(component, updateMenuText, {\n          text: text\n        });\n      },\n      setIcon: function setIcon(icon) {\n        return emitWith(component, updateMenuIcon, {\n          icon: icon\n        });\n      }\n    };\n  };\n  var renderMenuButton = function renderMenuButton(spec, prefix, backstage, role) {\n    var tabstopping = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    return renderCommonDropdown({\n      text: spec.text,\n      icon: spec.icon,\n      tooltip: spec.tooltip,\n      searchable: spec.search.isSome(),\n      role: role,\n      fetch: function fetch(dropdownComp, callback) {\n        var fetchContext = {\n          pattern: spec.search.isSome() ? getSearchPattern(dropdownComp) : ''\n        };\n        spec.fetch(function (items) {\n          callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {\n            isHorizontalMenu: false,\n            search: spec.search\n          }));\n        }, fetchContext, getMenuButtonApi(dropdownComp));\n      },\n      onSetup: spec.onSetup,\n      getApi: getMenuButtonApi,\n      columns: 1,\n      presets: 'normal',\n      classes: [],\n      dropdownBehaviours: _toConsumableArray(tabstopping ? [Tabstopping.config({})] : [])\n    }, prefix, backstage.shared);\n  };\n  var getFetch = function getFetch(items, getButton, backstage) {\n    var getMenuItemAction = function getMenuItemAction(item) {\n      return function (api) {\n        var newValue = !api.isActive();\n        api.setActive(newValue);\n        item.storage.set(newValue);\n        backstage.shared.getSink().each(function (sink) {\n          getButton().getOpt(sink).each(function (orig) {\n            focus$3(orig.element);\n            emitWith(orig, formActionEvent, {\n              name: item.name,\n              value: item.storage.get()\n            });\n          });\n        });\n      };\n    };\n    var getMenuItemSetup = function getMenuItemSetup(item) {\n      return function (api) {\n        api.setActive(item.storage.get());\n      };\n    };\n    return function (success) {\n      success(map$2(items, function (item) {\n        var text = item.text.fold(function () {\n          return {};\n        }, function (text) {\n          return {\n            text: text\n          };\n        });\n        return _objectSpread({\n          type: item.type,\n          active: false\n        }, text, {\n          onAction: getMenuItemAction(item),\n          onSetup: getMenuItemSetup(item)\n        });\n      }));\n    };\n  };\n  var renderLabel = function renderLabel(text) {\n    return {\n      dom: {\n        tag: 'span',\n        classes: ['tox-tree__label'],\n        attributes: {\n          'title': text,\n          'aria-label': text\n        }\n      },\n      components: [text$2(text)]\n    };\n  };\n  var leafLabelEventsId = generate$6('leaf-label-event-id');\n  var renderLeafLabel = function renderLeafLabel(_ref12) {\n    var leaf = _ref12.leaf,\n      onLeafAction = _ref12.onLeafAction,\n      visible = _ref12.visible,\n      treeId = _ref12.treeId,\n      selectedId = _ref12.selectedId,\n      backstage = _ref12.backstage;\n    var internalMenuButton = leaf.menu.map(function (btn) {\n      return renderMenuButton(btn, 'tox-mbtn', backstage, Optional.none(), visible);\n    });\n    var components = [renderLabel(leaf.title)];\n    internalMenuButton.each(function (btn) {\n      return components.push(btn);\n    });\n    return Button.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-tree--leaf__label', 'tox-trbtn'].concat(visible ? ['tox-tree--leaf__label--visible'] : [])\n      },\n      components: components,\n      role: 'treeitem',\n      action: function action(button) {\n        onLeafAction(leaf.id);\n        button.getSystem().broadcastOn([\"update-active-item-\".concat(treeId)], {\n          value: leaf.id\n        });\n      },\n      eventOrder: _defineProperty({}, keydown(), [leafLabelEventsId, 'keying']),\n      buttonBehaviours: derive$1([].concat(_toConsumableArray(visible ? [Tabstopping.config({})] : []), [Toggling.config({\n        toggleClass: 'tox-trbtn--enabled',\n        toggleOnExecute: false,\n        aria: {\n          mode: 'selected'\n        }\n      }), Receiving.config({\n        channels: _defineProperty({}, \"update-active-item-\".concat(treeId), {\n          onReceive: function onReceive(comp, message) {\n            (message.value === leaf.id ? Toggling.on : Toggling.off)(comp);\n          }\n        })\n      }), config(leafLabelEventsId, [runOnAttached(function (comp, _se) {\n        selectedId.each(function (id) {\n          var toggle = id === leaf.id ? Toggling.on : Toggling.off;\n          toggle(comp);\n        });\n      }), run$1(keydown(), function (comp, se) {\n        var isLeftArrowKey = se.event.raw.code === 'ArrowLeft';\n        var isRightArrowKey = se.event.raw.code === 'ArrowRight';\n        if (isLeftArrowKey) {\n          ancestor(comp.element, '.tox-tree--directory').each(function (dirElement) {\n            comp.getSystem().getByDom(dirElement).each(function (dirComp) {\n              child(dirElement, '.tox-tree--directory__label').each(function (dirLabelElement) {\n                dirComp.getSystem().getByDom(dirLabelElement).each(Focusing.focus);\n              });\n            });\n          });\n          se.stop();\n        } else if (isRightArrowKey) {\n          se.stop();\n        }\n      })])]))\n    });\n  };\n  var renderIcon = function renderIcon(iconName, iconsProvider, behaviours) {\n    return render$3(iconName, {\n      tag: 'span',\n      classes: ['tox-tree__icon-wrap', 'tox-icon'],\n      behaviours: behaviours\n    }, iconsProvider);\n  };\n  var renderIconFromPack = function renderIconFromPack(iconName, iconsProvider) {\n    return renderIcon(iconName, iconsProvider, []);\n  };\n  var directoryLabelEventsId = generate$6('directory-label-event-id');\n  var renderDirectoryLabel = function renderDirectoryLabel(_ref13) {\n    var directory = _ref13.directory,\n      visible = _ref13.visible,\n      noChildren = _ref13.noChildren,\n      backstage = _ref13.backstage;\n    var internalMenuButton = directory.menu.map(function (btn) {\n      return renderMenuButton(btn, 'tox-mbtn', backstage, Optional.none());\n    });\n    var components = [{\n      dom: {\n        tag: 'div',\n        classes: ['tox-chevron']\n      },\n      components: [renderIconFromPack('chevron-right', backstage.shared.providers.icons)]\n    }, renderLabel(directory.title)];\n    internalMenuButton.each(function (btn) {\n      components.push(btn);\n    });\n    var toggleExpandChildren = function toggleExpandChildren(button) {\n      ancestor(button.element, '.tox-tree--directory').each(function (directoryEle) {\n        button.getSystem().getByDom(directoryEle).each(function (directoryComp) {\n          var willExpand = !Toggling.isOn(directoryComp);\n          Toggling.toggle(directoryComp);\n          emitWith(button, 'expand-tree-node', {\n            expanded: willExpand,\n            node: directory.id\n          });\n        });\n      });\n    };\n    return Button.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-tree--directory__label', 'tox-trbtn'].concat(visible ? ['tox-tree--directory__label--visible'] : [])\n      },\n      components: components,\n      action: toggleExpandChildren,\n      eventOrder: _defineProperty({}, keydown(), [directoryLabelEventsId, 'keying']),\n      buttonBehaviours: derive$1([].concat(_toConsumableArray(visible ? [Tabstopping.config({})] : []), [config(directoryLabelEventsId, [run$1(keydown(), function (comp, se) {\n        var isRightArrowKey = se.event.raw.code === 'ArrowRight';\n        var isLeftArrowKey = se.event.raw.code === 'ArrowLeft';\n        if (isRightArrowKey && noChildren) {\n          se.stop();\n        }\n        if (isRightArrowKey || isLeftArrowKey) {\n          ancestor(comp.element, '.tox-tree--directory').each(function (directoryEle) {\n            comp.getSystem().getByDom(directoryEle).each(function (directoryComp) {\n              if (!Toggling.isOn(directoryComp) && isRightArrowKey || Toggling.isOn(directoryComp) && isLeftArrowKey) {\n                toggleExpandChildren(comp);\n                se.stop();\n              } else if (isLeftArrowKey && !Toggling.isOn(directoryComp)) {\n                ancestor(directoryComp.element, '.tox-tree--directory').each(function (parentDirElement) {\n                  child(parentDirElement, '.tox-tree--directory__label').each(function (parentDirLabelElement) {\n                    directoryComp.getSystem().getByDom(parentDirLabelElement).each(Focusing.focus);\n                  });\n                });\n                se.stop();\n              }\n            });\n          });\n        }\n      })])]))\n    });\n  };\n  var renderDirectoryChildren = function renderDirectoryChildren(_ref14) {\n    var children = _ref14.children,\n      onLeafAction = _ref14.onLeafAction,\n      visible = _ref14.visible,\n      treeId = _ref14.treeId,\n      expandedIds = _ref14.expandedIds,\n      selectedId = _ref14.selectedId,\n      backstage = _ref14.backstage;\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-tree--directory__children']\n      },\n      components: children.map(function (item) {\n        return item.type === 'leaf' ? renderLeafLabel({\n          leaf: item,\n          selectedId: selectedId,\n          onLeafAction: onLeafAction,\n          visible: visible,\n          treeId: treeId,\n          backstage: backstage\n        }) : renderDirectory({\n          directory: item,\n          expandedIds: expandedIds,\n          selectedId: selectedId,\n          onLeafAction: onLeafAction,\n          labelTabstopping: visible,\n          treeId: treeId,\n          backstage: backstage\n        });\n      }),\n      behaviours: derive$1([Sliding.config({\n        dimension: {\n          property: 'height'\n        },\n        closedClass: 'tox-tree--directory__children--closed',\n        openClass: 'tox-tree--directory__children--open',\n        growingClass: 'tox-tree--directory__children--growing',\n        shrinkingClass: 'tox-tree--directory__children--shrinking',\n        expanded: visible\n      }), Replacing.config({})])\n    };\n  };\n  var directoryEventsId = generate$6('directory-event-id');\n  var renderDirectory = function renderDirectory(_ref15) {\n    var directory = _ref15.directory,\n      onLeafAction = _ref15.onLeafAction,\n      labelTabstopping = _ref15.labelTabstopping,\n      treeId = _ref15.treeId,\n      backstage = _ref15.backstage,\n      expandedIds = _ref15.expandedIds,\n      selectedId = _ref15.selectedId;\n    var children = directory.children;\n    var expandedIdsCell = Cell(expandedIds);\n    var computedChildrenComponents = function computedChildrenComponents(visible) {\n      return children.map(function (item) {\n        return item.type === 'leaf' ? renderLeafLabel({\n          leaf: item,\n          selectedId: selectedId,\n          onLeafAction: onLeafAction,\n          visible: visible,\n          treeId: treeId,\n          backstage: backstage\n        }) : renderDirectory({\n          directory: item,\n          expandedIds: expandedIdsCell.get(),\n          selectedId: selectedId,\n          onLeafAction: onLeafAction,\n          labelTabstopping: visible,\n          treeId: treeId,\n          backstage: backstage\n        });\n      });\n    };\n    var childrenVisible = expandedIds.includes(directory.id);\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-tree--directory'],\n        attributes: {\n          role: 'treeitem'\n        }\n      },\n      components: [renderDirectoryLabel({\n        directory: directory,\n        visible: labelTabstopping,\n        noChildren: directory.children.length === 0,\n        backstage: backstage\n      }), renderDirectoryChildren({\n        children: children,\n        expandedIds: expandedIds,\n        selectedId: selectedId,\n        onLeafAction: onLeafAction,\n        visible: childrenVisible,\n        treeId: treeId,\n        backstage: backstage\n      })],\n      behaviours: derive$1([config(directoryEventsId, [runOnAttached(function (comp, _se) {\n        Toggling.set(comp, childrenVisible);\n      }), run$1('expand-tree-node', function (_cmp, se) {\n        var _se$event = se.event,\n          expanded = _se$event.expanded,\n          node = _se$event.node;\n        expandedIdsCell.set(expanded ? [].concat(_toConsumableArray(expandedIdsCell.get()), [node]) : expandedIdsCell.get().filter(function (id) {\n          return id !== node;\n        }));\n      })]), Toggling.config(_objectSpread({}, directory.children.length > 0 ? {\n        aria: {\n          mode: 'expanded'\n        }\n      } : {}, {\n        toggleClass: 'tox-tree--directory--expanded',\n        onToggled: function onToggled(comp, childrenVisible) {\n          var childrenComp = comp.components()[1];\n          var newChildren = computedChildrenComponents(childrenVisible);\n          if (childrenVisible) {\n            Sliding.grow(childrenComp);\n          } else {\n            Sliding.shrink(childrenComp);\n          }\n          Replacing.set(childrenComp, newChildren);\n        }\n      }))])\n    };\n  };\n  var treeEventsId = generate$6('tree-event-id');\n  var renderTree = function renderTree(spec, backstage) {\n    var onLeafAction = spec.onLeafAction.getOr(noop);\n    var onToggleExpand = spec.onToggleExpand.getOr(noop);\n    var defaultExpandedIds = spec.defaultExpandedIds;\n    var expandedIds = Cell(defaultExpandedIds);\n    var selectedIdCell = Cell(spec.defaultSelectedId);\n    var treeId = generate$6('tree-id');\n    var children = function children(selectedId, expandedIds) {\n      return spec.items.map(function (item) {\n        return item.type === 'leaf' ? renderLeafLabel({\n          leaf: item,\n          selectedId: selectedId,\n          onLeafAction: onLeafAction,\n          visible: true,\n          treeId: treeId,\n          backstage: backstage\n        }) : renderDirectory({\n          directory: item,\n          selectedId: selectedId,\n          onLeafAction: onLeafAction,\n          expandedIds: expandedIds,\n          labelTabstopping: true,\n          treeId: treeId,\n          backstage: backstage\n        });\n      });\n    };\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-tree'],\n        attributes: {\n          role: 'tree'\n        }\n      },\n      components: children(selectedIdCell.get(), expandedIds.get()),\n      behaviours: derive$1([Keying.config({\n        mode: 'flow',\n        selector: '.tox-tree--leaf__label--visible, .tox-tree--directory__label--visible',\n        cycles: false\n      }), config(treeEventsId, [run$1('expand-tree-node', function (_cmp, se) {\n        var _se$event2 = se.event,\n          expanded = _se$event2.expanded,\n          node = _se$event2.node;\n        expandedIds.set(expanded ? [].concat(_toConsumableArray(expandedIds.get()), [node]) : expandedIds.get().filter(function (id) {\n          return id !== node;\n        }));\n        onToggleExpand(expandedIds.get(), {\n          expanded: expanded,\n          node: node\n        });\n      })]), Receiving.config({\n        channels: _defineProperty({}, \"update-active-item-\".concat(treeId), {\n          onReceive: function onReceive(comp, message) {\n            selectedIdCell.set(Optional.some(message.value));\n            Replacing.set(comp, children(Optional.some(message.value), expandedIds.get()));\n          }\n        })\n      }), Replacing.config({})])\n    };\n  };\n  var events$5 = function events$5(streamConfig, streamState) {\n    var streams = streamConfig.stream.streams;\n    var processor = streams.setup(streamConfig, streamState);\n    return derive$2([run$1(streamConfig.event, processor), runOnDetached(function () {\n      return streamState.cancel();\n    })].concat(streamConfig.cancelEvent.map(function (e) {\n      return [run$1(e, function () {\n        return streamState.cancel();\n      })];\n    }).getOr([])));\n  };\n  var ActiveStreaming = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    events: events$5\n  });\n  var throttle = function throttle(_config) {\n    var state = Cell(null);\n    var readState = function readState() {\n      return {\n        timer: state.get() !== null ? 'set' : 'unset'\n      };\n    };\n    var setTimer = function setTimer(t) {\n      state.set(t);\n    };\n    var cancel = function cancel() {\n      var t = state.get();\n      if (t !== null) {\n        t.cancel();\n      }\n    };\n    return nu$8({\n      readState: readState,\n      setTimer: setTimer,\n      cancel: cancel\n    });\n  };\n  var init$8 = function init$8(spec) {\n    return spec.stream.streams.state(spec);\n  };\n  var StreamingState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    throttle: throttle,\n    init: init$8\n  });\n  var setup$c = function setup$c(streamInfo, streamState) {\n    var sInfo = streamInfo.stream;\n    var throttler = last(streamInfo.onStream, sInfo.delay);\n    streamState.setTimer(throttler);\n    return function (component, simulatedEvent) {\n      throttler.throttle(component, simulatedEvent);\n      if (sInfo.stopEvent) {\n        simulatedEvent.stop();\n      }\n    };\n  };\n  var StreamingSchema = [requiredOf('stream', choose$1('mode', {\n    throttle: [required$1('delay'), defaulted('stopEvent', true), output$1('streams', {\n      setup: setup$c,\n      state: throttle\n    })]\n  })), defaulted('event', 'input'), option$3('cancelEvent'), onStrictHandler('onStream')];\n  var Streaming = create$4({\n    fields: StreamingSchema,\n    name: 'streaming',\n    active: ActiveStreaming,\n    state: StreamingState\n  });\n  var setValueFromItem = function setValueFromItem(model, input, item) {\n    var itemData = Representing.getValue(item);\n    Representing.setValue(input, itemData);\n    setCursorAtEnd(input);\n  };\n  var setSelectionOn = function setSelectionOn(input, f) {\n    var el = input.element;\n    var value = get$6(el);\n    var node = el.dom;\n    if (get$f(el, 'type') !== 'number') {\n      f(node, value);\n    }\n  };\n  var setCursorAtEnd = function setCursorAtEnd(input) {\n    setSelectionOn(input, function (node, value) {\n      return node.setSelectionRange(value.length, value.length);\n    });\n  };\n  var setSelectionToEnd = function setSelectionToEnd(input, startOffset) {\n    setSelectionOn(input, function (node, value) {\n      return node.setSelectionRange(startOffset, value.length);\n    });\n  };\n  var attemptSelectOver = function attemptSelectOver(model, input, item) {\n    if (!model.selectsOver) {\n      return Optional.none();\n    } else {\n      var _currentValue = Representing.getValue(input);\n      var inputDisplay = model.getDisplayText(_currentValue);\n      var itemValue = Representing.getValue(item);\n      var itemDisplay = model.getDisplayText(itemValue);\n      return itemDisplay.indexOf(inputDisplay) === 0 ? Optional.some(function () {\n        setValueFromItem(model, input, item);\n        setSelectionToEnd(input, inputDisplay.length);\n      }) : Optional.none();\n    }\n  };\n  var itemExecute = constant$1('alloy.typeahead.itemexecute');\n  var make$3 = function make$3(detail, components, spec, externals) {\n    var navigateList = function navigateList(comp, simulatedEvent, highlighter) {\n      detail.previewing.set(false);\n      var sandbox = Coupling.getCoupled(comp, 'sandbox');\n      if (Sandboxing.isOpen(sandbox)) {\n        Composing.getCurrent(sandbox).each(function (menu) {\n          Highlighting.getHighlighted(menu).fold(function () {\n            highlighter(menu);\n          }, function () {\n            dispatchEvent(sandbox, menu.element, 'keydown', simulatedEvent);\n          });\n        });\n      } else {\n        var onOpenSync = function onOpenSync(sandbox) {\n          Composing.getCurrent(sandbox).each(highlighter);\n        };\n        open(detail, mapFetch(comp), comp, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n      }\n    };\n    var focusBehaviours$1 = focusBehaviours(detail);\n    var mapFetch = function mapFetch(comp) {\n      return function (tdata) {\n        return tdata.map(function (data) {\n          var menus = values(data.menus);\n          var items = bind$3(menus, function (menu) {\n            return filter$2(menu.items, function (item) {\n              return item.type === 'item';\n            });\n          });\n          var repState = Representing.getState(comp);\n          repState.update(map$2(items, function (item) {\n            return item.data;\n          }));\n          return data;\n        });\n      };\n    };\n    var getActiveMenu = function getActiveMenu(sandboxComp) {\n      return Composing.getCurrent(sandboxComp);\n    };\n    var typeaheadCustomEvents = 'typeaheadevents';\n    var behaviours = [Focusing.config({}), Representing.config({\n      onSetValue: detail.onSetValue,\n      store: _objectSpread({\n        mode: 'dataset',\n        getDataKey: function getDataKey(comp) {\n          return get$6(comp.element);\n        },\n        getFallbackEntry: function getFallbackEntry(itemString) {\n          return {\n            value: itemString,\n            meta: {}\n          };\n        },\n        setValue: function setValue(comp, data) {\n          set$5(comp.element, detail.model.getDisplayText(data));\n        }\n      }, detail.initialData.map(function (d) {\n        return wrap$1('initialValue', d);\n      }).getOr({}))\n    }), Streaming.config({\n      stream: {\n        mode: 'throttle',\n        delay: detail.responseTime,\n        stopEvent: false\n      },\n      onStream: function onStream(component, _simulatedEvent) {\n        var sandbox = Coupling.getCoupled(component, 'sandbox');\n        var focusInInput = Focusing.isFocused(component);\n        if (focusInInput) {\n          if (get$6(component.element).length >= detail.minChars) {\n            var previousValue = getActiveMenu(sandbox).bind(function (activeMenu) {\n              return Highlighting.getHighlighted(activeMenu).map(Representing.getValue);\n            });\n            detail.previewing.set(true);\n            var onOpenSync = function onOpenSync(_sandbox) {\n              getActiveMenu(sandbox).each(function (activeMenu) {\n                previousValue.fold(function () {\n                  if (detail.model.selectsOver) {\n                    Highlighting.highlightFirst(activeMenu);\n                  }\n                }, function (pv) {\n                  Highlighting.highlightBy(activeMenu, function (item) {\n                    var itemData = Representing.getValue(item);\n                    return itemData.value === pv.value;\n                  });\n                  Highlighting.getHighlighted(activeMenu).orThunk(function () {\n                    Highlighting.highlightFirst(activeMenu);\n                    return Optional.none();\n                  });\n                });\n              });\n            };\n            open(detail, mapFetch(component), component, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightJustMenu).get(noop);\n          }\n        }\n      },\n      cancelEvent: typeaheadCancel()\n    }), Keying.config({\n      mode: 'special',\n      onDown: function onDown(comp, simulatedEvent) {\n        navigateList(comp, simulatedEvent, Highlighting.highlightFirst);\n        return Optional.some(true);\n      },\n      onEscape: function onEscape(comp) {\n        var sandbox = Coupling.getCoupled(comp, 'sandbox');\n        if (Sandboxing.isOpen(sandbox)) {\n          Sandboxing.close(sandbox);\n          return Optional.some(true);\n        }\n        return Optional.none();\n      },\n      onUp: function onUp(comp, simulatedEvent) {\n        navigateList(comp, simulatedEvent, Highlighting.highlightLast);\n        return Optional.some(true);\n      },\n      onEnter: function onEnter(comp) {\n        var sandbox = Coupling.getCoupled(comp, 'sandbox');\n        var sandboxIsOpen = Sandboxing.isOpen(sandbox);\n        if (sandboxIsOpen && !detail.previewing.get()) {\n          return getActiveMenu(sandbox).bind(function (activeMenu) {\n            return Highlighting.getHighlighted(activeMenu);\n          }).map(function (item) {\n            emitWith(comp, itemExecute(), {\n              item: item\n            });\n            return true;\n          });\n        } else {\n          var _currentValue2 = Representing.getValue(comp);\n          emit(comp, typeaheadCancel());\n          detail.onExecute(sandbox, comp, _currentValue2);\n          if (sandboxIsOpen) {\n            Sandboxing.close(sandbox);\n          }\n          return Optional.some(true);\n        }\n      }\n    }), Toggling.config({\n      toggleClass: detail.markers.openClass,\n      aria: {\n        mode: 'expanded'\n      }\n    }), Coupling.config({\n      others: {\n        sandbox: function sandbox(hotspot) {\n          return makeSandbox$1(detail, hotspot, {\n            onOpen: function onOpen() {\n              return Toggling.on(hotspot);\n            },\n            onClose: function onClose() {\n              detail.lazyTypeaheadComp.get().each(function (input) {\n                return remove$7(input.element, 'aria-activedescendant');\n              });\n              Toggling.off(hotspot);\n            }\n          });\n        }\n      }\n    }), config(typeaheadCustomEvents, [runOnAttached(function (typeaheadComp) {\n      detail.lazyTypeaheadComp.set(Optional.some(typeaheadComp));\n    }), runOnDetached(function (_typeaheadComp) {\n      detail.lazyTypeaheadComp.set(Optional.none());\n    }), runOnExecute$1(function (comp) {\n      var onOpenSync = noop;\n      togglePopup(detail, mapFetch(comp), comp, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n    }), run$1(itemExecute(), function (comp, se) {\n      var sandbox = Coupling.getCoupled(comp, 'sandbox');\n      setValueFromItem(detail.model, comp, se.event.item);\n      emit(comp, typeaheadCancel());\n      detail.onItemExecute(comp, sandbox, se.event.item, Representing.getValue(comp));\n      Sandboxing.close(sandbox);\n      setCursorAtEnd(comp);\n    })].concat(detail.dismissOnBlur ? [run$1(postBlur(), function (typeahead) {\n      var sandbox = Coupling.getCoupled(typeahead, 'sandbox');\n      if (search(sandbox.element).isNone()) {\n        Sandboxing.close(sandbox);\n      }\n    })] : []))];\n    var eventOrder = _objectSpread(_defineProperty({}, detachedFromDom(), [Representing.name(), Streaming.name(), typeaheadCustomEvents]), detail.eventOrder);\n    return {\n      uid: detail.uid,\n      dom: dom(deepMerge(detail, {\n        inputAttributes: {\n          'role': 'combobox',\n          'aria-autocomplete': 'list',\n          'aria-haspopup': 'true'\n        }\n      })),\n      behaviours: _objectSpread({}, focusBehaviours$1, augment(detail.typeaheadBehaviours, behaviours)),\n      eventOrder: eventOrder\n    };\n  };\n  var schema$g = constant$1([option$3('lazySink'), required$1('fetch'), defaulted('minChars', 5), defaulted('responseTime', 1000), onHandler('onOpen'), defaulted('getHotspot', Optional.some), defaulted('getAnchorOverrides', constant$1({})), defaulted('layouts', Optional.none()), defaulted('eventOrder', {}), defaultedObjOf('model', {}, [defaulted('getDisplayText', function (itemData) {\n    return itemData.meta !== undefined && itemData.meta.text !== undefined ? itemData.meta.text : itemData.value;\n  }), defaulted('selectsOver', true), defaulted('populateFromBrowse', true)]), onHandler('onSetValue'), onKeyboardHandler('onExecute'), onHandler('onItemExecute'), defaulted('inputClasses', []), defaulted('inputAttributes', {}), defaulted('inputStyles', {}), defaulted('matchWidth', true), defaulted('useMinWidth', false), defaulted('dismissOnBlur', true), markers$1(['openClass']), option$3('initialData'), field('typeaheadBehaviours', [Focusing, Representing, Streaming, Keying, Toggling, Coupling]), customField('lazyTypeaheadComp', function () {\n    return Cell(Optional.none);\n  }), customField('previewing', function () {\n    return Cell(true);\n  })].concat(schema$l()).concat(sandboxFields()));\n  var parts$b = constant$1([external({\n    schema: [tieredMenuMarkers()],\n    name: 'menu',\n    overrides: function overrides(detail) {\n      return {\n        fakeFocus: true,\n        onHighlightItem: function onHighlightItem(_tmenu, menu, item) {\n          if (!detail.previewing.get()) {\n            detail.lazyTypeaheadComp.get().each(function (input) {\n              if (detail.model.populateFromBrowse) {\n                setValueFromItem(detail.model, input, item);\n              }\n              getOpt(item.element, 'id').each(function (id) {\n                return set$9(input.element, 'aria-activedescendant', id);\n              });\n            });\n          } else {\n            detail.lazyTypeaheadComp.get().each(function (input) {\n              attemptSelectOver(detail.model, input, item).fold(function () {\n                if (detail.model.selectsOver) {\n                  Highlighting.dehighlight(menu, item);\n                  detail.previewing.set(true);\n                } else {\n                  detail.previewing.set(false);\n                }\n              }, function (selectOverTextInInput) {\n                selectOverTextInInput();\n                detail.previewing.set(false);\n              });\n            });\n          }\n        },\n        onExecute: function onExecute(_menu, item) {\n          return detail.lazyTypeaheadComp.get().map(function (typeahead) {\n            emitWith(typeahead, itemExecute(), {\n              item: item\n            });\n            return true;\n          });\n        },\n        onHover: function onHover(menu, item) {\n          detail.previewing.set(false);\n          detail.lazyTypeaheadComp.get().each(function (input) {\n            if (detail.model.populateFromBrowse) {\n              setValueFromItem(detail.model, input, item);\n            }\n          });\n        }\n      };\n    }\n  })]);\n  var Typeahead = composite({\n    name: 'Typeahead',\n    configFields: schema$g(),\n    partFields: parts$b(),\n    factory: make$3\n  });\n  var wrap = function wrap(delegate) {\n    var toCached = function toCached() {\n      return wrap(delegate.toCached());\n    };\n    var bindFuture = function bindFuture(f) {\n      return wrap(delegate.bind(function (resA) {\n        return resA.fold(function (err) {\n          return Future.pure(Result.error(err));\n        }, function (a) {\n          return f(a);\n        });\n      }));\n    };\n    var bindResult = function bindResult(f) {\n      return wrap(delegate.map(function (resA) {\n        return resA.bind(f);\n      }));\n    };\n    var mapResult = function mapResult(f) {\n      return wrap(delegate.map(function (resA) {\n        return resA.map(f);\n      }));\n    };\n    var mapError = function mapError(f) {\n      return wrap(delegate.map(function (resA) {\n        return resA.mapError(f);\n      }));\n    };\n    var foldResult = function foldResult(whenError, whenValue) {\n      return delegate.map(function (res) {\n        return res.fold(whenError, whenValue);\n      });\n    };\n    var withTimeout = function withTimeout(timeout, errorThunk) {\n      return wrap(Future.nu(function (callback) {\n        var timedOut = false;\n        var timer = setTimeout(function () {\n          timedOut = true;\n          callback(Result.error(errorThunk()));\n        }, timeout);\n        delegate.get(function (result) {\n          if (!timedOut) {\n            clearTimeout(timer);\n            callback(result);\n          }\n        });\n      }));\n    };\n    return _objectSpread({}, delegate, {\n      toCached: toCached,\n      bindFuture: bindFuture,\n      bindResult: bindResult,\n      mapResult: mapResult,\n      mapError: mapError,\n      foldResult: foldResult,\n      withTimeout: withTimeout\n    });\n  };\n  var nu$1 = function nu$1(worker) {\n    return wrap(Future.nu(worker));\n  };\n  var value = function value(_value5) {\n    return wrap(Future.pure(Result.value(_value5)));\n  };\n  var error = function error(_error) {\n    return wrap(Future.pure(Result.error(_error)));\n  };\n  var fromResult = function fromResult(result) {\n    return wrap(Future.pure(result));\n  };\n  var fromFuture = function fromFuture(future) {\n    return wrap(future.map(Result.value));\n  };\n  var fromPromise = function fromPromise(promise) {\n    return nu$1(function (completer) {\n      promise.then(function (value) {\n        completer(Result.value(value));\n      }, function (error) {\n        completer(Result.error(error));\n      });\n    });\n  };\n  var FutureResult = {\n    nu: nu$1,\n    wrap: wrap,\n    pure: value,\n    value: value,\n    error: error,\n    fromResult: fromResult,\n    fromFuture: fromFuture,\n    fromPromise: fromPromise\n  };\n  var renderCommonSpec = function renderCommonSpec(spec, actionOpt) {\n    var extraBehaviours = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var dom = arguments.length > 3 ? arguments[3] : undefined;\n    var components = arguments.length > 4 ? arguments[4] : undefined;\n    var providersBackstage = arguments.length > 5 ? arguments[5] : undefined;\n    var action = actionOpt.fold(function () {\n      return {};\n    }, function (action) {\n      return {\n        action: action\n      };\n    });\n    var common = _objectSpread({\n      buttonBehaviours: derive$1([DisablingConfigs.button(function () {\n        return !spec.enabled || providersBackstage.isDisabled();\n      }), receivingConfig(), Tabstopping.config({}), config('button press', [preventDefault('click'), preventDefault('mousedown')])].concat(extraBehaviours)),\n      eventOrder: {\n        click: ['button press', 'alloy.base.behaviour'],\n        mousedown: ['button press', 'alloy.base.behaviour']\n      }\n    }, action);\n    var domFinal = deepMerge(common, {\n      dom: dom\n    });\n    return deepMerge(domFinal, {\n      components: components\n    });\n  };\n  var renderIconButtonSpec = function renderIconButtonSpec(spec, action, providersBackstage) {\n    var extraBehaviours = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    var tooltipAttributes = spec.tooltip.map(function (tooltip) {\n      return {\n        'aria-label': providersBackstage.translate(tooltip),\n        'title': providersBackstage.translate(tooltip)\n      };\n    }).getOr({});\n    var dom = {\n      tag: 'button',\n      classes: ['tox-tbtn'],\n      attributes: tooltipAttributes\n    };\n    var icon = spec.icon.map(function (iconName) {\n      return renderIconFromPack$1(iconName, providersBackstage.icons);\n    });\n    var components = componentRenderPipeline([icon]);\n    return renderCommonSpec(spec, action, extraBehaviours, dom, components, providersBackstage);\n  };\n  var calculateClassesFromButtonType = function calculateClassesFromButtonType(buttonType) {\n    switch (buttonType) {\n      case 'primary':\n        return ['tox-button'];\n      case 'toolbar':\n        return ['tox-tbtn'];\n      case 'secondary':\n      default:\n        return ['tox-button', 'tox-button--secondary'];\n    }\n  };\n  var renderButtonSpec = function renderButtonSpec(spec, action, providersBackstage) {\n    var extraBehaviours = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    var extraClasses = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    var translatedText = providersBackstage.translate(spec.text);\n    var icon = spec.icon.map(function (iconName) {\n      return renderIconFromPack$1(iconName, providersBackstage.icons);\n    });\n    var components = [icon.getOrThunk(function () {\n      return text$2(translatedText);\n    })];\n    var buttonType = spec.buttonType.getOr(!spec.primary && !spec.borderless ? 'secondary' : 'primary');\n    var baseClasses = calculateClassesFromButtonType(buttonType);\n    var classes = [].concat(_toConsumableArray(baseClasses), _toConsumableArray(icon.isSome() ? ['tox-button--icon'] : []), _toConsumableArray(spec.borderless ? ['tox-button--naked'] : []), _toConsumableArray(extraClasses));\n    var dom = {\n      tag: 'button',\n      classes: classes,\n      attributes: {\n        title: translatedText\n      }\n    };\n    return renderCommonSpec(spec, action, extraBehaviours, dom, components, providersBackstage);\n  };\n  var renderButton$1 = function renderButton$1(spec, action, providersBackstage) {\n    var extraBehaviours = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    var extraClasses = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    var buttonSpec = renderButtonSpec(spec, Optional.some(action), providersBackstage, extraBehaviours, extraClasses);\n    return Button.sketch(buttonSpec);\n  };\n  var getAction = function getAction(name, buttonType) {\n    return function (comp) {\n      if (buttonType === 'custom') {\n        emitWith(comp, formActionEvent, {\n          name: name,\n          value: {}\n        });\n      } else if (buttonType === 'submit') {\n        emit(comp, formSubmitEvent);\n      } else if (buttonType === 'cancel') {\n        emit(comp, formCancelEvent);\n      } else {\n        console.error('Unknown button type: ', buttonType);\n      }\n    };\n  };\n  var isMenuFooterButtonSpec = function isMenuFooterButtonSpec(spec, buttonType) {\n    return buttonType === 'menu';\n  };\n  var isNormalFooterButtonSpec = function isNormalFooterButtonSpec(spec, buttonType) {\n    return buttonType === 'custom' || buttonType === 'cancel' || buttonType === 'submit';\n  };\n  var isToggleButtonSpec = function isToggleButtonSpec(spec, buttonType) {\n    return buttonType === 'togglebutton';\n  };\n  var renderToggleButton = function renderToggleButton(spec, providers) {\n    var _a, _b;\n    var optMemIcon = spec.icon.map(function (memIcon) {\n      return renderReplaceableIconFromPack(memIcon, providers.icons);\n    }).map(record);\n    var action = function action(comp) {\n      emitWith(comp, formActionEvent, {\n        name: spec.name,\n        value: {\n          setIcon: function setIcon(newIcon) {\n            optMemIcon.map(function (memIcon) {\n              return memIcon.getOpt(comp).each(function (displayIcon) {\n                Replacing.set(displayIcon, [renderReplaceableIconFromPack(newIcon, providers.icons)]);\n              });\n            });\n          }\n        }\n      });\n    };\n    var buttonType = spec.buttonType.getOr(!spec.primary ? 'secondary' : 'primary');\n    var buttonSpec = _objectSpread({}, spec, {\n      name: (_a = spec.name) !== null && _a !== void 0 ? _a : '',\n      primary: buttonType === 'primary',\n      tooltip: Optional.from(spec.tooltip),\n      enabled: (_b = spec.enabled) !== null && _b !== void 0 ? _b : false,\n      borderless: false\n    });\n    var tooltipAttributes = buttonSpec.tooltip.map(function (tooltip) {\n      return {\n        'aria-label': providers.translate(tooltip),\n        'title': providers.translate(tooltip)\n      };\n    }).getOr({});\n    var buttonTypeClasses = calculateClassesFromButtonType(buttonType !== null && buttonType !== void 0 ? buttonType : 'secondary');\n    var showIconAndText = spec.icon.isSome() && spec.text.isSome();\n    var dom = {\n      tag: 'button',\n      classes: [].concat(_toConsumableArray(buttonTypeClasses.concat(spec.icon.isSome() ? ['tox-button--icon'] : [])), _toConsumableArray(spec.active ? ['tox-button--enabled'] : []), _toConsumableArray(showIconAndText ? ['tox-button--icon-and-text'] : [])),\n      attributes: tooltipAttributes\n    };\n    var extraBehaviours = [];\n    var translatedText = providers.translate(spec.text.getOr(''));\n    var translatedTextComponed = text$2(translatedText);\n    var iconComp = componentRenderPipeline([optMemIcon.map(function (memIcon) {\n      return memIcon.asSpec();\n    })]);\n    var components = [].concat(_toConsumableArray(iconComp), _toConsumableArray(spec.text.isSome() ? [translatedTextComponed] : []));\n    var iconButtonSpec = renderCommonSpec(buttonSpec, Optional.some(action), extraBehaviours, dom, components, providers);\n    return Button.sketch(iconButtonSpec);\n  };\n  var renderFooterButton = function renderFooterButton(spec, buttonType, backstage) {\n    if (isMenuFooterButtonSpec(spec, buttonType)) {\n      var getButton = function getButton() {\n        return memButton;\n      };\n      var menuButtonSpec = spec;\n      var fixedSpec = _objectSpread({}, spec, {\n        type: 'menubutton',\n        search: Optional.none(),\n        onSetup: function onSetup(api) {\n          api.setEnabled(spec.enabled);\n          return noop;\n        },\n        fetch: getFetch(menuButtonSpec.items, getButton, backstage)\n      });\n      var memButton = record(renderMenuButton(fixedSpec, 'tox-tbtn', backstage, Optional.none()));\n      return memButton.asSpec();\n    } else if (isNormalFooterButtonSpec(spec, buttonType)) {\n      var action = getAction(spec.name, buttonType);\n      var buttonSpec = _objectSpread({}, spec, {\n        borderless: false\n      });\n      return renderButton$1(buttonSpec, action, backstage.shared.providers, []);\n    } else if (isToggleButtonSpec(spec, buttonType)) {\n      return renderToggleButton(spec, backstage.shared.providers);\n    } else {\n      console.error('Unknown footer button type: ', buttonType);\n      throw new Error('Unknown footer button type');\n    }\n  };\n  var renderDialogButton = function renderDialogButton(spec, providersBackstage) {\n    var action = getAction(spec.name, 'custom');\n    return renderFormField(Optional.none(), FormField.parts.field(_objectSpread({\n      factory: Button\n    }, renderButtonSpec(spec, Optional.some(action), providersBackstage, [memory(''), ComposingConfigs.self()]))));\n  };\n  var separator$1 = {\n    type: 'separator'\n  };\n  var toMenuItem = function toMenuItem(target) {\n    return {\n      type: 'menuitem',\n      value: target.url,\n      text: target.title,\n      meta: {\n        attach: target.attach\n      },\n      onAction: noop\n    };\n  };\n  var staticMenuItem = function staticMenuItem(title, url) {\n    return {\n      type: 'menuitem',\n      value: url,\n      text: title,\n      meta: {\n        attach: undefined\n      },\n      onAction: noop\n    };\n  };\n  var toMenuItems = function toMenuItems(targets) {\n    return map$2(targets, toMenuItem);\n  };\n  var filterLinkTargets = function filterLinkTargets(type, targets) {\n    return filter$2(targets, function (target) {\n      return target.type === type;\n    });\n  };\n  var filteredTargets = function filteredTargets(type, targets) {\n    return toMenuItems(filterLinkTargets(type, targets));\n  };\n  var headerTargets = function headerTargets(linkInfo) {\n    return filteredTargets('header', linkInfo.targets);\n  };\n  var anchorTargets = function anchorTargets(linkInfo) {\n    return filteredTargets('anchor', linkInfo.targets);\n  };\n  var anchorTargetTop = function anchorTargetTop(linkInfo) {\n    return Optional.from(linkInfo.anchorTop).map(function (url) {\n      return staticMenuItem('<top>', url);\n    }).toArray();\n  };\n  var anchorTargetBottom = function anchorTargetBottom(linkInfo) {\n    return Optional.from(linkInfo.anchorBottom).map(function (url) {\n      return staticMenuItem('<bottom>', url);\n    }).toArray();\n  };\n  var historyTargets = function historyTargets(history) {\n    return map$2(history, function (url) {\n      return staticMenuItem(url, url);\n    });\n  };\n  var joinMenuLists = function joinMenuLists(items) {\n    return foldl(items, function (a, b) {\n      var bothEmpty = a.length === 0 || b.length === 0;\n      return bothEmpty ? a.concat(b) : a.concat(separator$1, b);\n    }, []);\n  };\n  var filterByQuery = function filterByQuery(term, menuItems) {\n    var lowerCaseTerm = term.toLowerCase();\n    return filter$2(menuItems, function (item) {\n      var _a;\n      var text = item.meta !== undefined && item.meta.text !== undefined ? item.meta.text : item.text;\n      var value = (_a = item.value) !== null && _a !== void 0 ? _a : '';\n      return contains$1(text.toLowerCase(), lowerCaseTerm) || contains$1(value.toLowerCase(), lowerCaseTerm);\n    });\n  };\n  var getItems = function getItems(fileType, input, urlBackstage) {\n    var _a, _b;\n    var urlInputValue = Representing.getValue(input);\n    var term = (_b = (_a = urlInputValue === null || urlInputValue === void 0 ? void 0 : urlInputValue.meta) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : urlInputValue.value;\n    var info = urlBackstage.getLinkInformation();\n    return info.fold(function () {\n      return [];\n    }, function (linkInfo) {\n      var history = filterByQuery(term, historyTargets(urlBackstage.getHistory(fileType)));\n      return fileType === 'file' ? joinMenuLists([history, filterByQuery(term, headerTargets(linkInfo)), filterByQuery(term, flatten([anchorTargetTop(linkInfo), anchorTargets(linkInfo), anchorTargetBottom(linkInfo)]))]) : history;\n    });\n  };\n  var errorId = generate$6('aria-invalid');\n  var renderUrlInput = function renderUrlInput(spec, backstage, urlBackstage, initialData) {\n    var providersBackstage = backstage.shared.providers;\n    var updateHistory = function updateHistory(component) {\n      var urlEntry = Representing.getValue(component);\n      urlBackstage.addToHistory(urlEntry.value, spec.filetype);\n    };\n    var typeaheadSpec = _objectSpread({}, initialData.map(function (initialData) {\n      return {\n        initialData: initialData\n      };\n    }).getOr({}), {\n      dismissOnBlur: true,\n      inputClasses: ['tox-textfield'],\n      sandboxClasses: ['tox-dialog__popups'],\n      inputAttributes: {\n        'aria-errormessage': errorId,\n        'type': 'url'\n      },\n      minChars: 0,\n      responseTime: 0,\n      fetch: function fetch(input) {\n        var items = getItems(spec.filetype, input, urlBackstage);\n        var tdata = build(items, ItemResponse$1.BUBBLE_TO_SANDBOX, backstage, {\n          isHorizontalMenu: false,\n          search: Optional.none()\n        });\n        return Future.pure(tdata);\n      },\n      getHotspot: function getHotspot(comp) {\n        return memUrlBox.getOpt(comp);\n      },\n      onSetValue: function onSetValue(comp, _newValue) {\n        if (comp.hasConfigured(Invalidating)) {\n          Invalidating.run(comp).get(noop);\n        }\n      },\n      typeaheadBehaviours: derive$1([].concat(_toConsumableArray(urlBackstage.getValidationHandler().map(function (handler) {\n        return Invalidating.config({\n          getRoot: function getRoot(comp) {\n            return parentElement(comp.element);\n          },\n          invalidClass: 'tox-control-wrap--status-invalid',\n          notify: {\n            onInvalid: function onInvalid(comp, err) {\n              memInvalidIcon.getOpt(comp).each(function (invalidComp) {\n                set$9(invalidComp.element, 'title', providersBackstage.translate(err));\n              });\n            }\n          },\n          validator: {\n            validate: function validate(input) {\n              var urlEntry = Representing.getValue(input);\n              return FutureResult.nu(function (completer) {\n                handler({\n                  type: spec.filetype,\n                  url: urlEntry.value\n                }, function (validation) {\n                  if (validation.status === 'invalid') {\n                    var err = Result.error(validation.message);\n                    completer(err);\n                  } else {\n                    var val = Result.value(validation.message);\n                    completer(val);\n                  }\n                });\n              });\n            },\n            validateOnLoad: false\n          }\n        });\n      }).toArray()), [Disabling.config({\n        disabled: function disabled() {\n          return !spec.enabled || providersBackstage.isDisabled();\n        }\n      }), Tabstopping.config({}), config('urlinput-events', [run$1(input(), function (comp) {\n        var currentValue = get$6(comp.element);\n        var trimmedValue = currentValue.trim();\n        if (trimmedValue !== currentValue) {\n          set$5(comp.element, trimmedValue);\n        }\n        if (spec.filetype === 'file') {\n          emitWith(comp, formChangeEvent, {\n            name: spec.name\n          });\n        }\n      }), run$1(change(), function (comp) {\n        emitWith(comp, formChangeEvent, {\n          name: spec.name\n        });\n        updateHistory(comp);\n      }), run$1(postPaste(), function (comp) {\n        emitWith(comp, formChangeEvent, {\n          name: spec.name\n        });\n        updateHistory(comp);\n      })])])),\n      eventOrder: _defineProperty({}, input(), ['streaming', 'urlinput-events', 'invalidating']),\n      model: {\n        getDisplayText: function getDisplayText(itemData) {\n          return itemData.value;\n        },\n        selectsOver: false,\n        populateFromBrowse: false\n      },\n      markers: {\n        openClass: 'tox-textfield--popup-open'\n      },\n      lazySink: backstage.shared.getSink,\n      parts: {\n        menu: part(false, 1, 'normal')\n      },\n      onExecute: function onExecute(_menu, component, _entry) {\n        emitWith(component, formSubmitEvent, {});\n      },\n      onItemExecute: function onItemExecute(typeahead, _sandbox, _item, _value) {\n        updateHistory(typeahead);\n        emitWith(typeahead, formChangeEvent, {\n          name: spec.name\n        });\n      }\n    });\n    var pField = FormField.parts.field(_objectSpread({}, typeaheadSpec, {\n      factory: Typeahead\n    }));\n    var pLabel = spec.label.map(function (label) {\n      return renderLabel$3(label, providersBackstage);\n    });\n    var makeIcon = function makeIcon(name, errId) {\n      var icon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : name;\n      var label = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : name;\n      return render$3(icon, {\n        tag: 'div',\n        classes: ['tox-icon', 'tox-control-wrap__status-icon-' + name],\n        attributes: _objectSpread({\n          'title': providersBackstage.translate(label),\n          'aria-live': 'polite'\n        }, errId.fold(function () {\n          return {};\n        }, function (id) {\n          return {\n            id: id\n          };\n        }))\n      }, providersBackstage.icons);\n    };\n    var memInvalidIcon = record(makeIcon('invalid', Optional.some(errorId), 'warning'));\n    var memStatus = record({\n      dom: {\n        tag: 'div',\n        classes: ['tox-control-wrap__status-icon-wrap']\n      },\n      components: [memInvalidIcon.asSpec()]\n    });\n    var optUrlPicker = urlBackstage.getUrlPicker(spec.filetype);\n    var browseUrlEvent = generate$6('browser.url.event');\n    var memUrlBox = record({\n      dom: {\n        tag: 'div',\n        classes: ['tox-control-wrap']\n      },\n      components: [pField, memStatus.asSpec()],\n      behaviours: derive$1([Disabling.config({\n        disabled: function disabled() {\n          return !spec.enabled || providersBackstage.isDisabled();\n        }\n      })])\n    });\n    var memUrlPickerButton = record(renderButton$1({\n      name: spec.name,\n      icon: Optional.some('browse'),\n      text: spec.picker_text.or(spec.label).getOr(''),\n      enabled: spec.enabled,\n      primary: false,\n      buttonType: Optional.none(),\n      borderless: true\n    }, function (component) {\n      return emit(component, browseUrlEvent);\n    }, providersBackstage, [], ['tox-browse-url']));\n    var controlHWrapper = function controlHWrapper() {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__controls-h-stack']\n        },\n        components: flatten([[memUrlBox.asSpec()], optUrlPicker.map(function () {\n          return memUrlPickerButton.asSpec();\n        }).toArray()])\n      };\n    };\n    var openUrlPicker = function openUrlPicker(comp) {\n      Composing.getCurrent(comp).each(function (field) {\n        var componentData = Representing.getValue(field);\n        var urlData = _objectSpread({\n          fieldname: spec.name\n        }, componentData);\n        optUrlPicker.each(function (picker) {\n          picker(urlData).get(function (chosenData) {\n            Representing.setValue(field, chosenData);\n            emitWith(comp, formChangeEvent, {\n              name: spec.name\n            });\n          });\n        });\n      });\n    };\n    return FormField.sketch({\n      dom: renderFormFieldDom(),\n      components: pLabel.toArray().concat([controlHWrapper()]),\n      fieldBehaviours: derive$1([Disabling.config({\n        disabled: function disabled() {\n          return !spec.enabled || providersBackstage.isDisabled();\n        },\n        onDisabled: function onDisabled(comp) {\n          FormField.getField(comp).each(Disabling.disable);\n          memUrlPickerButton.getOpt(comp).each(Disabling.disable);\n        },\n        onEnabled: function onEnabled(comp) {\n          FormField.getField(comp).each(Disabling.enable);\n          memUrlPickerButton.getOpt(comp).each(Disabling.enable);\n        }\n      }), receivingConfig(), config('url-input-events', [run$1(browseUrlEvent, openUrlPicker)])])\n    });\n  };\n  var renderAlertBanner = function renderAlertBanner(spec, providersBackstage) {\n    var icon = get$2(spec.icon, providersBackstage.icons);\n    return Container.sketch({\n      dom: {\n        tag: 'div',\n        attributes: {\n          role: 'alert'\n        },\n        classes: ['tox-notification', 'tox-notification--in', \"tox-notification--\".concat(spec.level)]\n      },\n      components: [{\n        dom: {\n          tag: 'div',\n          classes: ['tox-notification__icon'],\n          innerHtml: !spec.url ? icon : undefined\n        },\n        components: spec.url ? [Button.sketch({\n          dom: {\n            tag: 'button',\n            classes: ['tox-button', 'tox-button--naked', 'tox-button--icon'],\n            innerHtml: icon,\n            attributes: {\n              title: providersBackstage.translate(spec.iconTooltip)\n            }\n          },\n          action: function action(comp) {\n            return emitWith(comp, formActionEvent, {\n              name: 'alert-banner',\n              value: spec.url\n            });\n          },\n          buttonBehaviours: derive$1([addFocusableBehaviour()])\n        })] : undefined\n      }, {\n        dom: {\n          tag: 'div',\n          classes: ['tox-notification__body'],\n          innerHtml: providersBackstage.translate(spec.text)\n        }\n      }]\n    });\n  };\n  var set$1 = function set$1(element, status) {\n    element.dom.checked = status;\n  };\n  var get$1 = function get$1(element) {\n    return element.dom.checked;\n  };\n  var renderCheckbox = function renderCheckbox(spec, providerBackstage, initialData) {\n    var toggleCheckboxHandler = function toggleCheckboxHandler(comp) {\n      comp.element.dom.click();\n      return Optional.some(true);\n    };\n    var pField = FormField.parts.field({\n      factory: {\n        sketch: identity\n      },\n      dom: {\n        tag: 'input',\n        classes: ['tox-checkbox__input'],\n        attributes: {\n          type: 'checkbox'\n        }\n      },\n      behaviours: derive$1([ComposingConfigs.self(), Disabling.config({\n        disabled: function disabled() {\n          return !spec.enabled || providerBackstage.isDisabled();\n        },\n        onDisabled: function onDisabled(component) {\n          parentElement(component.element).each(function (element) {\n            return add$2(element, 'tox-checkbox--disabled');\n          });\n        },\n        onEnabled: function onEnabled(component) {\n          parentElement(component.element).each(function (element) {\n            return remove$2(element, 'tox-checkbox--disabled');\n          });\n        }\n      }), Tabstopping.config({}), Focusing.config({}), withElement(initialData, get$1, set$1), Keying.config({\n        mode: 'special',\n        onEnter: toggleCheckboxHandler,\n        onSpace: toggleCheckboxHandler,\n        stopSpaceKeyup: true\n      }), config('checkbox-events', [run$1(change(), function (component, _) {\n        emitWith(component, formChangeEvent, {\n          name: spec.name\n        });\n      })])])\n    });\n    var pLabel = FormField.parts.label({\n      dom: {\n        tag: 'span',\n        classes: ['tox-checkbox__label']\n      },\n      components: [text$2(providerBackstage.translate(spec.label))],\n      behaviours: derive$1([Unselecting.config({})])\n    });\n    var makeIcon = function makeIcon(className) {\n      var iconName = className === 'checked' ? 'selected' : 'unselected';\n      return render$3(iconName, {\n        tag: 'span',\n        classes: ['tox-icon', 'tox-checkbox-icon__' + className]\n      }, providerBackstage.icons);\n    };\n    var memIcons = record({\n      dom: {\n        tag: 'div',\n        classes: ['tox-checkbox__icons']\n      },\n      components: [makeIcon('checked'), makeIcon('unchecked')]\n    });\n    return FormField.sketch({\n      dom: {\n        tag: 'label',\n        classes: ['tox-checkbox']\n      },\n      components: [pField, memIcons.asSpec(), pLabel],\n      fieldBehaviours: derive$1([Disabling.config({\n        disabled: function disabled() {\n          return !spec.enabled || providerBackstage.isDisabled();\n        }\n      }), receivingConfig()])\n    });\n  };\n  var renderHtmlPanel = function renderHtmlPanel(spec) {\n    if (spec.presets === 'presentation') {\n      return Container.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__group'],\n          innerHtml: spec.html\n        }\n      });\n    } else {\n      return Container.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-form__group'],\n          innerHtml: spec.html,\n          attributes: {\n            role: 'document'\n          }\n        },\n        containerBehaviours: derive$1([Tabstopping.config({}), Focusing.config({})])\n      });\n    }\n  };\n  var make$2 = function make$2(render) {\n    return function (parts, spec, dialogData, backstage) {\n      return get$g(spec, 'name').fold(function () {\n        return render(spec, backstage, Optional.none());\n      }, function (fieldName) {\n        return parts.field(fieldName, render(spec, backstage, get$g(dialogData, fieldName)));\n      });\n    };\n  };\n  var makeIframe = function makeIframe(render) {\n    return function (parts, spec, dialogData, backstage) {\n      var iframeSpec = deepMerge(spec, {\n        source: 'dynamic'\n      });\n      return make$2(render)(parts, iframeSpec, dialogData, backstage);\n    };\n  };\n  var factories = {\n    bar: make$2(function (spec, backstage) {\n      return renderBar(spec, backstage.shared);\n    }),\n    collection: make$2(function (spec, backstage, data) {\n      return renderCollection(spec, backstage.shared.providers, data);\n    }),\n    alertbanner: make$2(function (spec, backstage) {\n      return renderAlertBanner(spec, backstage.shared.providers);\n    }),\n    input: make$2(function (spec, backstage, data) {\n      return renderInput(spec, backstage.shared.providers, data);\n    }),\n    textarea: make$2(function (spec, backstage, data) {\n      return renderTextarea(spec, backstage.shared.providers, data);\n    }),\n    label: make$2(function (spec, backstage) {\n      return renderLabel$2(spec, backstage.shared);\n    }),\n    iframe: makeIframe(function (spec, backstage, data) {\n      return renderIFrame(spec, backstage.shared.providers, data);\n    }),\n    button: make$2(function (spec, backstage) {\n      return renderDialogButton(spec, backstage.shared.providers);\n    }),\n    checkbox: make$2(function (spec, backstage, data) {\n      return renderCheckbox(spec, backstage.shared.providers, data);\n    }),\n    colorinput: make$2(function (spec, backstage, data) {\n      return renderColorInput(spec, backstage.shared, backstage.colorinput, data);\n    }),\n    colorpicker: make$2(function (spec, backstage, data) {\n      return renderColorPicker(spec, backstage.shared.providers, data);\n    }),\n    dropzone: make$2(function (spec, backstage, data) {\n      return renderDropZone(spec, backstage.shared.providers, data);\n    }),\n    grid: make$2(function (spec, backstage) {\n      return renderGrid(spec, backstage.shared);\n    }),\n    listbox: make$2(function (spec, backstage, data) {\n      return renderListBox(spec, backstage, data);\n    }),\n    selectbox: make$2(function (spec, backstage, data) {\n      return renderSelectBox(spec, backstage.shared.providers, data);\n    }),\n    sizeinput: make$2(function (spec, backstage) {\n      return renderSizeInput(spec, backstage.shared.providers);\n    }),\n    slider: make$2(function (spec, backstage, data) {\n      return renderSlider(spec, backstage.shared.providers, data);\n    }),\n    urlinput: make$2(function (spec, backstage, data) {\n      return renderUrlInput(spec, backstage, backstage.urlinput, data);\n    }),\n    customeditor: make$2(renderCustomEditor),\n    htmlpanel: make$2(renderHtmlPanel),\n    imagepreview: make$2(function (spec, _, data) {\n      return renderImagePreview(spec, data);\n    }),\n    table: make$2(function (spec, backstage) {\n      return renderTable(spec, backstage.shared.providers);\n    }),\n    tree: make$2(function (spec, backstage) {\n      return renderTree(spec, backstage);\n    }),\n    panel: make$2(function (spec, backstage) {\n      return renderPanel(spec, backstage);\n    })\n  };\n  var noFormParts = {\n    field: function field(_name, spec) {\n      return spec;\n    },\n    record: constant$1([])\n  };\n  var interpretInForm = function interpretInForm(parts, spec, dialogData, oldBackstage) {\n    var newBackstage = deepMerge(oldBackstage, {\n      shared: {\n        interpreter: function interpreter(childSpec) {\n          return interpretParts(parts, childSpec, dialogData, newBackstage);\n        }\n      }\n    });\n    return interpretParts(parts, spec, dialogData, newBackstage);\n  };\n  var interpretParts = function interpretParts(parts, spec, dialogData, backstage) {\n    return get$g(factories, spec.type).fold(function () {\n      console.error(\"Unknown factory type \\\"\".concat(spec.type, \"\\\", defaulting to container: \"), spec);\n      return spec;\n    }, function (factory) {\n      return factory(parts, spec, dialogData, backstage);\n    });\n  };\n  var interpretWithoutForm = function interpretWithoutForm(spec, dialogData, backstage) {\n    return interpretParts(noFormParts, spec, dialogData, backstage);\n  };\n  var labelPrefix = 'layout-inset';\n  var westEdgeX = function westEdgeX(anchor) {\n    return anchor.x;\n  };\n  var middleX = function middleX(anchor, element) {\n    return anchor.x + anchor.width / 2 - element.width / 2;\n  };\n  var eastEdgeX = function eastEdgeX(anchor, element) {\n    return anchor.x + anchor.width - element.width;\n  };\n  var northY = function northY(anchor) {\n    return anchor.y;\n  };\n  var southY = function southY(anchor, element) {\n    return anchor.y + anchor.height - element.height;\n  };\n  var centreY = function centreY(anchor, element) {\n    return anchor.y + anchor.height / 2 - element.height / 2;\n  };\n  var southwest = function southwest(anchor, element, bubbles) {\n    return nu$6(eastEdgeX(anchor, element), southY(anchor, element), bubbles.insetSouthwest(), northwest$3(), 'southwest', boundsRestriction(anchor, {\n      right: 0,\n      bottom: 3\n    }), labelPrefix);\n  };\n  var southeast = function southeast(anchor, element, bubbles) {\n    return nu$6(westEdgeX(anchor), southY(anchor, element), bubbles.insetSoutheast(), northeast$3(), 'southeast', boundsRestriction(anchor, {\n      left: 1,\n      bottom: 3\n    }), labelPrefix);\n  };\n  var northwest = function northwest(anchor, element, bubbles) {\n    return nu$6(eastEdgeX(anchor, element), northY(anchor), bubbles.insetNorthwest(), southwest$3(), 'northwest', boundsRestriction(anchor, {\n      right: 0,\n      top: 2\n    }), labelPrefix);\n  };\n  var northeast = function northeast(anchor, element, bubbles) {\n    return nu$6(westEdgeX(anchor), northY(anchor), bubbles.insetNortheast(), southeast$3(), 'northeast', boundsRestriction(anchor, {\n      left: 1,\n      top: 2\n    }), labelPrefix);\n  };\n  var north = function north(anchor, element, bubbles) {\n    return nu$6(middleX(anchor, element), northY(anchor), bubbles.insetNorth(), south$3(), 'north', boundsRestriction(anchor, {\n      top: 2\n    }), labelPrefix);\n  };\n  var south = function south(anchor, element, bubbles) {\n    return nu$6(middleX(anchor, element), southY(anchor, element), bubbles.insetSouth(), north$3(), 'south', boundsRestriction(anchor, {\n      bottom: 3\n    }), labelPrefix);\n  };\n  var east = function east(anchor, element, bubbles) {\n    return nu$6(eastEdgeX(anchor, element), centreY(anchor, element), bubbles.insetEast(), west$3(), 'east', boundsRestriction(anchor, {\n      right: 0\n    }), labelPrefix);\n  };\n  var west = function west(anchor, element, bubbles) {\n    return nu$6(westEdgeX(anchor), centreY(anchor, element), bubbles.insetWest(), east$3(), 'west', boundsRestriction(anchor, {\n      left: 1\n    }), labelPrefix);\n  };\n  var lookupPreserveLayout = function lookupPreserveLayout(lastPlacement) {\n    switch (lastPlacement) {\n      case 'north':\n        return north;\n      case 'northeast':\n        return northeast;\n      case 'northwest':\n        return northwest;\n      case 'south':\n        return south;\n      case 'southeast':\n        return southeast;\n      case 'southwest':\n        return southwest;\n      case 'east':\n        return east;\n      case 'west':\n        return west;\n    }\n  };\n  var preserve = function preserve(anchor, element, bubbles, placee, bounds) {\n    var layout = getPlacement(placee).map(lookupPreserveLayout).getOr(north);\n    return layout(anchor, element, bubbles, placee, bounds);\n  };\n  var lookupFlippedLayout = function lookupFlippedLayout(lastPlacement) {\n    switch (lastPlacement) {\n      case 'north':\n        return south;\n      case 'northeast':\n        return southeast;\n      case 'northwest':\n        return southwest;\n      case 'south':\n        return north;\n      case 'southeast':\n        return northeast;\n      case 'southwest':\n        return northwest;\n      case 'east':\n        return west;\n      case 'west':\n        return east;\n    }\n  };\n  var flip = function flip(anchor, element, bubbles, placee, bounds) {\n    var layout = getPlacement(placee).map(lookupFlippedLayout).getOr(north);\n    return layout(anchor, element, bubbles, placee, bounds);\n  };\n  var bubbleAlignments$2 = {\n    valignCentre: [],\n    alignCentre: [],\n    alignLeft: [],\n    alignRight: [],\n    right: [],\n    left: [],\n    bottom: [],\n    top: []\n  };\n  var getInlineDialogAnchor = function getInlineDialogAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) {\n    var bubbleSize = 12;\n    var overrides = {\n      maxHeightFunction: expandable$1()\n    };\n    var editableAreaAnchor = function editableAreaAnchor() {\n      return {\n        type: 'node',\n        root: getContentContainer(getRootNode(contentAreaElement())),\n        node: Optional.from(contentAreaElement()),\n        bubble: nu$5(bubbleSize, bubbleSize, bubbleAlignments$2),\n        layouts: {\n          onRtl: function onRtl() {\n            return [northeast];\n          },\n          onLtr: function onLtr() {\n            return [northwest];\n          }\n        },\n        overrides: overrides\n      };\n    };\n    var standardAnchor = function standardAnchor() {\n      return {\n        type: 'hotspot',\n        hotspot: lazyAnchorbar(),\n        bubble: nu$5(-bubbleSize, bubbleSize, bubbleAlignments$2),\n        layouts: {\n          onRtl: function onRtl() {\n            return [southeast$2, southwest$2, south$2];\n          },\n          onLtr: function onLtr() {\n            return [southwest$2, southeast$2, south$2];\n          }\n        },\n        overrides: overrides\n      };\n    };\n    return function () {\n      return lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();\n    };\n  };\n  var getInlineBottomDialogAnchor = function getInlineBottomDialogAnchor(inline, contentAreaElement, lazyBottomAnchorBar, lazyUseEditableAreaAnchor) {\n    var bubbleSize = 12;\n    var overrides = {\n      maxHeightFunction: expandable$1()\n    };\n    var editableAreaAnchor = function editableAreaAnchor() {\n      return {\n        type: 'node',\n        root: getContentContainer(getRootNode(contentAreaElement())),\n        node: Optional.from(contentAreaElement()),\n        bubble: nu$5(bubbleSize, bubbleSize, bubbleAlignments$2),\n        layouts: {\n          onRtl: function onRtl() {\n            return [north];\n          },\n          onLtr: function onLtr() {\n            return [north];\n          }\n        },\n        overrides: overrides\n      };\n    };\n    var standardAnchor = function standardAnchor() {\n      return inline ? {\n        type: 'node',\n        root: getContentContainer(getRootNode(contentAreaElement())),\n        node: Optional.from(contentAreaElement()),\n        bubble: nu$5(0, -getOuter$2(contentAreaElement()), bubbleAlignments$2),\n        layouts: {\n          onRtl: function onRtl() {\n            return [north$2];\n          },\n          onLtr: function onLtr() {\n            return [north$2];\n          }\n        },\n        overrides: overrides\n      } : {\n        type: 'hotspot',\n        hotspot: lazyBottomAnchorBar(),\n        bubble: nu$5(0, 0, bubbleAlignments$2),\n        layouts: {\n          onRtl: function onRtl() {\n            return [north$2];\n          },\n          onLtr: function onLtr() {\n            return [north$2];\n          }\n        },\n        overrides: overrides\n      };\n    };\n    return function () {\n      return lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();\n    };\n  };\n  var getBannerAnchor = function getBannerAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) {\n    var editableAreaAnchor = function editableAreaAnchor() {\n      return {\n        type: 'node',\n        root: getContentContainer(getRootNode(contentAreaElement())),\n        node: Optional.from(contentAreaElement()),\n        layouts: {\n          onRtl: function onRtl() {\n            return [north];\n          },\n          onLtr: function onLtr() {\n            return [north];\n          }\n        }\n      };\n    };\n    var standardAnchor = function standardAnchor() {\n      return {\n        type: 'hotspot',\n        hotspot: lazyAnchorbar(),\n        layouts: {\n          onRtl: function onRtl() {\n            return [south$2];\n          },\n          onLtr: function onLtr() {\n            return [south$2];\n          }\n        }\n      };\n    };\n    return function () {\n      return lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();\n    };\n  };\n  var getCursorAnchor = function getCursorAnchor(editor, bodyElement) {\n    return function () {\n      return {\n        type: 'selection',\n        root: bodyElement(),\n        getSelection: function getSelection() {\n          var rng = editor.selection.getRng();\n          var selectedCells = editor.model.table.getSelectedCells();\n          if (selectedCells.length > 1) {\n            var firstCell = selectedCells[0];\n            var lastCell = selectedCells[selectedCells.length - 1];\n            var selectionTableCellRange = {\n              firstCell: SugarElement.fromDom(firstCell),\n              lastCell: SugarElement.fromDom(lastCell)\n            };\n            return Optional.some(selectionTableCellRange);\n          }\n          return Optional.some(SimSelection.range(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n        }\n      };\n    };\n  };\n  var getNodeAnchor$1 = function getNodeAnchor$1(bodyElement) {\n    return function (element) {\n      return {\n        type: 'node',\n        root: bodyElement(),\n        node: element\n      };\n    };\n  };\n  var getAnchors = function getAnchors(editor, lazyAnchorbar, lazyBottomAnchorBar, isToolbarTop) {\n    var useFixedToolbarContainer = useFixedContainer(editor);\n    var bodyElement = function bodyElement() {\n      return SugarElement.fromDom(editor.getBody());\n    };\n    var contentAreaElement = function contentAreaElement() {\n      return SugarElement.fromDom(editor.getContentAreaContainer());\n    };\n    var lazyUseEditableAreaAnchor = function lazyUseEditableAreaAnchor() {\n      return useFixedToolbarContainer || !isToolbarTop();\n    };\n    return {\n      inlineDialog: getInlineDialogAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),\n      inlineBottomDialog: getInlineBottomDialogAnchor(editor.inline, contentAreaElement, lazyBottomAnchorBar, lazyUseEditableAreaAnchor),\n      banner: getBannerAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),\n      cursor: getCursorAnchor(editor, bodyElement),\n      node: getNodeAnchor$1(bodyElement)\n    };\n  };\n  var colorPicker = function colorPicker(editor) {\n    return function (callback, value) {\n      var dialog = colorPickerDialog(editor);\n      dialog(callback, value);\n    };\n  };\n  var hasCustomColors = function hasCustomColors(editor) {\n    return function () {\n      return hasCustomColors$1(editor);\n    };\n  };\n  var getColors = function getColors(editor) {\n    return function (id) {\n      return getColors$2(editor, id);\n    };\n  };\n  var getColorCols = function getColorCols(editor) {\n    return function (id) {\n      return getColorCols$1(editor, id);\n    };\n  };\n  var ColorInputBackstage = function ColorInputBackstage(editor) {\n    return {\n      colorPicker: colorPicker(editor),\n      hasCustomColors: hasCustomColors(editor),\n      getColors: getColors(editor),\n      getColorCols: getColorCols(editor)\n    };\n  };\n  var isDraggableModal = function isDraggableModal(editor) {\n    return function () {\n      return isDraggableModal$1(editor);\n    };\n  };\n  var DialogBackstage = function DialogBackstage(editor) {\n    return {\n      isDraggableModal: isDraggableModal(editor)\n    };\n  };\n  var HeaderBackstage = function HeaderBackstage(editor) {\n    var mode = Cell(isToolbarLocationBottom(editor) ? 'bottom' : 'top');\n    return {\n      isPositionedAtTop: function isPositionedAtTop() {\n        return mode.get() === 'top';\n      },\n      getDockingMode: mode.get,\n      setDockingMode: mode.set\n    };\n  };\n  var isNestedFormat = function isNestedFormat(format) {\n    return hasNonNullableKey(format, 'items');\n  };\n  var isFormatReference = function isFormatReference(format) {\n    return hasNonNullableKey(format, 'format');\n  };\n  var defaultStyleFormats = [{\n    title: 'Headings',\n    items: [{\n      title: 'Heading 1',\n      format: 'h1'\n    }, {\n      title: 'Heading 2',\n      format: 'h2'\n    }, {\n      title: 'Heading 3',\n      format: 'h3'\n    }, {\n      title: 'Heading 4',\n      format: 'h4'\n    }, {\n      title: 'Heading 5',\n      format: 'h5'\n    }, {\n      title: 'Heading 6',\n      format: 'h6'\n    }]\n  }, {\n    title: 'Inline',\n    items: [{\n      title: 'Bold',\n      format: 'bold'\n    }, {\n      title: 'Italic',\n      format: 'italic'\n    }, {\n      title: 'Underline',\n      format: 'underline'\n    }, {\n      title: 'Strikethrough',\n      format: 'strikethrough'\n    }, {\n      title: 'Superscript',\n      format: 'superscript'\n    }, {\n      title: 'Subscript',\n      format: 'subscript'\n    }, {\n      title: 'Code',\n      format: 'code'\n    }]\n  }, {\n    title: 'Blocks',\n    items: [{\n      title: 'Paragraph',\n      format: 'p'\n    }, {\n      title: 'Blockquote',\n      format: 'blockquote'\n    }, {\n      title: 'Div',\n      format: 'div'\n    }, {\n      title: 'Pre',\n      format: 'pre'\n    }]\n  }, {\n    title: 'Align',\n    items: [{\n      title: 'Left',\n      format: 'alignleft'\n    }, {\n      title: 'Center',\n      format: 'aligncenter'\n    }, {\n      title: 'Right',\n      format: 'alignright'\n    }, {\n      title: 'Justify',\n      format: 'alignjustify'\n    }]\n  }];\n  var isNestedFormats = function isNestedFormats(format) {\n    return has$2(format, 'items');\n  };\n  var isBlockFormat = function isBlockFormat(format) {\n    return has$2(format, 'block');\n  };\n  var isInlineFormat = function isInlineFormat(format) {\n    return has$2(format, 'inline');\n  };\n  var isSelectorFormat = function isSelectorFormat(format) {\n    return has$2(format, 'selector');\n  };\n  var mapFormats = function mapFormats(userFormats) {\n    return foldl(userFormats, function (acc, fmt) {\n      if (isNestedFormats(fmt)) {\n        var result = mapFormats(fmt.items);\n        return {\n          customFormats: acc.customFormats.concat(result.customFormats),\n          formats: acc.formats.concat([{\n            title: fmt.title,\n            items: result.formats\n          }])\n        };\n      } else if (isInlineFormat(fmt) || isBlockFormat(fmt) || isSelectorFormat(fmt)) {\n        var formatName = isString(fmt.name) ? fmt.name : fmt.title.toLowerCase();\n        var formatNameWithPrefix = \"custom-\".concat(formatName);\n        return {\n          customFormats: acc.customFormats.concat([{\n            name: formatNameWithPrefix,\n            format: fmt\n          }]),\n          formats: acc.formats.concat([{\n            title: fmt.title,\n            format: formatNameWithPrefix,\n            icon: fmt.icon\n          }])\n        };\n      } else {\n        return _objectSpread({}, acc, {\n          formats: acc.formats.concat(fmt)\n        });\n      }\n    }, {\n      customFormats: [],\n      formats: []\n    });\n  };\n  var registerCustomFormats = function registerCustomFormats(editor, userFormats) {\n    var result = mapFormats(userFormats);\n    var registerFormats = function registerFormats(customFormats) {\n      each$1(customFormats, function (fmt) {\n        if (!editor.formatter.has(fmt.name)) {\n          editor.formatter.register(fmt.name, fmt.format);\n        }\n      });\n    };\n    if (editor.formatter) {\n      registerFormats(result.customFormats);\n    } else {\n      editor.on('init', function () {\n        registerFormats(result.customFormats);\n      });\n    }\n    return result.formats;\n  };\n  var getStyleFormats = function getStyleFormats(editor) {\n    return getUserStyleFormats(editor).map(function (userFormats) {\n      var registeredUserFormats = registerCustomFormats(editor, userFormats);\n      return shouldMergeStyleFormats(editor) ? defaultStyleFormats.concat(registeredUserFormats) : registeredUserFormats;\n    }).getOr(defaultStyleFormats);\n  };\n  var isSeparator$1 = function isSeparator$1(format) {\n    var keys$1 = keys(format);\n    return keys$1.length === 1 && contains$2(keys$1, 'title');\n  };\n  var processBasic = function processBasic(item, isSelectedFor, getPreviewFor) {\n    return _objectSpread({}, item, {\n      type: 'formatter',\n      isSelected: isSelectedFor(item.format),\n      getStylePreview: getPreviewFor(item.format)\n    });\n  };\n  var register$a = function register$a(editor, formats, isSelectedFor, getPreviewFor) {\n    var enrichSupported = function enrichSupported(item) {\n      return processBasic(item, isSelectedFor, getPreviewFor);\n    };\n    var enrichMenu = function enrichMenu(item) {\n      var newItems = doEnrich(item.items);\n      return _objectSpread({}, item, {\n        type: 'submenu',\n        getStyleItems: constant$1(newItems)\n      });\n    };\n    var enrichCustom = function enrichCustom(item) {\n      var formatName = isString(item.name) ? item.name : generate$6(item.title);\n      var formatNameWithPrefix = \"custom-\".concat(formatName);\n      var newItem = _objectSpread({}, item, {\n        type: 'formatter',\n        format: formatNameWithPrefix,\n        isSelected: isSelectedFor(formatNameWithPrefix),\n        getStylePreview: getPreviewFor(formatNameWithPrefix)\n      });\n      editor.formatter.register(formatName, newItem);\n      return newItem;\n    };\n    var doEnrich = function doEnrich(items) {\n      return map$2(items, function (item) {\n        if (isNestedFormat(item)) {\n          return enrichMenu(item);\n        } else if (isFormatReference(item)) {\n          return enrichSupported(item);\n        } else if (isSeparator$1(item)) {\n          return _objectSpread({}, item, {\n            type: 'separator'\n          });\n        } else {\n          return enrichCustom(item);\n        }\n      });\n    };\n    return doEnrich(formats);\n  };\n  var init$7 = function init$7(editor) {\n    var isSelectedFor = function isSelectedFor(format) {\n      return function () {\n        return editor.formatter.match(format);\n      };\n    };\n    var getPreviewFor = function getPreviewFor(format) {\n      return function () {\n        var fmt = editor.formatter.get(format);\n        return fmt !== undefined ? Optional.some({\n          tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',\n          styles: editor.dom.parseStyle(editor.formatter.getCssText(format))\n        }) : Optional.none();\n      };\n    };\n    var settingsFormats = Cell([]);\n    var eventsFormats = Cell([]);\n    var replaceSettings = Cell(false);\n    editor.on('PreInit', function (_e) {\n      var formats = getStyleFormats(editor);\n      var enriched = register$a(editor, formats, isSelectedFor, getPreviewFor);\n      settingsFormats.set(enriched);\n    });\n    editor.on('addStyleModifications', function (e) {\n      var modifications = register$a(editor, e.items, isSelectedFor, getPreviewFor);\n      eventsFormats.set(modifications);\n      replaceSettings.set(e.replace);\n    });\n    var getData = function getData() {\n      var fromSettings = replaceSettings.get() ? [] : settingsFormats.get();\n      var fromEvents = eventsFormats.get();\n      return fromSettings.concat(fromEvents);\n    };\n    return {\n      getData: getData\n    };\n  };\n  var isElement = function isElement(node) {\n    return isNonNullable(node) && node.nodeType === 1;\n  };\n  var trim = global$1.trim;\n  var hasContentEditableState = function hasContentEditableState(value) {\n    return function (node) {\n      if (isElement(node)) {\n        if (node.contentEditable === value) {\n          return true;\n        }\n        if (node.getAttribute('data-mce-contenteditable') === value) {\n          return true;\n        }\n      }\n      return false;\n    };\n  };\n  var isContentEditableTrue = hasContentEditableState('true');\n  var isContentEditableFalse = hasContentEditableState('false');\n  var create = function create(type, title, url, level, attach) {\n    return {\n      type: type,\n      title: title,\n      url: url,\n      level: level,\n      attach: attach\n    };\n  };\n  var isChildOfContentEditableTrue = function isChildOfContentEditableTrue(node) {\n    var tempNode = node;\n    while (tempNode = tempNode.parentNode) {\n      var _value6 = tempNode.contentEditable;\n      if (_value6 && _value6 !== 'inherit') {\n        return isContentEditableTrue(tempNode);\n      }\n    }\n    return false;\n  };\n  var select = function select(selector, root) {\n    return map$2(descendants(SugarElement.fromDom(root), selector), function (element) {\n      return element.dom;\n    });\n  };\n  var getElementText = function getElementText(elm) {\n    return elm.innerText || elm.textContent;\n  };\n  var getOrGenerateId = function getOrGenerateId(elm) {\n    return elm.id ? elm.id : generate$6('h');\n  };\n  var isAnchor = function isAnchor(elm) {\n    return elm && elm.nodeName === 'A' && (elm.id || elm.name) !== undefined;\n  };\n  var isValidAnchor = function isValidAnchor(elm) {\n    return isAnchor(elm) && isEditable(elm);\n  };\n  var isHeader = function isHeader(elm) {\n    return elm && /^(H[1-6])$/.test(elm.nodeName);\n  };\n  var isEditable = function isEditable(elm) {\n    return isChildOfContentEditableTrue(elm) && !isContentEditableFalse(elm);\n  };\n  var isValidHeader = function isValidHeader(elm) {\n    return isHeader(elm) && isEditable(elm);\n  };\n  var getLevel = function getLevel(elm) {\n    return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;\n  };\n  var headerTarget = function headerTarget(elm) {\n    var _a;\n    var headerId = getOrGenerateId(elm);\n    var attach = function attach() {\n      elm.id = headerId;\n    };\n    return create('header', (_a = getElementText(elm)) !== null && _a !== void 0 ? _a : '', '#' + headerId, getLevel(elm), attach);\n  };\n  var anchorTarget = function anchorTarget(elm) {\n    var anchorId = elm.id || elm.name;\n    var anchorText = getElementText(elm);\n    return create('anchor', anchorText ? anchorText : '#' + anchorId, '#' + anchorId, 0, noop);\n  };\n  var getHeaderTargets = function getHeaderTargets(elms) {\n    return map$2(filter$2(elms, isValidHeader), headerTarget);\n  };\n  var getAnchorTargets = function getAnchorTargets(elms) {\n    return map$2(filter$2(elms, isValidAnchor), anchorTarget);\n  };\n  var getTargetElements = function getTargetElements(elm) {\n    var elms = select('h1,h2,h3,h4,h5,h6,a:not([href])', elm);\n    return elms;\n  };\n  var hasTitle = function hasTitle(target) {\n    return trim(target.title).length > 0;\n  };\n  var find = function find(elm) {\n    var elms = getTargetElements(elm);\n    return filter$2(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);\n  };\n  var LinkTargets = {\n    find: find\n  };\n  var STORAGE_KEY = 'tinymce-url-history';\n  var HISTORY_LENGTH = 5;\n  var isHttpUrl = function isHttpUrl(url) {\n    return isString(url) && /^https?/.test(url);\n  };\n  var isArrayOfUrl = function isArrayOfUrl(a) {\n    return isArray(a) && a.length <= HISTORY_LENGTH && forall(a, isHttpUrl);\n  };\n  var isRecordOfUrlArray = function isRecordOfUrlArray(r) {\n    return isObject(r) && find$4(r, function (value) {\n      return !isArrayOfUrl(value);\n    }).isNone();\n  };\n  var getAllHistory = function getAllHistory() {\n    var unparsedHistory = global$4.getItem(STORAGE_KEY);\n    if (unparsedHistory === null) {\n      return {};\n    }\n    var history;\n    try {\n      history = JSON.parse(unparsedHistory);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        console.log('Local storage ' + STORAGE_KEY + ' was not valid JSON', e);\n        return {};\n      }\n      throw e;\n    }\n    if (!isRecordOfUrlArray(history)) {\n      console.log('Local storage ' + STORAGE_KEY + ' was not valid format', history);\n      return {};\n    }\n    return history;\n  };\n  var setAllHistory = function setAllHistory(history) {\n    if (!isRecordOfUrlArray(history)) {\n      throw new Error('Bad format for history:\\n' + JSON.stringify(history));\n    }\n    global$4.setItem(STORAGE_KEY, JSON.stringify(history));\n  };\n  var getHistory = function getHistory(fileType) {\n    var history = getAllHistory();\n    return get$g(history, fileType).getOr([]);\n  };\n  var addToHistory = function addToHistory(url, fileType) {\n    if (!isHttpUrl(url)) {\n      return;\n    }\n    var history = getAllHistory();\n    var items = get$g(history, fileType).getOr([]);\n    var itemsWithoutUrl = filter$2(items, function (item) {\n      return item !== url;\n    });\n    history[fileType] = [url].concat(itemsWithoutUrl).slice(0, HISTORY_LENGTH);\n    setAllHistory(history);\n  };\n  var isTruthy = function isTruthy(value) {\n    return !!value;\n  };\n  var makeMap = function makeMap(value) {\n    return map$1(global$1.makeMap(value, /[, ]/), isTruthy);\n  };\n  var getPicker = function getPicker(editor) {\n    return Optional.from(getFilePickerCallback(editor));\n  };\n  var getPickerTypes = function getPickerTypes(editor) {\n    var optFileTypes = Optional.from(getFilePickerTypes(editor)).filter(isTruthy).map(makeMap);\n    return getPicker(editor).fold(never, function (_picker) {\n      return optFileTypes.fold(always, function (types) {\n        return keys(types).length > 0 ? types : false;\n      });\n    });\n  };\n  var getPickerSetting = function getPickerSetting(editor, filetype) {\n    var pickerTypes = getPickerTypes(editor);\n    if (isBoolean(pickerTypes)) {\n      return pickerTypes ? getPicker(editor) : Optional.none();\n    } else {\n      return pickerTypes[filetype] ? getPicker(editor) : Optional.none();\n    }\n  };\n  var _getUrlPicker = function getUrlPicker(editor, filetype) {\n    return getPickerSetting(editor, filetype).map(function (picker) {\n      return function (entry) {\n        return Future.nu(function (completer) {\n          var handler = function handler(value, meta) {\n            if (!isString(value)) {\n              throw new Error('Expected value to be string');\n            }\n            if (meta !== undefined && !isObject(meta)) {\n              throw new Error('Expected meta to be a object');\n            }\n            var r = {\n              value: value,\n              meta: meta\n            };\n            completer(r);\n          };\n          var meta = _objectSpread({\n            filetype: filetype,\n            fieldname: entry.fieldname\n          }, Optional.from(entry.meta).getOr({}));\n          picker.call(editor, handler, entry.value, meta);\n        });\n      };\n    });\n  };\n  var getTextSetting = function getTextSetting(value) {\n    return Optional.from(value).filter(isString).getOrUndefined();\n  };\n  var _getLinkInformation = function getLinkInformation(editor) {\n    if (!useTypeaheadUrls(editor)) {\n      return Optional.none();\n    }\n    return Optional.some({\n      targets: LinkTargets.find(editor.getBody()),\n      anchorTop: getTextSetting(getAnchorTop(editor)),\n      anchorBottom: getTextSetting(getAnchorBottom(editor))\n    });\n  };\n  var _getValidationHandler = function getValidationHandler(editor) {\n    return Optional.from(getFilePickerValidatorHandler(editor));\n  };\n  var UrlInputBackstage = function UrlInputBackstage(editor) {\n    return {\n      getHistory: getHistory,\n      addToHistory: addToHistory,\n      getLinkInformation: function getLinkInformation() {\n        return _getLinkInformation(editor);\n      },\n      getValidationHandler: function getValidationHandler() {\n        return _getValidationHandler(editor);\n      },\n      getUrlPicker: function getUrlPicker(filetype) {\n        return _getUrlPicker(editor, filetype);\n      }\n    };\n  };\n  var init$6 = function init$6(lazySinks, editor, lazyAnchorbar, lazyBottomAnchorBar) {\n    var contextMenuState = Cell(false);\n    var toolbar = HeaderBackstage(editor);\n    var providers = {\n      icons: function icons() {\n        return editor.ui.registry.getAll().icons;\n      },\n      menuItems: function menuItems() {\n        return editor.ui.registry.getAll().menuItems;\n      },\n      translate: global$8.translate,\n      isDisabled: function isDisabled() {\n        return editor.mode.isReadOnly() || !editor.ui.isEnabled();\n      },\n      getOption: editor.options.get\n    };\n    var urlinput = UrlInputBackstage(editor);\n    var styles = init$7(editor);\n    var colorinput = ColorInputBackstage(editor);\n    var dialogSettings = DialogBackstage(editor);\n    var isContextMenuOpen = function isContextMenuOpen() {\n      return contextMenuState.get();\n    };\n    var setContextMenuState = function setContextMenuState(state) {\n      return contextMenuState.set(state);\n    };\n    var commonBackstage = {\n      shared: {\n        providers: providers,\n        anchors: getAnchors(editor, lazyAnchorbar, lazyBottomAnchorBar, toolbar.isPositionedAtTop),\n        header: toolbar\n      },\n      urlinput: urlinput,\n      styles: styles,\n      colorinput: colorinput,\n      dialog: dialogSettings,\n      isContextMenuOpen: isContextMenuOpen,\n      setContextMenuState: setContextMenuState\n    };\n    var popupBackstage = _objectSpread({}, commonBackstage, {\n      shared: _objectSpread({}, commonBackstage.shared, {\n        interpreter: function interpreter(s) {\n          return interpretWithoutForm(s, {}, popupBackstage);\n        },\n        getSink: lazySinks.popup\n      })\n    });\n    var dialogBackstage = _objectSpread({}, commonBackstage, {\n      shared: _objectSpread({}, commonBackstage.shared, {\n        interpreter: function interpreter(s) {\n          return interpretWithoutForm(s, {}, dialogBackstage);\n        },\n        getSink: lazySinks.dialog\n      })\n    });\n    return {\n      popup: popupBackstage,\n      dialog: dialogBackstage\n    };\n  };\n  var setup$b = function setup$b(editor, mothership, uiMotherships) {\n    var broadcastEvent = function broadcastEvent(name, evt) {\n      each$1([mothership].concat(_toConsumableArray(uiMotherships)), function (m) {\n        m.broadcastEvent(name, evt);\n      });\n    };\n    var broadcastOn = function broadcastOn(channel, message) {\n      each$1([mothership].concat(_toConsumableArray(uiMotherships)), function (m) {\n        m.broadcastOn([channel], message);\n      });\n    };\n    var fireDismissPopups = function fireDismissPopups(evt) {\n      return broadcastOn(dismissPopups(), {\n        target: evt.target\n      });\n    };\n    var doc = getDocument();\n    var onTouchstart = bind(doc, 'touchstart', fireDismissPopups);\n    var onTouchmove = bind(doc, 'touchmove', function (evt) {\n      return broadcastEvent(documentTouchmove(), evt);\n    });\n    var onTouchend = bind(doc, 'touchend', function (evt) {\n      return broadcastEvent(documentTouchend(), evt);\n    });\n    var onMousedown = bind(doc, 'mousedown', fireDismissPopups);\n    var onMouseup = bind(doc, 'mouseup', function (evt) {\n      if (evt.raw.button === 0) {\n        broadcastOn(mouseReleased(), {\n          target: evt.target\n        });\n      }\n    });\n    var onContentClick = function onContentClick(raw) {\n      return broadcastOn(dismissPopups(), {\n        target: SugarElement.fromDom(raw.target)\n      });\n    };\n    var onContentMouseup = function onContentMouseup(raw) {\n      if (raw.button === 0) {\n        broadcastOn(mouseReleased(), {\n          target: SugarElement.fromDom(raw.target)\n        });\n      }\n    };\n    var onContentMousedown = function onContentMousedown() {\n      each$1(editor.editorManager.get(), function (loopEditor) {\n        if (editor !== loopEditor) {\n          loopEditor.dispatch('DismissPopups', {\n            relatedTarget: editor\n          });\n        }\n      });\n    };\n    var onWindowScroll = function onWindowScroll(evt) {\n      return broadcastEvent(windowScroll(), fromRawEvent(evt));\n    };\n    var onWindowResize = function onWindowResize(evt) {\n      broadcastOn(repositionPopups(), {});\n      broadcastEvent(windowResize(), fromRawEvent(evt));\n    };\n    var dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n    var onElementScroll = capture(dos, 'scroll', function (evt) {\n      requestAnimationFrame(function () {\n        var c = editor.getContainer();\n        if (c !== undefined && c !== null) {\n          var optScrollingContext = detectWhenSplitUiMode(editor, mothership.element);\n          var scrollers = optScrollingContext.map(function (sc) {\n            return [sc.element].concat(_toConsumableArray(sc.others));\n          }).getOr([]);\n          if (exists(scrollers, function (s) {\n            return eq(s, evt.target);\n          })) {\n            editor.dispatch('ElementScroll', {\n              target: evt.target.dom\n            });\n            broadcastEvent(externalElementScroll(), evt);\n          }\n        }\n      });\n    });\n    var onEditorResize = function onEditorResize() {\n      return broadcastOn(repositionPopups(), {});\n    };\n    var onEditorProgress = function onEditorProgress(evt) {\n      if (evt.state) {\n        broadcastOn(dismissPopups(), {\n          target: SugarElement.fromDom(editor.getContainer())\n        });\n      }\n    };\n    var onDismissPopups = function onDismissPopups(event) {\n      broadcastOn(dismissPopups(), {\n        target: SugarElement.fromDom(event.relatedTarget.getContainer())\n      });\n    };\n    editor.on('PostRender', function () {\n      editor.on('click', onContentClick);\n      editor.on('tap', onContentClick);\n      editor.on('mouseup', onContentMouseup);\n      editor.on('mousedown', onContentMousedown);\n      editor.on('ScrollWindow', onWindowScroll);\n      editor.on('ResizeWindow', onWindowResize);\n      editor.on('ResizeEditor', onEditorResize);\n      editor.on('AfterProgressState', onEditorProgress);\n      editor.on('DismissPopups', onDismissPopups);\n    });\n    editor.on('remove', function () {\n      editor.off('click', onContentClick);\n      editor.off('tap', onContentClick);\n      editor.off('mouseup', onContentMouseup);\n      editor.off('mousedown', onContentMousedown);\n      editor.off('ScrollWindow', onWindowScroll);\n      editor.off('ResizeWindow', onWindowResize);\n      editor.off('ResizeEditor', onEditorResize);\n      editor.off('AfterProgressState', onEditorProgress);\n      editor.off('DismissPopups', onDismissPopups);\n      onMousedown.unbind();\n      onTouchstart.unbind();\n      onTouchmove.unbind();\n      onTouchend.unbind();\n      onMouseup.unbind();\n      onElementScroll.unbind();\n    });\n    editor.on('detach', function () {\n      each$1([mothership].concat(_toConsumableArray(uiMotherships)), detachSystem);\n      each$1([mothership].concat(_toConsumableArray(uiMotherships)), function (m) {\n        return m.destroy();\n      });\n    });\n  };\n  var parts$a = AlloyParts;\n  var partType = PartType;\n  var schema$f = constant$1([defaulted('shell', false), required$1('makeItem'), defaulted('setupItem', noop), SketchBehaviours.field('listBehaviours', [Replacing])]);\n  var customListDetail = function customListDetail() {\n    return {\n      behaviours: derive$1([Replacing.config({})])\n    };\n  };\n  var itemsPart = optional({\n    name: 'items',\n    overrides: customListDetail\n  });\n  var parts$9 = constant$1([itemsPart]);\n  var name = constant$1('CustomList');\n  var factory$f = function factory$f(detail, components, _spec, _external) {\n    var setItems = function setItems(list, items) {\n      getListContainer(list).fold(function () {\n        console.error('Custom List was defined to not be a shell, but no item container was specified in components');\n        throw new Error('Custom List was defined to not be a shell, but no item container was specified in components');\n      }, function (container) {\n        var itemComps = Replacing.contents(container);\n        var numListsRequired = items.length;\n        var numListsToAdd = numListsRequired - itemComps.length;\n        var itemsToAdd = numListsToAdd > 0 ? range$2(numListsToAdd, function () {\n          return detail.makeItem();\n        }) : [];\n        var itemsToRemove = itemComps.slice(numListsRequired);\n        each$1(itemsToRemove, function (item) {\n          return Replacing.remove(container, item);\n        });\n        each$1(itemsToAdd, function (item) {\n          return Replacing.append(container, item);\n        });\n        var builtLists = Replacing.contents(container);\n        each$1(builtLists, function (item, i) {\n          detail.setupItem(list, item, items[i], i);\n        });\n      });\n    };\n    var extra = detail.shell ? {\n      behaviours: [Replacing.config({})],\n      components: []\n    } : {\n      behaviours: [],\n      components: components\n    };\n    var getListContainer = function getListContainer(component) {\n      return detail.shell ? Optional.some(component) : getPart(component, detail, 'items');\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: extra.components,\n      behaviours: augment(detail.listBehaviours, extra.behaviours),\n      apis: {\n        setItems: setItems\n      }\n    };\n  };\n  var CustomList = composite({\n    name: name(),\n    configFields: schema$f(),\n    partFields: parts$9(),\n    factory: factory$f,\n    apis: {\n      setItems: function setItems(apis, list, items) {\n        apis.setItems(list, items);\n      }\n    }\n  });\n  var schema$e = constant$1([required$1('dom'), defaulted('shell', true), field('toolbarBehaviours', [Replacing])]);\n  var enhanceGroups = function enhanceGroups() {\n    return {\n      behaviours: derive$1([Replacing.config({})])\n    };\n  };\n  var parts$8 = constant$1([optional({\n    name: 'groups',\n    overrides: enhanceGroups\n  })]);\n  var factory$e = function factory$e(detail, components, _spec, _externals) {\n    var setGroups = function setGroups(toolbar, groups) {\n      getGroupContainer(toolbar).fold(function () {\n        console.error('Toolbar was defined to not be a shell, but no groups container was specified in components');\n        throw new Error('Toolbar was defined to not be a shell, but no groups container was specified in components');\n      }, function (container) {\n        Replacing.set(container, groups);\n      });\n    };\n    var getGroupContainer = function getGroupContainer(component) {\n      return detail.shell ? Optional.some(component) : getPart(component, detail, 'groups');\n    };\n    var extra = detail.shell ? {\n      behaviours: [Replacing.config({})],\n      components: []\n    } : {\n      behaviours: [],\n      components: components\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: extra.components,\n      behaviours: augment(detail.toolbarBehaviours, extra.behaviours),\n      apis: {\n        setGroups: setGroups,\n        refresh: noop\n      },\n      domModification: {\n        attributes: {\n          role: 'group'\n        }\n      }\n    };\n  };\n  var Toolbar = composite({\n    name: 'Toolbar',\n    configFields: schema$e(),\n    partFields: parts$8(),\n    factory: factory$e,\n    apis: {\n      setGroups: function setGroups(apis, toolbar, groups) {\n        apis.setGroups(toolbar, groups);\n      }\n    }\n  });\n  var setup$a = noop;\n  var isDocked$2 = never;\n  var getBehaviours$1 = constant$1([]);\n  var StaticHeader = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setup: setup$a,\n    isDocked: isDocked$2,\n    getBehaviours: getBehaviours$1\n  });\n  var getOffsetParent = function getOffsetParent(element) {\n    var isFixed = is$1(getRaw(element, 'position'), 'fixed');\n    var offsetParent$1 = isFixed ? Optional.none() : offsetParent(element);\n    return offsetParent$1.orThunk(function () {\n      var marker = SugarElement.fromTag('span');\n      return parent(element).bind(function (parent) {\n        append$2(parent, marker);\n        var offsetParent$1 = offsetParent(marker);\n        remove$5(marker);\n        return offsetParent$1;\n      });\n    });\n  };\n  var getOrigin = function getOrigin(element) {\n    return getOffsetParent(element).map(absolute$3).getOrThunk(function () {\n      return SugarPosition(0, 0);\n    });\n  };\n  var appear = function appear(component, contextualInfo) {\n    var elem = component.element;\n    add$2(elem, contextualInfo.transitionClass);\n    remove$2(elem, contextualInfo.fadeOutClass);\n    add$2(elem, contextualInfo.fadeInClass);\n    contextualInfo.onShow(component);\n  };\n  var disappear = function disappear(component, contextualInfo) {\n    var elem = component.element;\n    add$2(elem, contextualInfo.transitionClass);\n    remove$2(elem, contextualInfo.fadeInClass);\n    add$2(elem, contextualInfo.fadeOutClass);\n    contextualInfo.onHide(component);\n  };\n  var isPartiallyVisible = function isPartiallyVisible(box, bounds) {\n    return box.y < bounds.bottom && box.bottom > bounds.y;\n  };\n  var isTopCompletelyVisible = function isTopCompletelyVisible(box, bounds) {\n    return box.y >= bounds.y;\n  };\n  var isBottomCompletelyVisible = function isBottomCompletelyVisible(box, bounds) {\n    return box.bottom <= bounds.bottom;\n  };\n  var forceTopPosition = function forceTopPosition(winBox, leftX, viewport) {\n    return {\n      location: 'top',\n      leftX: leftX,\n      topY: viewport.bounds.y - winBox.y\n    };\n  };\n  var forceBottomPosition = function forceBottomPosition(winBox, leftX, viewport) {\n    return {\n      location: 'bottom',\n      leftX: leftX,\n      bottomY: winBox.bottom - viewport.bounds.bottom\n    };\n  };\n  var getDockedLeftPosition = function getDockedLeftPosition(bounds) {\n    return bounds.box.x - bounds.win.x;\n  };\n  var tryDockingPosition = function tryDockingPosition(modes, bounds, viewport) {\n    var winBox = bounds.win;\n    var box = bounds.box;\n    var leftX = getDockedLeftPosition(bounds);\n    return findMap(modes, function (mode) {\n      switch (mode) {\n        case 'bottom':\n          return !isBottomCompletelyVisible(box, viewport.bounds) ? Optional.some(forceBottomPosition(winBox, leftX, viewport)) : Optional.none();\n        case 'top':\n          return !isTopCompletelyVisible(box, viewport.bounds) ? Optional.some(forceTopPosition(winBox, leftX, viewport)) : Optional.none();\n        default:\n          return Optional.none();\n      }\n    }).getOr({\n      location: 'no-dock'\n    });\n  };\n  var isVisibleForModes = function isVisibleForModes(modes, box, viewport) {\n    return forall(modes, function (mode) {\n      switch (mode) {\n        case 'bottom':\n          return isBottomCompletelyVisible(box, viewport.bounds);\n        case 'top':\n          return isTopCompletelyVisible(box, viewport.bounds);\n      }\n    });\n  };\n  var getXYForRestoring = function getXYForRestoring(pos, viewport) {\n    var priorY = viewport.optScrollEnv.fold(constant$1(pos.bounds.y), function (scrollEnv) {\n      return scrollEnv.scrollElmTop + (pos.bounds.y - scrollEnv.currentScrollTop);\n    });\n    return SugarPosition(pos.bounds.x, priorY);\n  };\n  var getXYForSaving = function getXYForSaving(box, viewport) {\n    var priorY = viewport.optScrollEnv.fold(constant$1(box.y), function (scrollEnv) {\n      return box.y + scrollEnv.currentScrollTop - scrollEnv.scrollElmTop;\n    });\n    return SugarPosition(box.x, priorY);\n  };\n  var getPrior = function getPrior(elem, viewport, state) {\n    return state.getInitialPos().map(function (pos) {\n      var xy = getXYForRestoring(pos, viewport);\n      return {\n        box: bounds(xy.left, xy.top, get$c(elem), get$d(elem)),\n        location: pos.location\n      };\n    });\n  };\n  var storePrior = function storePrior(elem, box, viewport, state, decision) {\n    var xy = getXYForSaving(box, viewport);\n    var bounds$1 = bounds(xy.left, xy.top, box.width, box.height);\n    state.setInitialPos({\n      style: getAllRaw(elem),\n      position: get$e(elem, 'position') || 'static',\n      bounds: bounds$1,\n      location: decision.location\n    });\n  };\n  var storePriorIfNone = function storePriorIfNone(elem, box, viewport, state, decision) {\n    state.getInitialPos().fold(function () {\n      return storePrior(elem, box, viewport, state, decision);\n    }, function () {\n      return noop;\n    });\n  };\n  var revertToOriginal = function revertToOriginal(elem, box, state) {\n    return state.getInitialPos().bind(function (position) {\n      var _a;\n      state.clearInitialPos();\n      switch (position.position) {\n        case 'static':\n          return Optional.some({\n            morph: 'static'\n          });\n        case 'absolute':\n          var _offsetParent = getOffsetParent(elem).getOr(body());\n          var offsetBox = box$1(_offsetParent);\n          var scrollDelta = (_a = _offsetParent.dom.scrollTop) !== null && _a !== void 0 ? _a : 0;\n          return Optional.some({\n            morph: 'absolute',\n            positionCss: NuPositionCss('absolute', get$g(position.style, 'left').map(function (_left) {\n              return box.x - offsetBox.x;\n            }), get$g(position.style, 'top').map(function (_top) {\n              return box.y - offsetBox.y + scrollDelta;\n            }), get$g(position.style, 'right').map(function (_right) {\n              return offsetBox.right - box.right;\n            }), get$g(position.style, 'bottom').map(function (_bottom) {\n              return offsetBox.bottom - box.bottom;\n            }))\n          });\n        default:\n          return Optional.none();\n      }\n    });\n  };\n  var tryMorphToOriginal = function tryMorphToOriginal(elem, viewport, state) {\n    return getPrior(elem, viewport, state).filter(function (_ref16) {\n      var box = _ref16.box;\n      return isVisibleForModes(state.getModes(), box, viewport);\n    }).bind(function (_ref17) {\n      var box = _ref17.box;\n      return revertToOriginal(elem, box, state);\n    });\n  };\n  var tryDecisionToFixedMorph = function tryDecisionToFixedMorph(decision) {\n    switch (decision.location) {\n      case 'top':\n        {\n          return Optional.some({\n            morph: 'fixed',\n            positionCss: NuPositionCss('fixed', Optional.some(decision.leftX), Optional.some(decision.topY), Optional.none(), Optional.none())\n          });\n        }\n      case 'bottom':\n        {\n          return Optional.some({\n            morph: 'fixed',\n            positionCss: NuPositionCss('fixed', Optional.some(decision.leftX), Optional.none(), Optional.none(), Optional.some(decision.bottomY))\n          });\n        }\n      default:\n        return Optional.none();\n    }\n  };\n  var tryMorphToFixed = function tryMorphToFixed(elem, viewport, state) {\n    var box = box$1(elem);\n    var winBox = win();\n    var decision = tryDockingPosition(state.getModes(), {\n      win: winBox,\n      box: box\n    }, viewport);\n    if (decision.location === 'top' || decision.location === 'bottom') {\n      storePrior(elem, box, viewport, state, decision);\n      return tryDecisionToFixedMorph(decision);\n    } else {\n      return Optional.none();\n    }\n  };\n  var tryMorphToOriginalOrUpdateFixed = function tryMorphToOriginalOrUpdateFixed(elem, viewport, state) {\n    return tryMorphToOriginal(elem, viewport, state).orThunk(function () {\n      return viewport.optScrollEnv.bind(function (_) {\n        return getPrior(elem, viewport, state);\n      }).bind(function (_ref18) {\n        var box = _ref18.box,\n          location = _ref18.location;\n        var winBox = win();\n        var leftX = getDockedLeftPosition({\n          win: winBox,\n          box: box\n        });\n        var decision = location === 'top' ? forceTopPosition(winBox, leftX, viewport) : forceBottomPosition(winBox, leftX, viewport);\n        return tryDecisionToFixedMorph(decision);\n      });\n    });\n  };\n  var tryMorph = function tryMorph(component, viewport, state) {\n    var elem = component.element;\n    var isDocked = is$1(getRaw(elem, 'position'), 'fixed');\n    return isDocked ? tryMorphToOriginalOrUpdateFixed(elem, viewport, state) : tryMorphToFixed(elem, viewport, state);\n  };\n  var calculateMorphToOriginal = function calculateMorphToOriginal(component, viewport, state) {\n    var elem = component.element;\n    return getPrior(elem, viewport, state).bind(function (_ref19) {\n      var box = _ref19.box;\n      return revertToOriginal(elem, box, state);\n    });\n  };\n  var forceDockWith = function forceDockWith(elem, viewport, state, getDecision) {\n    var box = box$1(elem);\n    var winBox = win();\n    var leftX = getDockedLeftPosition({\n      win: winBox,\n      box: box\n    });\n    var decision = getDecision(winBox, leftX, viewport);\n    if (decision.location === 'bottom' || decision.location === 'top') {\n      storePriorIfNone(elem, box, viewport, state, decision);\n      return tryDecisionToFixedMorph(decision);\n    } else {\n      return Optional.none();\n    }\n  };\n  var morphToStatic = function morphToStatic(component, config, state) {\n    state.setDocked(false);\n    each$1(['left', 'right', 'top', 'bottom', 'position'], function (prop) {\n      return remove$6(component.element, prop);\n    });\n    config.onUndocked(component);\n  };\n  var morphToCoord = function morphToCoord(component, config, state, position) {\n    var isDocked = position.position === 'fixed';\n    state.setDocked(isDocked);\n    applyPositionCss(component.element, position);\n    var method = isDocked ? config.onDocked : config.onUndocked;\n    method(component);\n  };\n  var updateVisibility = function updateVisibility(component, config, state, viewport) {\n    var morphToDocked = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    config.contextual.each(function (contextInfo) {\n      contextInfo.lazyContext(component).each(function (box) {\n        var isVisible = isPartiallyVisible(box, viewport.bounds);\n        if (isVisible !== state.isVisible()) {\n          state.setVisible(isVisible);\n          if (morphToDocked && !isVisible) {\n            add$1(component.element, [contextInfo.fadeOutClass]);\n            contextInfo.onHide(component);\n          } else {\n            var method = isVisible ? appear : disappear;\n            method(component, contextInfo);\n          }\n        }\n      });\n    });\n  };\n  var applyFixedMorph = function applyFixedMorph(component, config, state, viewport, morph) {\n    updateVisibility(component, config, state, viewport, true);\n    morphToCoord(component, config, state, morph.positionCss);\n  };\n  var applyMorph = function applyMorph(component, config, state, viewport, morph) {\n    switch (morph.morph) {\n      case 'static':\n        {\n          return morphToStatic(component, config, state);\n        }\n      case 'absolute':\n        {\n          return morphToCoord(component, config, state, morph.positionCss);\n        }\n      case 'fixed':\n        {\n          return applyFixedMorph(component, config, state, viewport, morph);\n        }\n    }\n  };\n  var refreshInternal = function refreshInternal(component, config, state) {\n    var viewport = config.lazyViewport(component);\n    updateVisibility(component, config, state, viewport);\n    tryMorph(component, viewport, state).each(function (morph) {\n      applyMorph(component, config, state, viewport, morph);\n    });\n  };\n  var resetInternal = function resetInternal(component, config, state) {\n    var elem = component.element;\n    state.setDocked(false);\n    var viewport = config.lazyViewport(component);\n    calculateMorphToOriginal(component, viewport, state).each(function (staticOrAbsoluteMorph) {\n      switch (staticOrAbsoluteMorph.morph) {\n        case 'static':\n          {\n            morphToStatic(component, config, state);\n            break;\n          }\n        case 'absolute':\n          {\n            morphToCoord(component, config, state, staticOrAbsoluteMorph.positionCss);\n            break;\n          }\n      }\n    });\n    state.setVisible(true);\n    config.contextual.each(function (contextInfo) {\n      remove$1(elem, [contextInfo.fadeInClass, contextInfo.fadeOutClass, contextInfo.transitionClass]);\n      contextInfo.onShow(component);\n    });\n    refresh$3(component, config, state);\n  };\n  var refresh$3 = function refresh$3(component, config, state) {\n    if (component.getSystem().isConnected()) {\n      refreshInternal(component, config, state);\n    }\n  };\n  var reset = function reset(component, config, state) {\n    if (state.isDocked()) {\n      resetInternal(component, config, state);\n    }\n  };\n  var forceDockWithDecision = function forceDockWithDecision(getDecision) {\n    return function (component, config, state) {\n      var viewport = config.lazyViewport(component);\n      var optMorph = forceDockWith(component.element, viewport, state, getDecision);\n      optMorph.each(function (morph) {\n        applyFixedMorph(component, config, state, viewport, morph);\n      });\n    };\n  };\n  var forceDockToTop = forceDockWithDecision(forceTopPosition);\n  var forceDockToBottom = forceDockWithDecision(forceBottomPosition);\n  var isDocked$1 = function isDocked$1(component, config, state) {\n    return state.isDocked();\n  };\n  var setModes = function setModes(component, config, state, modes) {\n    return state.setModes(modes);\n  };\n  var getModes = function getModes(component, config, state) {\n    return state.getModes();\n  };\n  var DockingApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    refresh: refresh$3,\n    reset: reset,\n    isDocked: isDocked$1,\n    getModes: getModes,\n    setModes: setModes,\n    forceDockToTop: forceDockToTop,\n    forceDockToBottom: forceDockToBottom\n  });\n  var events$4 = function events$4(dockInfo, dockState) {\n    return derive$2([runOnSource(transitionend(), function (component, simulatedEvent) {\n      dockInfo.contextual.each(function (contextInfo) {\n        if (has(component.element, contextInfo.transitionClass)) {\n          remove$1(component.element, [contextInfo.transitionClass, contextInfo.fadeInClass]);\n          var notify = dockState.isVisible() ? contextInfo.onShown : contextInfo.onHidden;\n          notify(component);\n        }\n        simulatedEvent.stop();\n      });\n    }), run$1(windowScroll(), function (component, _) {\n      refresh$3(component, dockInfo, dockState);\n    }), run$1(externalElementScroll(), function (component, _) {\n      refresh$3(component, dockInfo, dockState);\n    }), run$1(windowResize(), function (component, _) {\n      reset(component, dockInfo, dockState);\n    })]);\n  };\n  var ActiveDocking = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    events: events$4\n  });\n  var DockingSchema = [optionObjOf('contextual', [requiredString('fadeInClass'), requiredString('fadeOutClass'), requiredString('transitionClass'), requiredFunction('lazyContext'), onHandler('onShow'), onHandler('onShown'), onHandler('onHide'), onHandler('onHidden')]), defaultedFunction('lazyViewport', function () {\n    return {\n      bounds: win(),\n      optScrollEnv: Optional.none()\n    };\n  }), defaultedArrayOf('modes', ['top', 'bottom'], string), onHandler('onDocked'), onHandler('onUndocked')];\n  var init$5 = function init$5(spec) {\n    var docked = Cell(false);\n    var visible = Cell(true);\n    var initialBounds = value$2();\n    var modes = Cell(spec.modes);\n    var readState = function readState() {\n      return \"docked:  \".concat(docked.get(), \", visible: \").concat(visible.get(), \", modes: \").concat(modes.get().join(','));\n    };\n    return nu$8({\n      isDocked: docked.get,\n      setDocked: docked.set,\n      getInitialPos: initialBounds.get,\n      setInitialPos: initialBounds.set,\n      clearInitialPos: initialBounds.clear,\n      isVisible: visible.get,\n      setVisible: visible.set,\n      getModes: modes.get,\n      setModes: modes.set,\n      readState: readState\n    });\n  };\n  var DockingState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    init: init$5\n  });\n  var Docking = create$4({\n    fields: DockingSchema,\n    name: 'docking',\n    active: ActiveDocking,\n    apis: DockingApis,\n    state: DockingState\n  });\n  var toolbarHeightChange = constant$1(generate$6('toolbar-height-change'));\n  var visibility = {\n    fadeInClass: 'tox-editor-dock-fadein',\n    fadeOutClass: 'tox-editor-dock-fadeout',\n    transitionClass: 'tox-editor-dock-transition'\n  };\n  var editorStickyOnClass = 'tox-tinymce--toolbar-sticky-on';\n  var editorStickyOffClass = 'tox-tinymce--toolbar-sticky-off';\n  var scrollFromBehindHeader = function scrollFromBehindHeader(e, containerHeader) {\n    var doc = owner$4(containerHeader);\n    var win = defaultView(containerHeader);\n    var viewHeight = win.dom.innerHeight;\n    var scrollPos = get$b(doc);\n    var markerElement = SugarElement.fromDom(e.elm);\n    var markerPos = absolute$2(markerElement);\n    var markerHeight = get$d(markerElement);\n    var markerTop = markerPos.y;\n    var markerBottom = markerTop + markerHeight;\n    var editorHeaderPos = absolute$3(containerHeader);\n    var editorHeaderHeight = get$d(containerHeader);\n    var editorHeaderTop = editorHeaderPos.top;\n    var editorHeaderBottom = editorHeaderTop + editorHeaderHeight;\n    var editorHeaderDockedAtTop = Math.abs(editorHeaderTop - scrollPos.top) < 2;\n    var editorHeaderDockedAtBottom = Math.abs(editorHeaderBottom - (scrollPos.top + viewHeight)) < 2;\n    if (editorHeaderDockedAtTop && markerTop < editorHeaderBottom) {\n      to(scrollPos.left, markerTop - editorHeaderHeight, doc);\n    } else if (editorHeaderDockedAtBottom && markerBottom > editorHeaderTop) {\n      var y = markerTop - viewHeight + markerHeight + editorHeaderHeight;\n      to(scrollPos.left, y, doc);\n    }\n  };\n  var isDockedMode = function isDockedMode(header, mode) {\n    return contains$2(Docking.getModes(header), mode);\n  };\n  var updateIframeContentFlow = function updateIframeContentFlow(header) {\n    var getOccupiedHeight = function getOccupiedHeight(elm) {\n      return getOuter$2(elm) + (parseInt(get$e(elm, 'margin-top'), 10) || 0) + (parseInt(get$e(elm, 'margin-bottom'), 10) || 0);\n    };\n    var elm = header.element;\n    parentElement(elm).each(function (parentElem) {\n      var padding = 'padding-' + Docking.getModes(header)[0];\n      if (Docking.isDocked(header)) {\n        var parentWidth = get$c(parentElem);\n        set$8(elm, 'width', parentWidth + 'px');\n        set$8(parentElem, padding, getOccupiedHeight(elm) + 'px');\n      } else {\n        remove$6(elm, 'width');\n        remove$6(parentElem, padding);\n      }\n    });\n  };\n  var updateSinkVisibility = function updateSinkVisibility(sinkElem, visible) {\n    if (visible) {\n      remove$2(sinkElem, visibility.fadeOutClass);\n      add$1(sinkElem, [visibility.transitionClass, visibility.fadeInClass]);\n    } else {\n      remove$2(sinkElem, visibility.fadeInClass);\n      add$1(sinkElem, [visibility.fadeOutClass, visibility.transitionClass]);\n    }\n  };\n  var updateEditorClasses = function updateEditorClasses(editor, docked) {\n    var editorContainer = SugarElement.fromDom(editor.getContainer());\n    if (docked) {\n      add$2(editorContainer, editorStickyOnClass);\n      remove$2(editorContainer, editorStickyOffClass);\n    } else {\n      add$2(editorContainer, editorStickyOffClass);\n      remove$2(editorContainer, editorStickyOnClass);\n    }\n  };\n  var restoreFocus = function restoreFocus(headerElem, focusedElem) {\n    var ownerDoc = owner$4(focusedElem);\n    active$1(ownerDoc).filter(function (activeElm) {\n      return !eq(focusedElem, activeElm);\n    }).filter(function (activeElm) {\n      return eq(activeElm, SugarElement.fromDom(ownerDoc.dom.body)) || contains(headerElem, activeElm);\n    }).each(function () {\n      return focus$3(focusedElem);\n    });\n  };\n  var findFocusedElem = function findFocusedElem(rootElm, lazySink) {\n    return search(rootElm).orThunk(function () {\n      return lazySink().toOptional().bind(function (sink) {\n        return search(sink.element);\n      });\n    });\n  };\n  var setup$9 = function setup$9(editor, sharedBackstage, lazyHeader) {\n    if (!editor.inline) {\n      if (!sharedBackstage.header.isPositionedAtTop()) {\n        editor.on('ResizeEditor', function () {\n          lazyHeader().each(Docking.reset);\n        });\n      }\n      editor.on('ResizeWindow ResizeEditor', function () {\n        lazyHeader().each(updateIframeContentFlow);\n      });\n      editor.on('SkinLoaded', function () {\n        lazyHeader().each(function (comp) {\n          Docking.isDocked(comp) ? Docking.reset(comp) : Docking.refresh(comp);\n        });\n      });\n      editor.on('FullscreenStateChanged', function () {\n        lazyHeader().each(Docking.reset);\n      });\n    }\n    editor.on('AfterScrollIntoView', function (e) {\n      lazyHeader().each(function (header) {\n        Docking.refresh(header);\n        var headerElem = header.element;\n        if (isVisible(headerElem)) {\n          scrollFromBehindHeader(e, headerElem);\n        }\n      });\n    });\n    editor.on('PostRender', function () {\n      updateEditorClasses(editor, false);\n    });\n  };\n  var isDocked = function isDocked(lazyHeader) {\n    return lazyHeader().map(Docking.isDocked).getOr(false);\n  };\n  var getIframeBehaviours = function getIframeBehaviours() {\n    return [Receiving.config({\n      channels: _defineProperty({}, toolbarHeightChange(), {\n        onReceive: updateIframeContentFlow\n      })\n    })];\n  };\n  var getBehaviours = function getBehaviours(editor, sharedBackstage) {\n    var focusedElm = value$2();\n    var lazySink = sharedBackstage.getSink;\n    var runOnSinkElement = function runOnSinkElement(f) {\n      lazySink().each(function (sink) {\n        return f(sink.element);\n      });\n    };\n    var onDockingSwitch = function onDockingSwitch(comp) {\n      if (!editor.inline) {\n        updateIframeContentFlow(comp);\n      }\n      updateEditorClasses(editor, Docking.isDocked(comp));\n      comp.getSystem().broadcastOn([repositionPopups()], {});\n      lazySink().each(function (sink) {\n        return sink.getSystem().broadcastOn([repositionPopups()], {});\n      });\n    };\n    var additionalBehaviours = editor.inline ? [] : getIframeBehaviours();\n    return [Focusing.config({}), Docking.config({\n      contextual: _objectSpread({\n        lazyContext: function lazyContext(comp) {\n          var headerHeight = getOuter$2(comp.element);\n          var container = editor.inline ? editor.getContentAreaContainer() : editor.getContainer();\n          return Optional.from(container).map(function (c) {\n            var box = box$1(SugarElement.fromDom(c));\n            var optScrollingContext = detectWhenSplitUiMode(editor, comp.element);\n            return optScrollingContext.fold(function () {\n              var boxHeight = box.height - headerHeight;\n              var topBound = box.y + (isDockedMode(comp, 'top') ? 0 : headerHeight);\n              return bounds(box.x, topBound, box.width, boxHeight);\n            }, function (scrollEnv) {\n              var constrainedBounds = constrain(box, getBoundsFrom(scrollEnv));\n              var constrainedBoundsY = isDockedMode(comp, 'top') ? constrainedBounds.y : constrainedBounds.y + headerHeight;\n              return bounds(constrainedBounds.x, constrainedBoundsY, constrainedBounds.width, constrainedBounds.height - headerHeight);\n            });\n          });\n        },\n        onShow: function onShow() {\n          runOnSinkElement(function (elem) {\n            return updateSinkVisibility(elem, true);\n          });\n        },\n        onShown: function onShown(comp) {\n          runOnSinkElement(function (elem) {\n            return remove$1(elem, [visibility.transitionClass, visibility.fadeInClass]);\n          });\n          focusedElm.get().each(function (elem) {\n            restoreFocus(comp.element, elem);\n            focusedElm.clear();\n          });\n        },\n        onHide: function onHide(comp) {\n          findFocusedElem(comp.element, lazySink).fold(focusedElm.clear, focusedElm.set);\n          runOnSinkElement(function (elem) {\n            return updateSinkVisibility(elem, false);\n          });\n        },\n        onHidden: function onHidden() {\n          runOnSinkElement(function (elem) {\n            return remove$1(elem, [visibility.transitionClass]);\n          });\n        }\n      }, visibility),\n      lazyViewport: function lazyViewport(comp) {\n        var optScrollingContext = detectWhenSplitUiMode(editor, comp.element);\n        return optScrollingContext.fold(function () {\n          var boundsWithoutOffset = win();\n          var offset = getStickyToolbarOffset(editor);\n          var top = boundsWithoutOffset.y + (isDockedMode(comp, 'top') ? offset : 0);\n          var height = boundsWithoutOffset.height - (isDockedMode(comp, 'bottom') ? offset : 0);\n          return {\n            bounds: bounds(boundsWithoutOffset.x, top, boundsWithoutOffset.width, height),\n            optScrollEnv: Optional.none()\n          };\n        }, function (sc) {\n          var combinedBounds = getBoundsFrom(sc);\n          return {\n            bounds: combinedBounds,\n            optScrollEnv: Optional.some({\n              currentScrollTop: sc.element.dom.scrollTop,\n              scrollElmTop: absolute$3(sc.element).top\n            })\n          };\n        });\n      },\n      modes: [sharedBackstage.header.getDockingMode()],\n      onDocked: onDockingSwitch,\n      onUndocked: onDockingSwitch\n    })].concat(_toConsumableArray(additionalBehaviours));\n  };\n  var StickyHeader = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setup: setup$9,\n    isDocked: isDocked,\n    getBehaviours: getBehaviours\n  });\n  var renderHeader = function renderHeader(spec) {\n    var editor = spec.editor;\n    var getBehaviours$2 = spec.sticky ? getBehaviours : getBehaviours$1;\n    return {\n      uid: spec.uid,\n      dom: spec.dom,\n      components: spec.components,\n      behaviours: derive$1(getBehaviours$2(editor, spec.sharedBackstage))\n    };\n  };\n  var groupToolbarButtonSchema = objOf([type, requiredOf('items', oneOf([arrOfObj([name$1, requiredArrayOf('items', string)]), string]))].concat(baseToolbarButtonFields));\n  var createGroupToolbarButton = function createGroupToolbarButton(spec) {\n    return asRaw('GroupToolbarButton', groupToolbarButtonSchema, spec);\n  };\n  var baseMenuButtonFields = [optionString('text'), optionString('tooltip'), optionString('icon'), defaultedOf('search', false, oneOf([boolean, objOf([optionString('placeholder')])], function (x) {\n    if (isBoolean(x)) {\n      return x ? Optional.some({\n        placeholder: Optional.none()\n      }) : Optional.none();\n    } else {\n      return Optional.some(x);\n    }\n  })), requiredFunction('fetch'), defaultedFunction('onSetup', function () {\n    return noop;\n  })];\n  var MenuButtonSchema = objOf([type].concat(baseMenuButtonFields));\n  var createMenuButton = function createMenuButton(spec) {\n    return asRaw('menubutton', MenuButtonSchema, spec);\n  };\n  var splitButtonSchema = objOf([type, optionalTooltip, optionalIcon, optionalText, optionalSelect, fetch$1, onSetup, defaultedStringEnum('presets', 'normal', ['normal', 'color', 'listpreview']), defaultedColumns(1), onAction, onItemAction]);\n  var createSplitButton = function createSplitButton(spec) {\n    return asRaw('SplitButton', splitButtonSchema, spec);\n  };\n  var factory$d = function factory$d(detail, spec) {\n    var setMenus = function setMenus(comp, menus) {\n      var newMenus = map$2(menus, function (m) {\n        var buttonSpec = {\n          type: 'menubutton',\n          text: m.text,\n          fetch: function fetch(callback) {\n            callback(m.getItems());\n          }\n        };\n        var internal = createMenuButton(buttonSpec).mapError(function (errInfo) {\n          return formatError(errInfo);\n        }).getOrDie();\n        return renderMenuButton(internal, 'tox-mbtn', spec.backstage, Optional.some('menuitem'));\n      });\n      Replacing.set(comp, newMenus);\n    };\n    var apis = {\n      focus: Keying.focusIn,\n      setMenus: setMenus\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: [],\n      behaviours: derive$1([Replacing.config({}), config('menubar-events', [runOnAttached(function (component) {\n        detail.onSetup(component);\n      }), run$1(mouseover(), function (comp, se) {\n        descendant(comp.element, '.' + 'tox-mbtn--active').each(function (activeButton) {\n          closest$1(se.event.target, '.' + 'tox-mbtn').each(function (hoveredButton) {\n            if (!eq(activeButton, hoveredButton)) {\n              comp.getSystem().getByDom(activeButton).each(function (activeComp) {\n                comp.getSystem().getByDom(hoveredButton).each(function (hoveredComp) {\n                  Dropdown.expand(hoveredComp);\n                  Dropdown.close(activeComp);\n                  Focusing.focus(hoveredComp);\n                });\n              });\n            }\n          });\n        });\n      }), run$1(focusShifted(), function (comp, se) {\n        se.event.prevFocus.bind(function (prev) {\n          return comp.getSystem().getByDom(prev).toOptional();\n        }).each(function (prev) {\n          se.event.newFocus.bind(function (nu) {\n            return comp.getSystem().getByDom(nu).toOptional();\n          }).each(function (nu) {\n            if (Dropdown.isOpen(prev)) {\n              Dropdown.expand(nu);\n              Dropdown.close(prev);\n            }\n          });\n        });\n      })]), Keying.config({\n        mode: 'flow',\n        selector: '.' + 'tox-mbtn',\n        onEscape: function onEscape(comp) {\n          detail.onEscape(comp);\n          return Optional.some(true);\n        }\n      }), Tabstopping.config({})]),\n      apis: apis,\n      domModification: {\n        attributes: {\n          role: 'menubar'\n        }\n      }\n    };\n  };\n  var SilverMenubar = single({\n    factory: factory$d,\n    name: 'silver.Menubar',\n    configFields: [required$1('dom'), required$1('uid'), required$1('onEscape'), required$1('backstage'), defaulted('onSetup', noop)],\n    apis: {\n      focus: function focus(apis, comp) {\n        apis.focus(comp);\n      },\n      setMenus: function setMenus(apis, comp, menus) {\n        apis.setMenus(comp, menus);\n      }\n    }\n  });\n  var promotionMessage = \"\\u26A1\\uFE0FUpgrade\";\n  var promotionLink = 'https://www.tiny.cloud/tinymce-self-hosted-premium-features/?utm_source=TinyMCE&utm_medium=SPAP&utm_campaign=SPAP&utm_id=editorreferral';\n  var renderPromotion = function renderPromotion(spec) {\n    return {\n      uid: spec.uid,\n      dom: spec.dom,\n      components: [{\n        dom: {\n          tag: 'a',\n          attributes: {\n            'href': promotionLink,\n            'rel': 'noopener',\n            'target': '_blank',\n            'aria-hidden': 'true'\n          },\n          classes: ['tox-promotion-link'],\n          innerHtml: promotionMessage\n        }\n      }]\n    };\n  };\n  var owner = 'container';\n  var schema$d = [field('slotBehaviours', [])];\n  var getPartName = function getPartName(name) {\n    return '<alloy.field.' + name + '>';\n  };\n  var sketch = function sketch(sSpec) {\n    var parts = function () {\n      var record = [];\n      var slot = function slot(name, config) {\n        record.push(name);\n        return generateOne$1(owner, getPartName(name), config);\n      };\n      return {\n        slot: slot,\n        record: constant$1(record)\n      };\n    }();\n    var spec = sSpec(parts);\n    var partNames = parts.record();\n    var fieldParts = map$2(partNames, function (n) {\n      return required({\n        name: n,\n        pname: getPartName(n)\n      });\n    });\n    return composite$1(owner, schema$d, fieldParts, make$1, spec);\n  };\n  var make$1 = function make$1(detail, components) {\n    var getSlotNames = function getSlotNames(_) {\n      return getAllPartNames(detail);\n    };\n    var getSlot = function getSlot(container, key) {\n      return getPart(container, detail, key);\n    };\n    var onSlot = function onSlot(f, def) {\n      return function (container, key) {\n        return getPart(container, detail, key).map(function (slot) {\n          return f(slot, key);\n        }).getOr(def);\n      };\n    };\n    var onSlots = function onSlots(f) {\n      return function (container, keys) {\n        each$1(keys, function (key) {\n          return f(container, key);\n        });\n      };\n    };\n    var doShowing = function doShowing(comp, _key) {\n      return get$f(comp.element, 'aria-hidden') !== 'true';\n    };\n    var doShow = function doShow(comp, key) {\n      if (!doShowing(comp)) {\n        var _element2 = comp.element;\n        remove$6(_element2, 'display');\n        remove$7(_element2, 'aria-hidden');\n        emitWith(comp, slotVisibility(), {\n          name: key,\n          visible: true\n        });\n      }\n    };\n    var doHide = function doHide(comp, key) {\n      if (doShowing(comp)) {\n        var _element3 = comp.element;\n        set$8(_element3, 'display', 'none');\n        set$9(_element3, 'aria-hidden', 'true');\n        emitWith(comp, slotVisibility(), {\n          name: key,\n          visible: false\n        });\n      }\n    };\n    var isShowing = onSlot(doShowing, false);\n    var hideSlot = onSlot(doHide);\n    var hideSlots = onSlots(hideSlot);\n    var hideAllSlots = function hideAllSlots(container) {\n      return hideSlots(container, getSlotNames());\n    };\n    var showSlot = onSlot(doShow);\n    var apis = {\n      getSlotNames: getSlotNames,\n      getSlot: getSlot,\n      isShowing: isShowing,\n      hideSlot: hideSlot,\n      hideAllSlots: hideAllSlots,\n      showSlot: showSlot\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      behaviours: get$3(detail.slotBehaviours),\n      apis: apis\n    };\n  };\n  var slotApis = map$1({\n    getSlotNames: function getSlotNames(apis, c) {\n      return apis.getSlotNames(c);\n    },\n    getSlot: function getSlot(apis, c, key) {\n      return apis.getSlot(c, key);\n    },\n    isShowing: function isShowing(apis, c, key) {\n      return apis.isShowing(c, key);\n    },\n    hideSlot: function hideSlot(apis, c, key) {\n      return apis.hideSlot(c, key);\n    },\n    hideAllSlots: function hideAllSlots(apis, c) {\n      return apis.hideAllSlots(c);\n    },\n    showSlot: function showSlot(apis, c, key) {\n      return apis.showSlot(c, key);\n    }\n  }, function (value) {\n    return makeApi(value);\n  });\n  var SlotContainer = _objectSpread({}, slotApis, {\n    sketch: sketch\n  });\n  var sidebarSchema = objOf([optionalIcon, optionalTooltip, defaultedFunction('onShow', noop), defaultedFunction('onHide', noop), onSetup]);\n  var createSidebar = function createSidebar(spec) {\n    return asRaw('sidebar', sidebarSchema, spec);\n  };\n  var setup$8 = function setup$8(editor) {\n    var _editor$ui$registry$g = editor.ui.registry.getAll(),\n      sidebars = _editor$ui$registry$g.sidebars;\n    each$1(keys(sidebars), function (name) {\n      var spec = sidebars[name];\n      var isActive = function isActive() {\n        return is$1(Optional.from(editor.queryCommandValue('ToggleSidebar')), name);\n      };\n      editor.ui.registry.addToggleButton(name, {\n        icon: spec.icon,\n        tooltip: spec.tooltip,\n        onAction: function onAction(buttonApi) {\n          editor.execCommand('ToggleSidebar', false, name);\n          buttonApi.setActive(isActive());\n        },\n        onSetup: function onSetup(buttonApi) {\n          buttonApi.setActive(isActive());\n          var handleToggle = function handleToggle() {\n            return buttonApi.setActive(isActive());\n          };\n          editor.on('ToggleSidebar', handleToggle);\n          return function () {\n            editor.off('ToggleSidebar', handleToggle);\n          };\n        }\n      });\n    });\n  };\n  var getApi = function getApi(comp) {\n    return {\n      element: function element() {\n        return comp.element.dom;\n      }\n    };\n  };\n  var makePanels = function makePanels(parts, panelConfigs) {\n    var specs = map$2(keys(panelConfigs), function (name) {\n      var spec = panelConfigs[name];\n      var bridged = getOrDie(createSidebar(spec));\n      return {\n        name: name,\n        getApi: getApi,\n        onSetup: bridged.onSetup,\n        onShow: bridged.onShow,\n        onHide: bridged.onHide\n      };\n    });\n    return map$2(specs, function (spec) {\n      var editorOffCell = Cell(noop);\n      return parts.slot(spec.name, {\n        dom: {\n          tag: 'div',\n          classes: ['tox-sidebar__pane']\n        },\n        behaviours: SimpleBehaviours.unnamedEvents([onControlAttached(spec, editorOffCell), onControlDetached(spec, editorOffCell), run$1(slotVisibility(), function (sidepanel, se) {\n          var data = se.event;\n          var optSidePanelSpec = find$5(specs, function (config) {\n            return config.name === data.name;\n          });\n          optSidePanelSpec.each(function (sidePanelSpec) {\n            var handler = data.visible ? sidePanelSpec.onShow : sidePanelSpec.onHide;\n            handler(sidePanelSpec.getApi(sidepanel));\n          });\n        })])\n      });\n    });\n  };\n  var makeSidebar = function makeSidebar(panelConfigs) {\n    return SlotContainer.sketch(function (parts) {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-sidebar__pane-container']\n        },\n        components: makePanels(parts, panelConfigs),\n        slotBehaviours: SimpleBehaviours.unnamedEvents([runOnAttached(function (slotContainer) {\n          return SlotContainer.hideAllSlots(slotContainer);\n        })])\n      };\n    });\n  };\n  var _setSidebar = function setSidebar(sidebar, panelConfigs, showSidebar) {\n    var optSlider = Composing.getCurrent(sidebar);\n    optSlider.each(function (slider) {\n      Replacing.set(slider, [makeSidebar(panelConfigs)]);\n      var configKey = showSidebar === null || showSidebar === void 0 ? void 0 : showSidebar.toLowerCase();\n      if (isString(configKey) && has$2(panelConfigs, configKey)) {\n        Composing.getCurrent(slider).each(function (slotContainer) {\n          SlotContainer.showSlot(slotContainer, configKey);\n          Sliding.immediateGrow(slider);\n          remove$6(slider.element, 'width');\n          updateSidebarRoleOnToggle(sidebar.element, 'region');\n        });\n      }\n    });\n  };\n  var updateSidebarRoleOnToggle = function updateSidebarRoleOnToggle(sidebar, sidebarState) {\n    set$9(sidebar, 'role', sidebarState);\n  };\n  var _toggleSidebar = function toggleSidebar(sidebar, name) {\n    var optSlider = Composing.getCurrent(sidebar);\n    optSlider.each(function (slider) {\n      var optSlotContainer = Composing.getCurrent(slider);\n      optSlotContainer.each(function (slotContainer) {\n        if (Sliding.hasGrown(slider)) {\n          if (SlotContainer.isShowing(slotContainer, name)) {\n            Sliding.shrink(slider);\n            updateSidebarRoleOnToggle(sidebar.element, 'presentation');\n          } else {\n            SlotContainer.hideAllSlots(slotContainer);\n            SlotContainer.showSlot(slotContainer, name);\n            updateSidebarRoleOnToggle(sidebar.element, 'region');\n          }\n        } else {\n          SlotContainer.hideAllSlots(slotContainer);\n          SlotContainer.showSlot(slotContainer, name);\n          Sliding.grow(slider);\n          updateSidebarRoleOnToggle(sidebar.element, 'region');\n        }\n      });\n    });\n  };\n  var _whichSidebar = function whichSidebar(sidebar) {\n    var optSlider = Composing.getCurrent(sidebar);\n    return optSlider.bind(function (slider) {\n      var sidebarOpen = Sliding.isGrowing(slider) || Sliding.hasGrown(slider);\n      if (sidebarOpen) {\n        var optSlotContainer = Composing.getCurrent(slider);\n        return optSlotContainer.bind(function (slotContainer) {\n          return find$5(SlotContainer.getSlotNames(slotContainer), function (name) {\n            return SlotContainer.isShowing(slotContainer, name);\n          });\n        });\n      } else {\n        return Optional.none();\n      }\n    });\n  };\n  var fixSize = generate$6('FixSizeEvent');\n  var autoSize = generate$6('AutoSizeEvent');\n  var renderSidebar = function renderSidebar(spec) {\n    return {\n      uid: spec.uid,\n      dom: {\n        tag: 'div',\n        classes: ['tox-sidebar'],\n        attributes: {\n          role: 'presentation'\n        }\n      },\n      components: [{\n        dom: {\n          tag: 'div',\n          classes: ['tox-sidebar__slider']\n        },\n        components: [],\n        behaviours: derive$1([Tabstopping.config({}), Focusing.config({}), Sliding.config({\n          dimension: {\n            property: 'width'\n          },\n          closedClass: 'tox-sidebar--sliding-closed',\n          openClass: 'tox-sidebar--sliding-open',\n          shrinkingClass: 'tox-sidebar--sliding-shrinking',\n          growingClass: 'tox-sidebar--sliding-growing',\n          onShrunk: function onShrunk(slider) {\n            var optSlotContainer = Composing.getCurrent(slider);\n            optSlotContainer.each(SlotContainer.hideAllSlots);\n            emit(slider, autoSize);\n          },\n          onGrown: function onGrown(slider) {\n            emit(slider, autoSize);\n          },\n          onStartGrow: function onStartGrow(slider) {\n            emitWith(slider, fixSize, {\n              width: getRaw(slider.element, 'width').getOr('')\n            });\n          },\n          onStartShrink: function onStartShrink(slider) {\n            emitWith(slider, fixSize, {\n              width: get$c(slider.element) + 'px'\n            });\n          }\n        }), Replacing.config({}), Composing.config({\n          find: function find(comp) {\n            var children = Replacing.contents(comp);\n            return head(children);\n          }\n        })])\n      }],\n      behaviours: derive$1([ComposingConfigs.childAt(0), config('sidebar-sliding-events', [run$1(fixSize, function (comp, se) {\n        set$8(comp.element, 'width', se.event.width);\n      }), run$1(autoSize, function (comp, _se) {\n        remove$6(comp.element, 'width');\n      })])])\n    };\n  };\n  var block = function block(component, config, state, getBusySpec) {\n    set$9(component.element, 'aria-busy', true);\n    var root = config.getRoot(component).getOr(component);\n    var blockerBehaviours = derive$1([Keying.config({\n      mode: 'special',\n      onTab: function onTab() {\n        return Optional.some(true);\n      },\n      onShiftTab: function onShiftTab() {\n        return Optional.some(true);\n      }\n    }), Focusing.config({})]);\n    var blockSpec = getBusySpec(root, blockerBehaviours);\n    var blocker = root.getSystem().build(blockSpec);\n    Replacing.append(root, premade(blocker));\n    if (blocker.hasConfigured(Keying) && config.focus) {\n      Keying.focusIn(blocker);\n    }\n    if (!state.isBlocked()) {\n      config.onBlock(component);\n    }\n    state.blockWith(function () {\n      return Replacing.remove(root, blocker);\n    });\n  };\n  var unblock = function unblock(component, config, state) {\n    remove$7(component.element, 'aria-busy');\n    if (state.isBlocked()) {\n      config.onUnblock(component);\n    }\n    state.clear();\n  };\n  var isBlocked = function isBlocked(component, blockingConfig, blockingState) {\n    return blockingState.isBlocked();\n  };\n  var BlockingApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    block: block,\n    unblock: unblock,\n    isBlocked: isBlocked\n  });\n  var BlockingSchema = [defaultedFunction('getRoot', Optional.none), defaultedBoolean('focus', true), onHandler('onBlock'), onHandler('onUnblock')];\n  var init$4 = function init$4() {\n    var blocker = destroyable();\n    var blockWith = function blockWith(destroy) {\n      blocker.set({\n        destroy: destroy\n      });\n    };\n    return nu$8({\n      readState: blocker.isSet,\n      blockWith: blockWith,\n      clear: blocker.clear,\n      isBlocked: blocker.isSet\n    });\n  };\n  var BlockingState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    init: init$4\n  });\n  var Blocking = create$4({\n    fields: BlockingSchema,\n    name: 'blocking',\n    apis: BlockingApis,\n    state: BlockingState\n  });\n  var getBusySpec$1 = function getBusySpec$1(providerBackstage) {\n    return function (_root, _behaviours) {\n      return {\n        dom: {\n          tag: 'div',\n          attributes: {\n            'aria-label': providerBackstage.translate('Loading...'),\n            'tabindex': '0'\n          },\n          classes: ['tox-throbber__busy-spinner']\n        },\n        components: [{\n          dom: fromHtml('<div class=\"tox-spinner\"><div></div><div></div><div></div></div>')\n        }]\n      };\n    };\n  };\n  var focusBusyComponent = function focusBusyComponent(throbber) {\n    return Composing.getCurrent(throbber).each(function (comp) {\n      return focus$3(comp.element, true);\n    });\n  };\n  var toggleEditorTabIndex = function toggleEditorTabIndex(editor, state) {\n    var tabIndexAttr = 'tabindex';\n    var dataTabIndexAttr = \"data-mce-\".concat(tabIndexAttr);\n    Optional.from(editor.iframeElement).map(SugarElement.fromDom).each(function (iframe) {\n      if (state) {\n        getOpt(iframe, tabIndexAttr).each(function (tabIndex) {\n          return set$9(iframe, dataTabIndexAttr, tabIndex);\n        });\n        set$9(iframe, tabIndexAttr, -1);\n      } else {\n        remove$7(iframe, tabIndexAttr);\n        getOpt(iframe, dataTabIndexAttr).each(function (tabIndex) {\n          set$9(iframe, tabIndexAttr, tabIndex);\n          remove$7(iframe, dataTabIndexAttr);\n        });\n      }\n    });\n  };\n  var toggleThrobber = function toggleThrobber(editor, comp, state, providerBackstage) {\n    var element = comp.element;\n    toggleEditorTabIndex(editor, state);\n    if (state) {\n      Blocking.block(comp, getBusySpec$1(providerBackstage));\n      remove$6(element, 'display');\n      remove$7(element, 'aria-hidden');\n      if (editor.hasFocus()) {\n        focusBusyComponent(comp);\n      }\n    } else {\n      var throbberFocus = Composing.getCurrent(comp).exists(function (busyComp) {\n        return hasFocus(busyComp.element);\n      });\n      Blocking.unblock(comp);\n      set$8(element, 'display', 'none');\n      set$9(element, 'aria-hidden', 'true');\n      if (throbberFocus) {\n        editor.focus();\n      }\n    }\n  };\n  var renderThrobber = function renderThrobber(spec) {\n    return {\n      uid: spec.uid,\n      dom: {\n        tag: 'div',\n        attributes: {\n          'aria-hidden': 'true'\n        },\n        classes: ['tox-throbber'],\n        styles: {\n          display: 'none'\n        }\n      },\n      behaviours: derive$1([Replacing.config({}), Blocking.config({\n        focus: false\n      }), Composing.config({\n        find: function find(comp) {\n          return head(comp.components());\n        }\n      })]),\n      components: []\n    };\n  };\n  var isFocusEvent = function isFocusEvent(event) {\n    return event.type === 'focusin';\n  };\n  var isPasteBinTarget = function isPasteBinTarget(event) {\n    if (isFocusEvent(event)) {\n      var node = event.composed ? head(event.composedPath()) : Optional.from(event.target);\n      return node.map(SugarElement.fromDom).filter(isElement$1).exists(function (targetElm) {\n        return has(targetElm, 'mce-pastebin');\n      });\n    } else {\n      return false;\n    }\n  };\n  var setup$7 = function setup$7(editor, lazyThrobber, sharedBackstage) {\n    var throbberState = Cell(false);\n    var timer = value$2();\n    var stealFocus = function stealFocus(e) {\n      if (throbberState.get() && !isPasteBinTarget(e)) {\n        e.preventDefault();\n        focusBusyComponent(lazyThrobber());\n        editor.editorManager.setActive(editor);\n      }\n    };\n    if (!editor.inline) {\n      editor.on('PreInit', function () {\n        editor.dom.bind(editor.getWin(), 'focusin', stealFocus);\n        editor.on('BeforeExecCommand', function (e) {\n          if (e.command.toLowerCase() === 'mcefocus' && e.value !== true) {\n            stealFocus(e);\n          }\n        });\n      });\n    }\n    var toggle = function toggle(state) {\n      if (state !== throbberState.get()) {\n        throbberState.set(state);\n        toggleThrobber(editor, lazyThrobber(), state, sharedBackstage.providers);\n        fireAfterProgressState(editor, state);\n      }\n    };\n    editor.on('ProgressState', function (e) {\n      timer.on(clearTimeout);\n      if (isNumber(e.time)) {\n        var timerId = global$9.setEditorTimeout(editor, function () {\n          return toggle(e.state);\n        }, e.time);\n        timer.set(timerId);\n      } else {\n        toggle(e.state);\n        timer.clear();\n      }\n    });\n  };\n  var generate$1 = function generate$1(xs, f) {\n    var init = {\n      len: 0,\n      list: []\n    };\n    var r = foldl(xs, function (b, a) {\n      var value = f(a, b.len);\n      return value.fold(constant$1(b), function (v) {\n        return {\n          len: v.finish,\n          list: b.list.concat([v])\n        };\n      });\n    }, init);\n    return r.list;\n  };\n  var output = function output(within, extra, withinWidth) {\n    return {\n      within: within,\n      extra: extra,\n      withinWidth: withinWidth\n    };\n  };\n  var apportion = function apportion(units, total, len) {\n    var parray = generate$1(units, function (unit, current) {\n      var width = len(unit);\n      return Optional.some({\n        element: unit,\n        start: current,\n        finish: current + width,\n        width: width\n      });\n    });\n    var within = filter$2(parray, function (unit) {\n      return unit.finish <= total;\n    });\n    var withinWidth = foldr(within, function (acc, el) {\n      return acc + el.width;\n    }, 0);\n    var extra = parray.slice(within.length);\n    return {\n      within: within,\n      extra: extra,\n      withinWidth: withinWidth\n    };\n  };\n  var toUnit = function toUnit(parray) {\n    return map$2(parray, function (unit) {\n      return unit.element;\n    });\n  };\n  var fitLast = function fitLast(within, extra, withinWidth) {\n    var fits = toUnit(within.concat(extra));\n    return output(fits, [], withinWidth);\n  };\n  var overflow = function overflow(within, extra, overflower, withinWidth) {\n    var fits = toUnit(within).concat([overflower]);\n    return output(fits, toUnit(extra), withinWidth);\n  };\n  var fitAll = function fitAll(within, extra, withinWidth) {\n    return output(toUnit(within), [], withinWidth);\n  };\n  var tryFit = function tryFit(total, units, len) {\n    var divide = apportion(units, total, len);\n    return divide.extra.length === 0 ? Optional.some(divide) : Optional.none();\n  };\n  var partition = function partition(total, units, len, overflower) {\n    var divide = tryFit(total, units, len).getOrThunk(function () {\n      return apportion(units, total - len(overflower), len);\n    });\n    var within = divide.within;\n    var extra = divide.extra;\n    var withinWidth = divide.withinWidth;\n    if (extra.length === 1 && extra[0].width <= len(overflower)) {\n      return fitLast(within, extra, withinWidth);\n    } else if (extra.length >= 1) {\n      return overflow(within, extra, overflower, withinWidth);\n    } else {\n      return fitAll(within, extra, withinWidth);\n    }\n  };\n  var setGroups$1 = function setGroups$1(toolbar, storedGroups) {\n    var bGroups = map$2(storedGroups, function (g) {\n      return premade(g);\n    });\n    Toolbar.setGroups(toolbar, bGroups);\n  };\n  var findFocusedComp = function findFocusedComp(comps) {\n    return findMap(comps, function (comp) {\n      return search(comp.element).bind(function (focusedElm) {\n        return comp.getSystem().getByDom(focusedElm).toOptional();\n      });\n    });\n  };\n  var refresh$2 = function refresh$2(toolbar, detail, setOverflow) {\n    var builtGroups = detail.builtGroups.get();\n    if (builtGroups.length === 0) {\n      return;\n    }\n    var primary = getPartOrDie(toolbar, detail, 'primary');\n    var overflowGroup = Coupling.getCoupled(toolbar, 'overflowGroup');\n    set$8(primary.element, 'visibility', 'hidden');\n    var groups = builtGroups.concat([overflowGroup]);\n    var focusedComp = findFocusedComp(groups);\n    setOverflow([]);\n    setGroups$1(primary, groups);\n    var availableWidth = get$c(primary.element);\n    var overflows = partition(availableWidth, detail.builtGroups.get(), function (comp) {\n      return get$c(comp.element);\n    }, overflowGroup);\n    if (overflows.extra.length === 0) {\n      Replacing.remove(primary, overflowGroup);\n      setOverflow([]);\n    } else {\n      setGroups$1(primary, overflows.within);\n      setOverflow(overflows.extra);\n    }\n    remove$6(primary.element, 'visibility');\n    reflow(primary.element);\n    focusedComp.each(Focusing.focus);\n  };\n  var schema$c = constant$1([field('splitToolbarBehaviours', [Coupling]), customField('builtGroups', function () {\n    return Cell([]);\n  })]);\n  var schema$b = constant$1([markers$1(['overflowToggledClass']), optionFunction('getOverflowBounds'), required$1('lazySink'), customField('overflowGroups', function () {\n    return Cell([]);\n  }), onHandler('onOpened'), onHandler('onClosed')].concat(schema$c()));\n  var parts$7 = constant$1([required({\n    factory: Toolbar,\n    schema: schema$e(),\n    name: 'primary'\n  }), external({\n    schema: schema$e(),\n    name: 'overflow'\n  }), external({\n    name: 'overflow-button'\n  }), external({\n    name: 'overflow-group'\n  })]);\n  var expandable = constant$1(function (element, available) {\n    setMax(element, Math.floor(available));\n  });\n  var schema$a = constant$1([markers$1(['toggledClass']), required$1('lazySink'), requiredFunction('fetch'), optionFunction('getBounds'), optionObjOf('fireDismissalEventInstead', [defaulted('event', dismissRequested())]), schema$y(), onHandler('onToggled')]);\n  var parts$6 = constant$1([external({\n    name: 'button',\n    overrides: function overrides(detail) {\n      return {\n        dom: {\n          attributes: {\n            'aria-haspopup': 'true'\n          }\n        },\n        buttonBehaviours: derive$1([Toggling.config({\n          toggleClass: detail.markers.toggledClass,\n          aria: {\n            mode: 'expanded'\n          },\n          toggleOnExecute: false,\n          onToggled: detail.onToggled\n        })])\n      };\n    }\n  }), external({\n    factory: Toolbar,\n    schema: schema$e(),\n    name: 'toolbar',\n    overrides: function overrides(detail) {\n      return {\n        toolbarBehaviours: derive$1([Keying.config({\n          mode: 'cyclic',\n          onEscape: function onEscape(comp) {\n            getPart(comp, detail, 'button').each(Focusing.focus);\n            return Optional.none();\n          }\n        })])\n      };\n    }\n  })]);\n  var shouldSkipFocus = value$2();\n  var _toggleWithoutFocusing = function toggleWithoutFocusing(button, externals) {\n    shouldSkipFocus.set(true);\n    _toggle(button, externals);\n    shouldSkipFocus.clear();\n  };\n  var _toggle = function toggle(button, externals) {\n    var toolbarSandbox = Coupling.getCoupled(button, 'toolbarSandbox');\n    if (Sandboxing.isOpen(toolbarSandbox)) {\n      Sandboxing.close(toolbarSandbox);\n    } else {\n      Sandboxing.open(toolbarSandbox, externals.toolbar());\n    }\n  };\n  var position = function position(button, toolbar, detail, layouts) {\n    var bounds = detail.getBounds.map(function (bounder) {\n      return bounder();\n    });\n    var sink = detail.lazySink(button).getOrDie();\n    Positioning.positionWithinBounds(sink, toolbar, {\n      anchor: {\n        type: 'hotspot',\n        hotspot: button,\n        layouts: layouts,\n        overrides: {\n          maxWidthFunction: expandable()\n        }\n      }\n    }, bounds);\n  };\n  var _setGroups = function setGroups(button, toolbar, detail, layouts, groups) {\n    Toolbar.setGroups(toolbar, groups);\n    position(button, toolbar, detail, layouts);\n    Toggling.on(button);\n  };\n  var makeSandbox = function makeSandbox(button, spec, detail) {\n    var ariaControls = manager();\n    var onOpen = function onOpen(sandbox, toolbar) {\n      var skipFocus = shouldSkipFocus.get().getOr(false);\n      detail.fetch().get(function (groups) {\n        _setGroups(button, toolbar, detail, spec.layouts, groups);\n        ariaControls.link(button.element);\n        if (!skipFocus) {\n          Keying.focusIn(toolbar);\n        }\n      });\n    };\n    var onClose = function onClose() {\n      Toggling.off(button);\n      if (!shouldSkipFocus.get().getOr(false)) {\n        Focusing.focus(button);\n      }\n      ariaControls.unlink(button.element);\n    };\n    return {\n      dom: {\n        tag: 'div',\n        attributes: {\n          id: ariaControls.id\n        }\n      },\n      behaviours: derive$1([Keying.config({\n        mode: 'special',\n        onEscape: function onEscape(comp) {\n          Sandboxing.close(comp);\n          return Optional.some(true);\n        }\n      }), Sandboxing.config({\n        onOpen: onOpen,\n        onClose: onClose,\n        isPartOf: function isPartOf(container, data, queryElem) {\n          return isPartOf$1(data, queryElem) || isPartOf$1(button, queryElem);\n        },\n        getAttachPoint: function getAttachPoint() {\n          return detail.lazySink(button).getOrDie();\n        }\n      }), Receiving.config({\n        channels: _objectSpread({}, receivingChannel$1(_objectSpread({\n          isExtraPart: never\n        }, detail.fireDismissalEventInstead.map(function (fe) {\n          return {\n            fireEventInstead: {\n              event: fe.event\n            }\n          };\n        }).getOr({}))), receivingChannel({\n          doReposition: function doReposition() {\n            Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(function (toolbar) {\n              position(button, toolbar, detail, spec.layouts);\n            });\n          }\n        }))\n      })])\n    };\n  };\n  var factory$c = function factory$c(detail, components, spec, externals) {\n    return _objectSpread({}, Button.sketch(_objectSpread({}, externals.button(), {\n      action: function action(button) {\n        _toggle(button, externals);\n      },\n      buttonBehaviours: SketchBehaviours.augment({\n        dump: externals.button().buttonBehaviours\n      }, [Coupling.config({\n        others: {\n          toolbarSandbox: function toolbarSandbox(button) {\n            return makeSandbox(button, spec, detail);\n          }\n        }\n      })])\n    })), {\n      apis: {\n        setGroups: function setGroups(button, groups) {\n          Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(function (toolbar) {\n            _setGroups(button, toolbar, detail, spec.layouts, groups);\n          });\n        },\n        reposition: function reposition(button) {\n          Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each(function (toolbar) {\n            position(button, toolbar, detail, spec.layouts);\n          });\n        },\n        toggle: function toggle(button) {\n          _toggle(button, externals);\n        },\n        toggleWithoutFocusing: function toggleWithoutFocusing(button) {\n          _toggleWithoutFocusing(button, externals);\n        },\n        getToolbar: function getToolbar(button) {\n          return Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox'));\n        },\n        isOpen: function isOpen(button) {\n          return Sandboxing.isOpen(Coupling.getCoupled(button, 'toolbarSandbox'));\n        }\n      }\n    });\n  };\n  var FloatingToolbarButton = composite({\n    name: 'FloatingToolbarButton',\n    factory: factory$c,\n    configFields: schema$a(),\n    partFields: parts$6(),\n    apis: {\n      setGroups: function setGroups(apis, button, groups) {\n        apis.setGroups(button, groups);\n      },\n      reposition: function reposition(apis, button) {\n        apis.reposition(button);\n      },\n      toggle: function toggle(apis, button) {\n        apis.toggle(button);\n      },\n      toggleWithoutFocusing: function toggleWithoutFocusing(apis, button) {\n        apis.toggleWithoutFocusing(button);\n      },\n      getToolbar: function getToolbar(apis, button) {\n        return apis.getToolbar(button);\n      },\n      isOpen: function isOpen(apis, button) {\n        return apis.isOpen(button);\n      }\n    }\n  });\n  var schema$9 = constant$1([required$1('items'), markers$1(['itemSelector']), field('tgroupBehaviours', [Keying])]);\n  var parts$5 = constant$1([group({\n    name: 'items',\n    unit: 'item'\n  })]);\n  var factory$b = function factory$b(detail, components, _spec, _externals) {\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      behaviours: augment(detail.tgroupBehaviours, [Keying.config({\n        mode: 'flow',\n        selector: detail.markers.itemSelector\n      })]),\n      domModification: {\n        attributes: {\n          role: 'toolbar'\n        }\n      }\n    };\n  };\n  var ToolbarGroup = composite({\n    name: 'ToolbarGroup',\n    configFields: schema$9(),\n    partFields: parts$5(),\n    factory: factory$b\n  });\n  var buildGroups = function buildGroups(comps) {\n    return map$2(comps, function (g) {\n      return premade(g);\n    });\n  };\n  var refresh$1 = function refresh$1(toolbar, memFloatingToolbarButton, detail) {\n    refresh$2(toolbar, detail, function (overflowGroups) {\n      detail.overflowGroups.set(overflowGroups);\n      memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {\n        FloatingToolbarButton.setGroups(floatingToolbarButton, buildGroups(overflowGroups));\n      });\n    });\n  };\n  var factory$a = function factory$a(detail, components, spec, externals) {\n    var memFloatingToolbarButton = record(FloatingToolbarButton.sketch({\n      fetch: function fetch() {\n        return Future.nu(function (resolve) {\n          resolve(buildGroups(detail.overflowGroups.get()));\n        });\n      },\n      layouts: {\n        onLtr: function onLtr() {\n          return [southwest$2, southeast$2];\n        },\n        onRtl: function onRtl() {\n          return [southeast$2, southwest$2];\n        },\n        onBottomLtr: function onBottomLtr() {\n          return [northwest$2, northeast$2];\n        },\n        onBottomRtl: function onBottomRtl() {\n          return [northeast$2, northwest$2];\n        }\n      },\n      getBounds: spec.getOverflowBounds,\n      lazySink: detail.lazySink,\n      fireDismissalEventInstead: {},\n      markers: {\n        toggledClass: detail.markers.overflowToggledClass\n      },\n      parts: {\n        button: externals['overflow-button'](),\n        toolbar: externals.overflow()\n      },\n      onToggled: function onToggled(comp, state) {\n        return detail[state ? 'onOpened' : 'onClosed'](comp);\n      }\n    }));\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      behaviours: augment(detail.splitToolbarBehaviours, [Coupling.config({\n        others: {\n          overflowGroup: function overflowGroup() {\n            return ToolbarGroup.sketch(_objectSpread({}, externals['overflow-group'](), {\n              items: [memFloatingToolbarButton.asSpec()]\n            }));\n          }\n        }\n      })]),\n      apis: {\n        setGroups: function setGroups(toolbar, groups) {\n          detail.builtGroups.set(map$2(groups, toolbar.getSystem().build));\n          refresh$1(toolbar, memFloatingToolbarButton, detail);\n        },\n        refresh: function refresh(toolbar) {\n          return refresh$1(toolbar, memFloatingToolbarButton, detail);\n        },\n        toggle: function toggle(toolbar) {\n          memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {\n            FloatingToolbarButton.toggle(floatingToolbarButton);\n          });\n        },\n        toggleWithoutFocusing: function toggleWithoutFocusing(toolbar) {\n          memFloatingToolbarButton.getOpt(toolbar).each(FloatingToolbarButton.toggleWithoutFocusing);\n        },\n        isOpen: function isOpen(toolbar) {\n          return memFloatingToolbarButton.getOpt(toolbar).map(FloatingToolbarButton.isOpen).getOr(false);\n        },\n        reposition: function reposition(toolbar) {\n          memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {\n            FloatingToolbarButton.reposition(floatingToolbarButton);\n          });\n        },\n        getOverflow: function getOverflow(toolbar) {\n          return memFloatingToolbarButton.getOpt(toolbar).bind(FloatingToolbarButton.getToolbar);\n        }\n      },\n      domModification: {\n        attributes: {\n          role: 'group'\n        }\n      }\n    };\n  };\n  var SplitFloatingToolbar = composite({\n    name: 'SplitFloatingToolbar',\n    configFields: schema$b(),\n    partFields: parts$7(),\n    factory: factory$a,\n    apis: {\n      setGroups: function setGroups(apis, toolbar, groups) {\n        apis.setGroups(toolbar, groups);\n      },\n      refresh: function refresh(apis, toolbar) {\n        apis.refresh(toolbar);\n      },\n      reposition: function reposition(apis, toolbar) {\n        apis.reposition(toolbar);\n      },\n      toggle: function toggle(apis, toolbar) {\n        apis.toggle(toolbar);\n      },\n      toggleWithoutFocusing: function toggleWithoutFocusing(apis, toolbar) {\n        apis.toggle(toolbar);\n      },\n      isOpen: function isOpen(apis, toolbar) {\n        return apis.isOpen(toolbar);\n      },\n      getOverflow: function getOverflow(apis, toolbar) {\n        return apis.getOverflow(toolbar);\n      }\n    }\n  });\n  var schema$8 = constant$1([markers$1(['closedClass', 'openClass', 'shrinkingClass', 'growingClass', 'overflowToggledClass']), onHandler('onOpened'), onHandler('onClosed')].concat(schema$c()));\n  var parts$4 = constant$1([required({\n    factory: Toolbar,\n    schema: schema$e(),\n    name: 'primary'\n  }), required({\n    factory: Toolbar,\n    schema: schema$e(),\n    name: 'overflow',\n    overrides: function overrides(detail) {\n      return {\n        toolbarBehaviours: derive$1([Sliding.config({\n          dimension: {\n            property: 'height'\n          },\n          closedClass: detail.markers.closedClass,\n          openClass: detail.markers.openClass,\n          shrinkingClass: detail.markers.shrinkingClass,\n          growingClass: detail.markers.growingClass,\n          onShrunk: function onShrunk(comp) {\n            getPart(comp, detail, 'overflow-button').each(function (button) {\n              Toggling.off(button);\n              Focusing.focus(button);\n            });\n            detail.onClosed(comp);\n          },\n          onGrown: function onGrown(comp) {\n            Keying.focusIn(comp);\n            detail.onOpened(comp);\n          },\n          onStartGrow: function onStartGrow(comp) {\n            getPart(comp, detail, 'overflow-button').each(Toggling.on);\n          }\n        }), Keying.config({\n          mode: 'acyclic',\n          onEscape: function onEscape(comp) {\n            getPart(comp, detail, 'overflow-button').each(Focusing.focus);\n            return Optional.some(true);\n          }\n        })])\n      };\n    }\n  }), external({\n    name: 'overflow-button',\n    overrides: function overrides(detail) {\n      return {\n        buttonBehaviours: derive$1([Toggling.config({\n          toggleClass: detail.markers.overflowToggledClass,\n          aria: {\n            mode: 'pressed'\n          },\n          toggleOnExecute: false\n        })])\n      };\n    }\n  }), external({\n    name: 'overflow-group'\n  })]);\n  var _isOpen = function isOpen(toolbar, detail) {\n    return getPart(toolbar, detail, 'overflow').map(Sliding.hasGrown).getOr(false);\n  };\n  var toggleToolbar = function toggleToolbar(toolbar, detail) {\n    getPart(toolbar, detail, 'overflow-button').bind(function () {\n      return getPart(toolbar, detail, 'overflow');\n    }).each(function (overf) {\n      _refresh(toolbar, detail);\n      Sliding.toggleGrow(overf);\n    });\n  };\n  var _refresh = function refresh(toolbar, detail) {\n    getPart(toolbar, detail, 'overflow').each(function (overflow) {\n      refresh$2(toolbar, detail, function (groups) {\n        var builtGroups = map$2(groups, function (g) {\n          return premade(g);\n        });\n        Toolbar.setGroups(overflow, builtGroups);\n      });\n      getPart(toolbar, detail, 'overflow-button').each(function (button) {\n        if (Sliding.hasGrown(overflow)) {\n          Toggling.on(button);\n        }\n      });\n      Sliding.refresh(overflow);\n    });\n  };\n  var factory$9 = function factory$9(detail, components, spec, externals) {\n    var toolbarToggleEvent = 'alloy.toolbar.toggle';\n    var doSetGroups = function doSetGroups(toolbar, groups) {\n      var built = map$2(groups, toolbar.getSystem().build);\n      detail.builtGroups.set(built);\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      behaviours: augment(detail.splitToolbarBehaviours, [Coupling.config({\n        others: {\n          overflowGroup: function overflowGroup(toolbar) {\n            return ToolbarGroup.sketch(_objectSpread({}, externals['overflow-group'](), {\n              items: [Button.sketch(_objectSpread({}, externals['overflow-button'](), {\n                action: function action(_button) {\n                  emit(toolbar, toolbarToggleEvent);\n                }\n              }))]\n            }));\n          }\n        }\n      }), config('toolbar-toggle-events', [run$1(toolbarToggleEvent, function (toolbar) {\n        toggleToolbar(toolbar, detail);\n      })])]),\n      apis: {\n        setGroups: function setGroups(toolbar, groups) {\n          doSetGroups(toolbar, groups);\n          _refresh(toolbar, detail);\n        },\n        refresh: function refresh(toolbar) {\n          return _refresh(toolbar, detail);\n        },\n        toggle: function toggle(toolbar) {\n          return toggleToolbar(toolbar, detail);\n        },\n        isOpen: function isOpen(toolbar) {\n          return _isOpen(toolbar, detail);\n        }\n      },\n      domModification: {\n        attributes: {\n          role: 'group'\n        }\n      }\n    };\n  };\n  var SplitSlidingToolbar = composite({\n    name: 'SplitSlidingToolbar',\n    configFields: schema$8(),\n    partFields: parts$4(),\n    factory: factory$9,\n    apis: {\n      setGroups: function setGroups(apis, toolbar, groups) {\n        apis.setGroups(toolbar, groups);\n      },\n      refresh: function refresh(apis, toolbar) {\n        apis.refresh(toolbar);\n      },\n      toggle: function toggle(apis, toolbar) {\n        apis.toggle(toolbar);\n      },\n      isOpen: function isOpen(apis, toolbar) {\n        return apis.isOpen(toolbar);\n      }\n    }\n  });\n  var renderToolbarGroupCommon = function renderToolbarGroupCommon(toolbarGroup) {\n    var attributes = toolbarGroup.title.fold(function () {\n      return {};\n    }, function (title) {\n      return {\n        attributes: {\n          title: title\n        }\n      };\n    });\n    return {\n      dom: _objectSpread({\n        tag: 'div',\n        classes: ['tox-toolbar__group']\n      }, attributes),\n      components: [ToolbarGroup.parts.items({})],\n      items: toolbarGroup.items,\n      markers: {\n        itemSelector: '*:not(.tox-split-button) > .tox-tbtn:not([disabled]), ' + '.tox-split-button:not([disabled]), ' + '.tox-toolbar-nav-js:not([disabled]), ' + '.tox-number-input:not([disabled])'\n      },\n      tgroupBehaviours: derive$1([Tabstopping.config({}), Focusing.config({})])\n    };\n  };\n  var renderToolbarGroup = function renderToolbarGroup(toolbarGroup) {\n    return ToolbarGroup.sketch(renderToolbarGroupCommon(toolbarGroup));\n  };\n  var getToolbarBehaviours = function getToolbarBehaviours(toolbarSpec, modeName) {\n    var onAttached = runOnAttached(function (component) {\n      var groups = map$2(toolbarSpec.initGroups, renderToolbarGroup);\n      Toolbar.setGroups(component, groups);\n    });\n    return derive$1([DisablingConfigs.toolbarButton(toolbarSpec.providers.isDisabled), receivingConfig(), Keying.config({\n      mode: modeName,\n      onEscape: toolbarSpec.onEscape,\n      selector: '.tox-toolbar__group'\n    }), config('toolbar-events', [onAttached])]);\n  };\n  var renderMoreToolbarCommon = function renderMoreToolbarCommon(toolbarSpec) {\n    var modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';\n    return {\n      uid: toolbarSpec.uid,\n      dom: {\n        tag: 'div',\n        classes: ['tox-toolbar-overlord']\n      },\n      parts: {\n        'overflow-group': renderToolbarGroupCommon({\n          title: Optional.none(),\n          items: []\n        }),\n        'overflow-button': renderIconButtonSpec({\n          name: 'more',\n          icon: Optional.some('more-drawer'),\n          enabled: true,\n          tooltip: Optional.some('Reveal or hide additional toolbar items'),\n          primary: false,\n          buttonType: Optional.none(),\n          borderless: false\n        }, Optional.none(), toolbarSpec.providers)\n      },\n      splitToolbarBehaviours: getToolbarBehaviours(toolbarSpec, modeName)\n    };\n  };\n  var renderFloatingMoreToolbar = function renderFloatingMoreToolbar(toolbarSpec) {\n    var baseSpec = renderMoreToolbarCommon(toolbarSpec);\n    var overflowXOffset = 4;\n    var primary = SplitFloatingToolbar.parts.primary({\n      dom: {\n        tag: 'div',\n        classes: ['tox-toolbar__primary']\n      }\n    });\n    return SplitFloatingToolbar.sketch(_objectSpread({}, baseSpec, {\n      lazySink: toolbarSpec.getSink,\n      getOverflowBounds: function getOverflowBounds() {\n        var headerElem = toolbarSpec.moreDrawerData.lazyHeader().element;\n        var headerBounds = absolute$2(headerElem);\n        var docElem = documentElement(headerElem);\n        var docBounds = absolute$2(docElem);\n        var height = Math.max(docElem.dom.scrollHeight, docBounds.height);\n        return bounds(headerBounds.x + overflowXOffset, docBounds.y, headerBounds.width - overflowXOffset * 2, height);\n      },\n      parts: _objectSpread({}, baseSpec.parts, {\n        overflow: {\n          dom: {\n            tag: 'div',\n            classes: ['tox-toolbar__overflow'],\n            attributes: toolbarSpec.attributes\n          }\n        }\n      }),\n      components: [primary],\n      markers: {\n        overflowToggledClass: 'tox-tbtn--enabled'\n      },\n      onOpened: function onOpened(comp) {\n        return toolbarSpec.onToggled(comp, true);\n      },\n      onClosed: function onClosed(comp) {\n        return toolbarSpec.onToggled(comp, false);\n      }\n    }));\n  };\n  var renderSlidingMoreToolbar = function renderSlidingMoreToolbar(toolbarSpec) {\n    var primary = SplitSlidingToolbar.parts.primary({\n      dom: {\n        tag: 'div',\n        classes: ['tox-toolbar__primary']\n      }\n    });\n    var overflow = SplitSlidingToolbar.parts.overflow({\n      dom: {\n        tag: 'div',\n        classes: ['tox-toolbar__overflow']\n      }\n    });\n    var baseSpec = renderMoreToolbarCommon(toolbarSpec);\n    return SplitSlidingToolbar.sketch(_objectSpread({}, baseSpec, {\n      components: [primary, overflow],\n      markers: {\n        openClass: 'tox-toolbar__overflow--open',\n        closedClass: 'tox-toolbar__overflow--closed',\n        growingClass: 'tox-toolbar__overflow--growing',\n        shrinkingClass: 'tox-toolbar__overflow--shrinking',\n        overflowToggledClass: 'tox-tbtn--enabled'\n      },\n      onOpened: function onOpened(comp) {\n        comp.getSystem().broadcastOn([toolbarHeightChange()], {\n          type: 'opened'\n        });\n        toolbarSpec.onToggled(comp, true);\n      },\n      onClosed: function onClosed(comp) {\n        comp.getSystem().broadcastOn([toolbarHeightChange()], {\n          type: 'closed'\n        });\n        toolbarSpec.onToggled(comp, false);\n      }\n    }));\n  };\n  var renderToolbar = function renderToolbar(toolbarSpec) {\n    var modeName = toolbarSpec.cyclicKeying ? 'cyclic' : 'acyclic';\n    return Toolbar.sketch({\n      uid: toolbarSpec.uid,\n      dom: {\n        tag: 'div',\n        classes: ['tox-toolbar'].concat(toolbarSpec.type === ToolbarMode$1.scrolling ? ['tox-toolbar--scrolling'] : [])\n      },\n      components: [Toolbar.parts.groups({})],\n      toolbarBehaviours: getToolbarBehaviours(toolbarSpec, modeName)\n    });\n  };\n  var baseButtonFields = [optionalText, optionalIcon, optionString('tooltip'), defaultedStringEnum('buttonType', 'secondary', ['primary', 'secondary']), defaultedBoolean('borderless', false), requiredFunction('onAction')];\n  var normalButtonFields = [].concat(baseButtonFields, [text, requiredStringEnum('type', ['button'])]);\n  var toggleButtonFields = [].concat(baseButtonFields, [defaultedBoolean('active', false), requiredStringEnum('type', ['togglebutton'])]);\n  var schemaWithoutGroupButton = {\n    button: normalButtonFields,\n    togglebutton: toggleButtonFields\n  };\n  var groupFields = [requiredStringEnum('type', ['group']), defaultedArrayOf('buttons', [], choose$1('type', schemaWithoutGroupButton))];\n  var viewButtonSchema = choose$1('type', _objectSpread({}, schemaWithoutGroupButton, {\n    group: groupFields\n  }));\n  var viewSchema = objOf([defaultedArrayOf('buttons', [], viewButtonSchema), requiredFunction('onShow'), requiredFunction('onHide')]);\n  var createView = function createView(spec) {\n    return asRaw('view', viewSchema, spec);\n  };\n  var renderButton = function renderButton(spec, providers) {\n    var _buttonTypeClasses$co, _buttonTypeClasses$co2, _buttonTypeClasses$co3;\n    var _a, _b;\n    var isToggleButton = spec.type === 'togglebutton';\n    var optMemIcon = spec.icon.map(function (memIcon) {\n      return renderReplaceableIconFromPack(memIcon, providers.icons);\n    }).map(record);\n    var getAction = function getAction() {\n      return function (comp) {\n        var setIcon = function setIcon(newIcon) {\n          optMemIcon.map(function (memIcon) {\n            return memIcon.getOpt(comp).each(function (displayIcon) {\n              Replacing.set(displayIcon, [renderReplaceableIconFromPack(newIcon, providers.icons)]);\n            });\n          });\n        };\n        var setActive = function setActive(state) {\n          var elm = comp.element;\n          if (state) {\n            add$2(elm, 'tox-button--enabled');\n            set$9(elm, 'aria-pressed', true);\n          } else {\n            remove$2(elm, 'tox-button--enabled');\n            remove$7(elm, 'aria-pressed');\n          }\n        };\n        var isActive = function isActive() {\n          return has(comp.element, 'tox-button--enabled');\n        };\n        if (isToggleButton) {\n          return spec.onAction({\n            setIcon: setIcon,\n            setActive: setActive,\n            isActive: isActive\n          });\n        }\n        if (spec.type === 'button') {\n          return spec.onAction({\n            setIcon: setIcon\n          });\n        }\n      };\n    };\n    var action = getAction();\n    var buttonSpec = _objectSpread({}, spec, {\n      name: isToggleButton ? spec.text.getOr(spec.icon.getOr('')) : (_a = spec.text) !== null && _a !== void 0 ? _a : spec.icon.getOr(''),\n      primary: spec.buttonType === 'primary',\n      buttonType: Optional.from(spec.buttonType),\n      tooltip: spec.tooltip,\n      icon: spec.icon,\n      enabled: true,\n      borderless: spec.borderless\n    });\n    var buttonTypeClasses = calculateClassesFromButtonType((_b = spec.buttonType) !== null && _b !== void 0 ? _b : 'secondary');\n    var optTranslatedText = isToggleButton ? spec.text.map(providers.translate) : Optional.some(providers.translate(spec.text));\n    var optTranslatedTextComponed = optTranslatedText.map(text$2);\n    var tooltipAttributes = buttonSpec.tooltip.or(optTranslatedText).map(function (tooltip) {\n      return {\n        'aria-label': providers.translate(tooltip),\n        'title': providers.translate(tooltip)\n      };\n    }).getOr({});\n    var optIconSpec = optMemIcon.map(function (memIcon) {\n      return memIcon.asSpec();\n    });\n    var components = componentRenderPipeline([optIconSpec, optTranslatedTextComponed]);\n    var hasIconAndText = spec.icon.isSome() && optTranslatedTextComponed.isSome();\n    var dom = {\n      tag: 'button',\n      classes: (_buttonTypeClasses$co = (_buttonTypeClasses$co2 = (_buttonTypeClasses$co3 = buttonTypeClasses.concat.apply(buttonTypeClasses, _toConsumableArray(spec.icon.isSome() && !hasIconAndText ? ['tox-button--icon'] : []))).concat.apply(_buttonTypeClasses$co3, _toConsumableArray(hasIconAndText ? ['tox-button--icon-and-text'] : []))).concat.apply(_buttonTypeClasses$co2, _toConsumableArray(spec.borderless ? ['tox-button--naked'] : []))).concat.apply(_buttonTypeClasses$co, _toConsumableArray(spec.type === 'togglebutton' && spec.active ? ['tox-button--enabled'] : [])),\n      attributes: tooltipAttributes\n    };\n    var extraBehaviours = [];\n    var iconButtonSpec = renderCommonSpec(buttonSpec, Optional.some(action), extraBehaviours, dom, components, providers);\n    return Button.sketch(iconButtonSpec);\n  };\n  var renderViewButton = function renderViewButton(spec, providers) {\n    return renderButton(spec, providers);\n  };\n  var renderButtonsGroup = function renderButtonsGroup(spec, providers) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-view__toolbar__group']\n      },\n      components: map$2(spec.buttons, function (button) {\n        return renderViewButton(button, providers);\n      })\n    };\n  };\n  var deviceDetection = detect$2().deviceType;\n  var isPhone = deviceDetection.isPhone();\n  var isTablet = deviceDetection.isTablet();\n  var renderViewHeader = function renderViewHeader(spec) {\n    var hasGroups = false;\n    var endButtons = map$2(spec.buttons, function (btnspec) {\n      if (btnspec.type === 'group') {\n        hasGroups = true;\n        return renderButtonsGroup(btnspec, spec.providers);\n      } else {\n        return renderViewButton(btnspec, spec.providers);\n      }\n    });\n    return {\n      uid: spec.uid,\n      dom: {\n        tag: 'div',\n        classes: [!hasGroups ? 'tox-view__header' : 'tox-view__toolbar'].concat(_toConsumableArray(isPhone || isTablet ? ['tox-view--mobile', 'tox-view--scrolling'] : []))\n      },\n      behaviours: derive$1([Focusing.config({}), Keying.config({\n        mode: 'flow',\n        selector: 'button, .tox-button',\n        focusInside: FocusInsideModes.OnEnterOrSpaceMode\n      })]),\n      components: hasGroups ? endButtons : [Container.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-view__header-start']\n        },\n        components: []\n      }), Container.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-view__header-end']\n        },\n        components: endButtons\n      })]\n    };\n  };\n  var renderViewPane = function renderViewPane(spec) {\n    return {\n      uid: spec.uid,\n      dom: {\n        tag: 'div',\n        classes: ['tox-view__pane']\n      }\n    };\n  };\n  var factory$8 = function factory$8(detail, components, _spec, _externals) {\n    var apis = {\n      getPane: function getPane(comp) {\n        return parts$a.getPart(comp, detail, 'pane');\n      },\n      getOnShow: function getOnShow(_comp) {\n        return detail.viewConfig.onShow;\n      },\n      getOnHide: function getOnHide(_comp) {\n        return detail.viewConfig.onHide;\n      }\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      apis: apis\n    };\n  };\n  var View = composite({\n    name: 'silver.View',\n    configFields: [required$1('viewConfig')],\n    partFields: [optional({\n      factory: {\n        sketch: renderViewHeader\n      },\n      schema: [required$1('buttons'), required$1('providers')],\n      name: 'header'\n    }), optional({\n      factory: {\n        sketch: renderViewPane\n      },\n      schema: [],\n      name: 'pane'\n    })],\n    factory: factory$8,\n    apis: {\n      getPane: function getPane(apis, comp) {\n        return apis.getPane(comp);\n      },\n      getOnShow: function getOnShow(apis, comp) {\n        return apis.getOnShow(comp);\n      },\n      getOnHide: function getOnHide(apis, comp) {\n        return apis.getOnHide(comp);\n      }\n    }\n  });\n  var makeViews = function makeViews(parts, viewConfigs, providers) {\n    return mapToArray(viewConfigs, function (config, name) {\n      var internalViewConfig = getOrDie(createView(config));\n      return parts.slot(name, View.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-view']\n        },\n        viewConfig: internalViewConfig,\n        components: [].concat(_toConsumableArray(internalViewConfig.buttons.length > 0 ? [View.parts.header({\n          buttons: internalViewConfig.buttons,\n          providers: providers\n        })] : []), [View.parts.pane({})])\n      }));\n    });\n  };\n  var makeSlotContainer = function makeSlotContainer(viewConfigs, providers) {\n    return SlotContainer.sketch(function (parts) {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-view-wrap__slot-container']\n        },\n        components: makeViews(parts, viewConfigs, providers),\n        slotBehaviours: SimpleBehaviours.unnamedEvents([runOnAttached(function (slotContainer) {\n          return SlotContainer.hideAllSlots(slotContainer);\n        })])\n      };\n    });\n  };\n  var getCurrentName = function getCurrentName(slotContainer) {\n    return find$5(SlotContainer.getSlotNames(slotContainer), function (name) {\n      return SlotContainer.isShowing(slotContainer, name);\n    });\n  };\n  var hideContainer = function hideContainer(comp) {\n    var element = comp.element;\n    set$8(element, 'display', 'none');\n    set$9(element, 'aria-hidden', 'true');\n  };\n  var showContainer = function showContainer(comp) {\n    var element = comp.element;\n    remove$6(element, 'display');\n    remove$7(element, 'aria-hidden');\n  };\n  var makeViewInstanceApi = function makeViewInstanceApi(slot) {\n    return {\n      getContainer: constant$1(slot)\n    };\n  };\n  var runOnPaneWithInstanceApi = function runOnPaneWithInstanceApi(slotContainer, name, get) {\n    SlotContainer.getSlot(slotContainer, name).each(function (view) {\n      View.getPane(view).each(function (pane) {\n        var onCallback = get(view);\n        onCallback(makeViewInstanceApi(pane.element.dom));\n      });\n    });\n  };\n  var runOnShow = function runOnShow(slotContainer, name) {\n    return runOnPaneWithInstanceApi(slotContainer, name, View.getOnShow);\n  };\n  var runOnHide = function runOnHide(slotContainer, name) {\n    return runOnPaneWithInstanceApi(slotContainer, name, View.getOnHide);\n  };\n  var factory$7 = function factory$7(detail, spec) {\n    var setViews = function setViews(comp, viewConfigs) {\n      Replacing.set(comp, [makeSlotContainer(viewConfigs, spec.backstage.shared.providers)]);\n    };\n    var whichView = function whichView(comp) {\n      return Composing.getCurrent(comp).bind(getCurrentName);\n    };\n    var toggleView = function toggleView(comp, showMainView, hideMainView, name) {\n      return Composing.getCurrent(comp).exists(function (slotContainer) {\n        var optCurrentSlotName = getCurrentName(slotContainer);\n        var isTogglingCurrentView = optCurrentSlotName.exists(function (current) {\n          return name === current;\n        });\n        var exists = SlotContainer.getSlot(slotContainer, name).isSome();\n        if (exists) {\n          SlotContainer.hideAllSlots(slotContainer);\n          if (!isTogglingCurrentView) {\n            hideMainView();\n            showContainer(comp);\n            SlotContainer.showSlot(slotContainer, name);\n            runOnShow(slotContainer, name);\n          } else {\n            hideContainer(comp);\n            showMainView();\n          }\n          optCurrentSlotName.each(function (prevName) {\n            return runOnHide(slotContainer, prevName);\n          });\n        }\n        return exists;\n      });\n    };\n    var apis = {\n      setViews: setViews,\n      whichView: whichView,\n      toggleView: toggleView\n    };\n    return {\n      uid: detail.uid,\n      dom: {\n        tag: 'div',\n        classes: ['tox-view-wrap'],\n        attributes: {\n          'aria-hidden': 'true'\n        },\n        styles: {\n          display: 'none'\n        }\n      },\n      components: [],\n      behaviours: derive$1([Replacing.config({}), Composing.config({\n        find: function find(comp) {\n          var children = Replacing.contents(comp);\n          return head(children);\n        }\n      })]),\n      apis: apis\n    };\n  };\n  var ViewWrapper = single({\n    factory: factory$7,\n    name: 'silver.ViewWrapper',\n    configFields: [required$1('backstage')],\n    apis: {\n      setViews: function setViews(apis, comp, views) {\n        return apis.setViews(comp, views);\n      },\n      toggleView: function toggleView(apis, comp, outerContainer, editorCont, name) {\n        return apis.toggleView(comp, outerContainer, editorCont, name);\n      },\n      whichView: function whichView(apis, comp) {\n        return apis.whichView(comp);\n      }\n    }\n  });\n  var factory$6 = function factory$6(detail, components, _spec) {\n    var toolbarDrawerOpenState = false;\n    var apis = {\n      getSocket: function getSocket(comp) {\n        return parts$a.getPart(comp, detail, 'socket');\n      },\n      setSidebar: function setSidebar(comp, panelConfigs, showSidebar) {\n        parts$a.getPart(comp, detail, 'sidebar').each(function (sidebar) {\n          return _setSidebar(sidebar, panelConfigs, showSidebar);\n        });\n      },\n      toggleSidebar: function toggleSidebar(comp, name) {\n        parts$a.getPart(comp, detail, 'sidebar').each(function (sidebar) {\n          return _toggleSidebar(sidebar, name);\n        });\n      },\n      whichSidebar: function whichSidebar(comp) {\n        return parts$a.getPart(comp, detail, 'sidebar').bind(_whichSidebar).getOrNull();\n      },\n      getHeader: function getHeader(comp) {\n        return parts$a.getPart(comp, detail, 'header');\n      },\n      getToolbar: function getToolbar(comp) {\n        return parts$a.getPart(comp, detail, 'toolbar');\n      },\n      setToolbar: function setToolbar(comp, groups) {\n        parts$a.getPart(comp, detail, 'toolbar').each(function (toolbar) {\n          var renderedGroups = map$2(groups, renderToolbarGroup);\n          toolbar.getApis().setGroups(toolbar, renderedGroups);\n        });\n      },\n      setToolbars: function setToolbars(comp, toolbars) {\n        parts$a.getPart(comp, detail, 'multiple-toolbar').each(function (mToolbar) {\n          var renderedToolbars = map$2(toolbars, function (g) {\n            return map$2(g, renderToolbarGroup);\n          });\n          CustomList.setItems(mToolbar, renderedToolbars);\n        });\n      },\n      refreshToolbar: function refreshToolbar(comp) {\n        var toolbar = parts$a.getPart(comp, detail, 'toolbar');\n        toolbar.each(function (toolbar) {\n          return toolbar.getApis().refresh(toolbar);\n        });\n      },\n      toggleToolbarDrawer: function toggleToolbarDrawer(comp) {\n        parts$a.getPart(comp, detail, 'toolbar').each(function (toolbar) {\n          mapFrom(toolbar.getApis().toggle, function (toggle) {\n            return toggle(toolbar);\n          });\n        });\n      },\n      toggleToolbarDrawerWithoutFocusing: function toggleToolbarDrawerWithoutFocusing(comp) {\n        parts$a.getPart(comp, detail, 'toolbar').each(function (toolbar) {\n          mapFrom(toolbar.getApis().toggleWithoutFocusing, function (toggleWithoutFocusing) {\n            return toggleWithoutFocusing(toolbar);\n          });\n        });\n      },\n      isToolbarDrawerToggled: function isToolbarDrawerToggled(comp) {\n        return parts$a.getPart(comp, detail, 'toolbar').bind(function (toolbar) {\n          return Optional.from(toolbar.getApis().isOpen).map(function (isOpen) {\n            return isOpen(toolbar);\n          });\n        }).getOr(false);\n      },\n      getThrobber: function getThrobber(comp) {\n        return parts$a.getPart(comp, detail, 'throbber');\n      },\n      focusToolbar: function focusToolbar(comp) {\n        var optToolbar = parts$a.getPart(comp, detail, 'toolbar').orThunk(function () {\n          return parts$a.getPart(comp, detail, 'multiple-toolbar');\n        });\n        optToolbar.each(function (toolbar) {\n          Keying.focusIn(toolbar);\n        });\n      },\n      setMenubar: function setMenubar(comp, menus) {\n        parts$a.getPart(comp, detail, 'menubar').each(function (menubar) {\n          SilverMenubar.setMenus(menubar, menus);\n        });\n      },\n      focusMenubar: function focusMenubar(comp) {\n        parts$a.getPart(comp, detail, 'menubar').each(function (menubar) {\n          SilverMenubar.focus(menubar);\n        });\n      },\n      setViews: function setViews(comp, viewConfigs) {\n        parts$a.getPart(comp, detail, 'viewWrapper').each(function (wrapper) {\n          ViewWrapper.setViews(wrapper, viewConfigs);\n        });\n      },\n      toggleView: function toggleView(comp, name) {\n        return parts$a.getPart(comp, detail, 'viewWrapper').exists(function (wrapper) {\n          return ViewWrapper.toggleView(wrapper, function () {\n            return apis.showMainView(comp);\n          }, function () {\n            return apis.hideMainView(comp);\n          }, name);\n        });\n      },\n      whichView: function whichView(comp) {\n        return parts$a.getPart(comp, detail, 'viewWrapper').bind(ViewWrapper.whichView).getOrNull();\n      },\n      hideMainView: function hideMainView(comp) {\n        toolbarDrawerOpenState = apis.isToolbarDrawerToggled(comp);\n        if (toolbarDrawerOpenState) {\n          apis.toggleToolbarDrawer(comp);\n        }\n        parts$a.getPart(comp, detail, 'editorContainer').each(function (editorContainer) {\n          var element = editorContainer.element;\n          set$8(element, 'display', 'none');\n          set$9(element, 'aria-hidden', 'true');\n        });\n      },\n      showMainView: function showMainView(comp) {\n        if (toolbarDrawerOpenState) {\n          apis.toggleToolbarDrawer(comp);\n        }\n        parts$a.getPart(comp, detail, 'editorContainer').each(function (editorContainer) {\n          var element = editorContainer.element;\n          remove$6(element, 'display');\n          remove$7(element, 'aria-hidden');\n        });\n      }\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      apis: apis,\n      behaviours: detail.behaviours\n    };\n  };\n  var partMenubar = partType.optional({\n    factory: SilverMenubar,\n    name: 'menubar',\n    schema: [required$1('backstage')]\n  });\n  var toolbarFactory = function toolbarFactory(spec) {\n    if (spec.type === ToolbarMode$1.sliding) {\n      return renderSlidingMoreToolbar;\n    } else if (spec.type === ToolbarMode$1.floating) {\n      return renderFloatingMoreToolbar;\n    } else {\n      return renderToolbar;\n    }\n  };\n  var partMultipleToolbar = partType.optional({\n    factory: {\n      sketch: function sketch(spec) {\n        return CustomList.sketch({\n          uid: spec.uid,\n          dom: spec.dom,\n          listBehaviours: derive$1([Keying.config({\n            mode: 'acyclic',\n            selector: '.tox-toolbar'\n          })]),\n          makeItem: function makeItem() {\n            return renderToolbar({\n              type: spec.type,\n              uid: generate$6('multiple-toolbar-item'),\n              cyclicKeying: false,\n              initGroups: [],\n              providers: spec.providers,\n              onEscape: function onEscape() {\n                spec.onEscape();\n                return Optional.some(true);\n              }\n            });\n          },\n          setupItem: function setupItem(_mToolbar, tc, data, _index) {\n            Toolbar.setGroups(tc, data);\n          },\n          shell: true\n        });\n      }\n    },\n    name: 'multiple-toolbar',\n    schema: [required$1('dom'), required$1('onEscape')]\n  });\n  var partToolbar = partType.optional({\n    factory: {\n      sketch: function sketch(spec) {\n        var renderer = toolbarFactory(spec);\n        var toolbarSpec = {\n          type: spec.type,\n          uid: spec.uid,\n          onEscape: function onEscape() {\n            spec.onEscape();\n            return Optional.some(true);\n          },\n          onToggled: function onToggled(_comp, state) {\n            return spec.onToolbarToggled(state);\n          },\n          cyclicKeying: false,\n          initGroups: [],\n          getSink: spec.getSink,\n          providers: spec.providers,\n          moreDrawerData: {\n            lazyToolbar: spec.lazyToolbar,\n            lazyMoreButton: spec.lazyMoreButton,\n            lazyHeader: spec.lazyHeader\n          },\n          attributes: spec.attributes\n        };\n        return renderer(toolbarSpec);\n      }\n    },\n    name: 'toolbar',\n    schema: [required$1('dom'), required$1('onEscape'), required$1('getSink')]\n  });\n  var partHeader = partType.optional({\n    factory: {\n      sketch: renderHeader\n    },\n    name: 'header',\n    schema: [required$1('dom')]\n  });\n  var partPromotion = partType.optional({\n    factory: {\n      sketch: renderPromotion\n    },\n    name: 'promotion',\n    schema: [required$1('dom')]\n  });\n  var partSocket = partType.optional({\n    name: 'socket',\n    schema: [required$1('dom')]\n  });\n  var partSidebar = partType.optional({\n    factory: {\n      sketch: renderSidebar\n    },\n    name: 'sidebar',\n    schema: [required$1('dom')]\n  });\n  var partThrobber = partType.optional({\n    factory: {\n      sketch: renderThrobber\n    },\n    name: 'throbber',\n    schema: [required$1('dom')]\n  });\n  var partViewWrapper = partType.optional({\n    factory: ViewWrapper,\n    name: 'viewWrapper',\n    schema: [required$1('backstage')]\n  });\n  var renderEditorContainer = function renderEditorContainer(spec) {\n    return {\n      uid: spec.uid,\n      dom: {\n        tag: 'div',\n        classes: ['tox-editor-container']\n      },\n      components: spec.components\n    };\n  };\n  var partEditorContainer = partType.optional({\n    factory: {\n      sketch: renderEditorContainer\n    },\n    name: 'editorContainer',\n    schema: []\n  });\n  var OuterContainer = composite({\n    name: 'OuterContainer',\n    factory: factory$6,\n    configFields: [required$1('dom'), required$1('behaviours')],\n    partFields: [partHeader, partMenubar, partToolbar, partMultipleToolbar, partSocket, partSidebar, partPromotion, partThrobber, partViewWrapper, partEditorContainer],\n    apis: {\n      getSocket: function getSocket(apis, comp) {\n        return apis.getSocket(comp);\n      },\n      setSidebar: function setSidebar(apis, comp, panelConfigs, showSidebar) {\n        apis.setSidebar(comp, panelConfigs, showSidebar);\n      },\n      toggleSidebar: function toggleSidebar(apis, comp, name) {\n        apis.toggleSidebar(comp, name);\n      },\n      whichSidebar: function whichSidebar(apis, comp) {\n        return apis.whichSidebar(comp);\n      },\n      getHeader: function getHeader(apis, comp) {\n        return apis.getHeader(comp);\n      },\n      getToolbar: function getToolbar(apis, comp) {\n        return apis.getToolbar(comp);\n      },\n      setToolbar: function setToolbar(apis, comp, groups) {\n        apis.setToolbar(comp, groups);\n      },\n      setToolbars: function setToolbars(apis, comp, toolbars) {\n        apis.setToolbars(comp, toolbars);\n      },\n      refreshToolbar: function refreshToolbar(apis, comp) {\n        return apis.refreshToolbar(comp);\n      },\n      toggleToolbarDrawer: function toggleToolbarDrawer(apis, comp) {\n        apis.toggleToolbarDrawer(comp);\n      },\n      toggleToolbarDrawerWithoutFocusing: function toggleToolbarDrawerWithoutFocusing(apis, comp) {\n        apis.toggleToolbarDrawerWithoutFocusing(comp);\n      },\n      isToolbarDrawerToggled: function isToolbarDrawerToggled(apis, comp) {\n        return apis.isToolbarDrawerToggled(comp);\n      },\n      getThrobber: function getThrobber(apis, comp) {\n        return apis.getThrobber(comp);\n      },\n      setMenubar: function setMenubar(apis, comp, menus) {\n        apis.setMenubar(comp, menus);\n      },\n      focusMenubar: function focusMenubar(apis, comp) {\n        apis.focusMenubar(comp);\n      },\n      focusToolbar: function focusToolbar(apis, comp) {\n        apis.focusToolbar(comp);\n      },\n      setViews: function setViews(apis, comp, views) {\n        apis.setViews(comp, views);\n      },\n      toggleView: function toggleView(apis, comp, name) {\n        return apis.toggleView(comp, name);\n      },\n      whichView: function whichView(apis, comp) {\n        return apis.whichView(comp);\n      }\n    }\n  });\n  var defaultMenubar = 'file edit view insert format tools table help';\n  var defaultMenus = {\n    file: {\n      title: 'File',\n      items: 'newdocument restoredraft | preview | export print | deleteallconversations'\n    },\n    edit: {\n      title: 'Edit',\n      items: 'undo redo | cut copy paste pastetext | selectall | searchreplace'\n    },\n    view: {\n      title: 'View',\n      items: 'code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments'\n    },\n    insert: {\n      title: 'Insert',\n      items: 'image link media addcomment pageembed template inserttemplate codesample inserttable accordion | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime'\n    },\n    format: {\n      title: 'Format',\n      items: 'bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat'\n    },\n    tools: {\n      title: 'Tools',\n      items: 'aidialog aishortcuts | spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code typography wordcount addtemplate'\n    },\n    table: {\n      title: 'Table',\n      items: 'inserttable | cell row column | advtablesort | tableprops deletetable'\n    },\n    help: {\n      title: 'Help',\n      items: 'help'\n    }\n  };\n  var make = function make(menu, registry, editor) {\n    var removedMenuItems = getRemovedMenuItems(editor).split(/[ ,]/);\n    return {\n      text: menu.title,\n      getItems: function getItems() {\n        return bind$3(menu.items, function (i) {\n          var itemName = i.toLowerCase();\n          if (itemName.trim().length === 0) {\n            return [];\n          } else if (exists(removedMenuItems, function (removedMenuItem) {\n            return removedMenuItem === itemName;\n          })) {\n            return [];\n          } else if (itemName === 'separator' || itemName === '|') {\n            return [{\n              type: 'separator'\n            }];\n          } else if (registry.menuItems[itemName]) {\n            return [registry.menuItems[itemName]];\n          } else {\n            return [];\n          }\n        });\n      }\n    };\n  };\n  var parseItemsString = function parseItemsString(items) {\n    return items.split(' ');\n  };\n  var identifyMenus = function identifyMenus(editor, registry) {\n    var rawMenuData = _objectSpread({}, defaultMenus, registry.menus);\n    var userDefinedMenus = keys(registry.menus).length > 0;\n    var menubar = registry.menubar === undefined || registry.menubar === true ? parseItemsString(defaultMenubar) : parseItemsString(registry.menubar === false ? '' : registry.menubar);\n    var validMenus = filter$2(menubar, function (menuName) {\n      var isDefaultMenu = has$2(defaultMenus, menuName);\n      if (userDefinedMenus) {\n        return isDefaultMenu || get$g(registry.menus, menuName).exists(function (menu) {\n          return has$2(menu, 'items');\n        });\n      } else {\n        return isDefaultMenu;\n      }\n    });\n    var menus = map$2(validMenus, function (menuName) {\n      var menuData = rawMenuData[menuName];\n      return make({\n        title: menuData.title,\n        items: parseItemsString(menuData.items)\n      }, registry, editor);\n    });\n    return filter$2(menus, function (menu) {\n      var isNotSeparator = function isNotSeparator(item) {\n        return isString(item) || item.type !== 'separator';\n      };\n      return menu.getItems().length > 0 && exists(menu.getItems(), isNotSeparator);\n    });\n  };\n  var fireSkinLoaded = function fireSkinLoaded(editor) {\n    var done = function done() {\n      editor._skinLoaded = true;\n      fireSkinLoaded$1(editor);\n    };\n    return function () {\n      if (editor.initialized) {\n        done();\n      } else {\n        editor.on('init', done);\n      }\n    };\n  };\n  var fireSkinLoadError = function fireSkinLoadError(editor, err) {\n    return function () {\n      return fireSkinLoadError$1(editor, {\n        message: err\n      });\n    };\n  };\n  var loadStylesheet = function loadStylesheet(editor, stylesheetUrl, styleSheetLoader) {\n    editor.on('remove', function () {\n      return styleSheetLoader.unload(stylesheetUrl);\n    });\n    return styleSheetLoader.load(stylesheetUrl);\n  };\n  var loadRawCss = function loadRawCss(editor, key, css, styleSheetLoader) {\n    editor.on('remove', function () {\n      return styleSheetLoader.unloadRawCss(key);\n    });\n    return styleSheetLoader.loadRawCss(key, css);\n  };\n  var loadUiSkins = /*#__PURE__*/function () {\n    var _ref20 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(editor, skinUrl) {\n      var skinUrl_, skinUiCss, css, _skinUiCss;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            skinUrl_ = getSkinUrlOption(editor).getOr('default');\n            skinUiCss = 'ui/' + skinUrl_ + '/skin.css';\n            css = tinymce.Resource.get(skinUiCss);\n            if (!isString(css)) {\n              _context.next = 7;\n              break;\n            }\n            return _context.abrupt(\"return\", Promise.resolve(loadRawCss(editor, skinUiCss, css, editor.ui.styleSheetLoader)));\n          case 7:\n            _skinUiCss = skinUrl + '/skin.min.css';\n            return _context.abrupt(\"return\", loadStylesheet(editor, _skinUiCss, editor.ui.styleSheetLoader));\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function loadUiSkins(_x, _x2) {\n      return _ref20.apply(this, arguments);\n    };\n  }();\n  var loadShadowDomUiSkins = /*#__PURE__*/function () {\n    var _ref21 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(editor, skinUrl) {\n      var isInShadowRoot$1, shadowDomSkinCss, css, _shadowDomSkinCss;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            isInShadowRoot$1 = isInShadowRoot(SugarElement.fromDom(editor.getElement()));\n            if (!isInShadowRoot$1) {\n              _context2.next = 11;\n              break;\n            }\n            shadowDomSkinCss = skinUrl + '/skin.shadowdom.css';\n            css = tinymce.Resource.get(shadowDomSkinCss);\n            if (!isString(css)) {\n              _context2.next = 9;\n              break;\n            }\n            loadRawCss(editor, shadowDomSkinCss, css, global$7.DOM.styleSheetLoader);\n            return _context2.abrupt(\"return\", Promise.resolve());\n          case 9:\n            _shadowDomSkinCss = skinUrl + '/skin.shadowdom.min.css';\n            return _context2.abrupt(\"return\", loadStylesheet(editor, _shadowDomSkinCss, global$7.DOM.styleSheetLoader));\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return function loadShadowDomUiSkins(_x3, _x4) {\n      return _ref21.apply(this, arguments);\n    };\n  }();\n  var loadUrlSkin = /*#__PURE__*/function () {\n    var _ref22 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(isInline, editor) {\n      var skinUrl;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            getSkinUrlOption(editor).fold(function () {\n              var skinUrl_ = getSkinUrl(editor);\n              if (skinUrl_) {\n                editor.contentCSS.push(skinUrl_ + (isInline ? '/content.inline' : '/content') + '.min.css');\n              }\n            }, function (skinUrl) {\n              var skinContentCss = 'ui/' + skinUrl + (isInline ? '/content.inline' : '/content') + '.css';\n              var css = tinymce.Resource.get(skinContentCss);\n              if (isString(css)) {\n                loadRawCss(editor, skinContentCss, css, editor.ui.styleSheetLoader);\n              } else {\n                var skinUrl_ = getSkinUrl(editor);\n                if (skinUrl_) {\n                  editor.contentCSS.push(skinUrl_ + (isInline ? '/content.inline' : '/content') + '.min.css');\n                }\n              }\n            });\n            skinUrl = getSkinUrl(editor);\n            if (!(!isSkinDisabled(editor) && isString(skinUrl))) {\n              _context3.next = 4;\n              break;\n            }\n            return _context3.abrupt(\"return\", Promise.all([loadUiSkins(editor, skinUrl), loadShadowDomUiSkins(editor, skinUrl)]).then());\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n    return function loadUrlSkin(_x5, _x6) {\n      return _ref22.apply(this, arguments);\n    };\n  }();\n  var loadSkin = function loadSkin(isInline, editor) {\n    return loadUrlSkin(isInline, editor).then(fireSkinLoaded(editor), fireSkinLoadError(editor, 'Skin could not be loaded'));\n  };\n  var iframe = curry(loadSkin, false);\n  var inline = curry(loadSkin, true);\n  var getTooltipText = function getTooltipText(editor, prefix, value) {\n    return editor.translate([\"\".concat(prefix, \" {0}\"), editor.translate(value)]);\n  };\n  var generateSelectItems = function generateSelectItems(_editor, backstage, spec) {\n    var generateItem = function generateItem(rawItem, response, invalid, value) {\n      var translatedText = backstage.shared.providers.translate(rawItem.title);\n      if (rawItem.type === 'separator') {\n        return Optional.some({\n          type: 'separator',\n          text: translatedText\n        });\n      } else if (rawItem.type === 'submenu') {\n        var items = bind$3(rawItem.getStyleItems(), function (si) {\n          return validate(si, response, value);\n        });\n        if (response === 0 && items.length <= 0) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            type: 'nestedmenuitem',\n            text: translatedText,\n            enabled: items.length > 0,\n            getSubmenuItems: function getSubmenuItems() {\n              return bind$3(rawItem.getStyleItems(), function (si) {\n                return validate(si, response, value);\n              });\n            }\n          });\n        }\n      } else {\n        return Optional.some(_objectSpread({\n          type: 'togglemenuitem',\n          text: translatedText,\n          icon: rawItem.icon,\n          active: rawItem.isSelected(value),\n          enabled: !invalid,\n          onAction: spec.onAction(rawItem)\n        }, rawItem.getStylePreview().fold(function () {\n          return {};\n        }, function (preview) {\n          return {\n            meta: {\n              style: preview\n            }\n          };\n        })));\n      }\n    };\n    var validate = function validate(item, response, value) {\n      var invalid = item.type === 'formatter' && spec.isInvalid(item);\n      if (response === 0) {\n        return invalid ? [] : generateItem(item, response, false, value).toArray();\n      } else {\n        return generateItem(item, response, invalid, value).toArray();\n      }\n    };\n    var validateItems = function validateItems(preItems) {\n      var value = spec.getCurrentValue();\n      var response = spec.shouldHide ? 0 : 1;\n      return bind$3(preItems, function (item) {\n        return validate(item, response, value);\n      });\n    };\n    var getFetch = function getFetch(backstage, getStyleItems) {\n      return function (comp, callback) {\n        var preItems = getStyleItems();\n        var items = validateItems(preItems);\n        var menu = build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {\n          isHorizontalMenu: false,\n          search: Optional.none()\n        });\n        callback(menu);\n      };\n    };\n    return {\n      validateItems: validateItems,\n      getFetch: getFetch\n    };\n  };\n  var createMenuItems = function createMenuItems(editor, backstage, spec) {\n    var dataset = spec.dataset;\n    var getStyleItems = dataset.type === 'basic' ? function () {\n      return map$2(dataset.data, function (d) {\n        return processBasic(d, spec.isSelectedFor, spec.getPreviewFor);\n      });\n    } : dataset.getData;\n    return {\n      items: generateSelectItems(editor, backstage, spec),\n      getStyleItems: getStyleItems\n    };\n  };\n  var createSelectButton = function createSelectButton(editor, backstage, spec, title, textUpdateEventName) {\n    var _createMenuItems = createMenuItems(editor, backstage, spec),\n      items = _createMenuItems.items,\n      getStyleItems = _createMenuItems.getStyleItems;\n    var getApi = function getApi(comp) {\n      return {\n        getComponent: constant$1(comp),\n        setTooltip: function setTooltip(tooltip) {\n          var translatedTooltip = backstage.shared.providers.translate(tooltip);\n          setAll$1(comp.element, {\n            'aria-label': translatedTooltip,\n            'title': translatedTooltip\n          });\n        }\n      };\n    };\n    var onSetup = function onSetup(api) {\n      var handler = function handler(e) {\n        return api.setTooltip(getTooltipText(editor, title, e.value));\n      };\n      editor.on(textUpdateEventName, handler);\n      return composeUnbinders(onSetupEvent(editor, 'NodeChange', function (api) {\n        var comp = api.getComponent();\n        spec.updateText(comp);\n        Disabling.set(api.getComponent(), !editor.selection.isEditable());\n      })(api), function () {\n        return editor.off(textUpdateEventName, handler);\n      });\n    };\n    return renderCommonDropdown({\n      text: spec.icon.isSome() ? Optional.none() : spec.text,\n      icon: spec.icon,\n      tooltip: Optional.from(spec.tooltip),\n      role: Optional.none(),\n      fetch: items.getFetch(backstage, getStyleItems),\n      onSetup: onSetup,\n      getApi: getApi,\n      columns: 1,\n      presets: 'normal',\n      classes: spec.icon.isSome() ? [] : ['bespoke'],\n      dropdownBehaviours: []\n    }, 'tox-tbtn', backstage.shared);\n  };\n  var process = function process(rawFormats) {\n    return map$2(rawFormats, function (item) {\n      var title = item,\n        format = item;\n      var values = item.split('=');\n      if (values.length > 1) {\n        title = values[0];\n        format = values[1];\n      }\n      return {\n        title: title,\n        format: format\n      };\n    });\n  };\n  var buildBasicStaticDataset = function buildBasicStaticDataset(data) {\n    return {\n      type: 'basic',\n      data: data\n    };\n  };\n  var Delimiter;\n  (function (Delimiter) {\n    Delimiter[Delimiter['SemiColon'] = 0] = 'SemiColon';\n    Delimiter[Delimiter['Space'] = 1] = 'Space';\n  })(Delimiter || (Delimiter = {}));\n  var split = function split(rawFormats, delimiter) {\n    if (delimiter === Delimiter.SemiColon) {\n      return rawFormats.replace(/;$/, '').split(';');\n    } else {\n      return rawFormats.split(' ');\n    }\n  };\n  var buildBasicSettingsDataset = function buildBasicSettingsDataset(editor, settingName, delimiter) {\n    var rawFormats = editor.options.get(settingName);\n    var data = process(split(rawFormats, delimiter));\n    return {\n      type: 'basic',\n      data: data\n    };\n  };\n  var title$4 = 'Align';\n  var fallbackAlignment = 'left';\n  var alignMenuItems = [{\n    title: 'Left',\n    icon: 'align-left',\n    format: 'alignleft',\n    command: 'JustifyLeft'\n  }, {\n    title: 'Center',\n    icon: 'align-center',\n    format: 'aligncenter',\n    command: 'JustifyCenter'\n  }, {\n    title: 'Right',\n    icon: 'align-right',\n    format: 'alignright',\n    command: 'JustifyRight'\n  }, {\n    title: 'Justify',\n    icon: 'align-justify',\n    format: 'alignjustify',\n    command: 'JustifyFull'\n  }];\n  var getSpec$4 = function getSpec$4(editor) {\n    var getMatchingValue = function getMatchingValue() {\n      return find$5(alignMenuItems, function (item) {\n        return editor.formatter.match(item.format);\n      });\n    };\n    var isSelectedFor = function isSelectedFor(format) {\n      return function () {\n        return editor.formatter.match(format);\n      };\n    };\n    var getPreviewFor = function getPreviewFor(_format) {\n      return Optional.none;\n    };\n    var updateSelectMenuIcon = function updateSelectMenuIcon(comp) {\n      var match = getMatchingValue();\n      var alignment = match.fold(constant$1(fallbackAlignment), function (item) {\n        return item.title.toLowerCase();\n      });\n      emitWith(comp, updateMenuIcon, {\n        icon: \"align-\".concat(alignment)\n      });\n      fireAlignTextUpdate(editor, {\n        value: alignment\n      });\n    };\n    var dataset = buildBasicStaticDataset(alignMenuItems);\n    var onAction = function onAction(rawItem) {\n      return function () {\n        return find$5(alignMenuItems, function (item) {\n          return item.format === rawItem.format;\n        }).each(function (item) {\n          return editor.execCommand(item.command);\n        });\n      };\n    };\n    return {\n      tooltip: getTooltipText(editor, title$4, fallbackAlignment),\n      text: Optional.none(),\n      icon: Optional.some('align-left'),\n      isSelectedFor: isSelectedFor,\n      getCurrentValue: Optional.none,\n      getPreviewFor: getPreviewFor,\n      onAction: onAction,\n      updateText: updateSelectMenuIcon,\n      dataset: dataset,\n      shouldHide: false,\n      isInvalid: function isInvalid(item) {\n        return !editor.formatter.canApply(item.format);\n      }\n    };\n  };\n  var createAlignButton = function createAlignButton(editor, backstage) {\n    return createSelectButton(editor, backstage, getSpec$4(editor), title$4, 'AlignTextUpdate');\n  };\n  var createAlignMenu = function createAlignMenu(editor, backstage) {\n    var menuItems = createMenuItems(editor, backstage, getSpec$4(editor));\n    editor.ui.registry.addNestedMenuItem('align', {\n      text: backstage.shared.providers.translate(title$4),\n      onSetup: onSetupEditableToggle(editor),\n      getSubmenuItems: function getSubmenuItems() {\n        return menuItems.items.validateItems(menuItems.getStyleItems());\n      }\n    });\n  };\n  var findNearest = function findNearest(editor, getStyles) {\n    var styles = getStyles();\n    var formats = map$2(styles, function (style) {\n      return style.format;\n    });\n    return Optional.from(editor.formatter.closest(formats)).bind(function (fmt) {\n      return find$5(styles, function (data) {\n        return data.format === fmt;\n      });\n    }).orThunk(function () {\n      return someIf(editor.formatter.match('p'), {\n        title: 'Paragraph',\n        format: 'p'\n      });\n    });\n  };\n  var title$3 = 'Blocks';\n  var fallbackFormat = 'Paragraph';\n  var getSpec$3 = function getSpec$3(editor) {\n    var isSelectedFor = function isSelectedFor(format) {\n      return function () {\n        return editor.formatter.match(format);\n      };\n    };\n    var getPreviewFor = function getPreviewFor(format) {\n      return function () {\n        var fmt = editor.formatter.get(format);\n        if (fmt) {\n          return Optional.some({\n            tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',\n            styles: editor.dom.parseStyle(editor.formatter.getCssText(format))\n          });\n        } else {\n          return Optional.none();\n        }\n      };\n    };\n    var updateSelectMenuText = function updateSelectMenuText(comp) {\n      var detectedFormat = findNearest(editor, function () {\n        return dataset.data;\n      });\n      var text = detectedFormat.fold(constant$1(fallbackFormat), function (fmt) {\n        return fmt.title;\n      });\n      emitWith(comp, updateMenuText, {\n        text: text\n      });\n      fireBlocksTextUpdate(editor, {\n        value: text\n      });\n    };\n    var dataset = buildBasicSettingsDataset(editor, 'block_formats', Delimiter.SemiColon);\n    return {\n      tooltip: getTooltipText(editor, title$3, fallbackFormat),\n      text: Optional.some(fallbackFormat),\n      icon: Optional.none(),\n      isSelectedFor: isSelectedFor,\n      getCurrentValue: Optional.none,\n      getPreviewFor: getPreviewFor,\n      onAction: onActionToggleFormat$1(editor),\n      updateText: updateSelectMenuText,\n      dataset: dataset,\n      shouldHide: false,\n      isInvalid: function isInvalid(item) {\n        return !editor.formatter.canApply(item.format);\n      }\n    };\n  };\n  var createBlocksButton = function createBlocksButton(editor, backstage) {\n    return createSelectButton(editor, backstage, getSpec$3(editor), title$3, 'BlocksTextUpdate');\n  };\n  var createBlocksMenu = function createBlocksMenu(editor, backstage) {\n    var menuItems = createMenuItems(editor, backstage, getSpec$3(editor));\n    editor.ui.registry.addNestedMenuItem('blocks', {\n      text: title$3,\n      onSetup: onSetupEditableToggle(editor),\n      getSubmenuItems: function getSubmenuItems() {\n        return menuItems.items.validateItems(menuItems.getStyleItems());\n      }\n    });\n  };\n  var title$2 = 'Fonts';\n  var systemFont = 'System Font';\n  var systemStackFonts = ['-apple-system', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'sans-serif'];\n  var splitFonts = function splitFonts(fontFamily) {\n    var fonts = fontFamily.split(/\\s*,\\s*/);\n    return map$2(fonts, function (font) {\n      return font.replace(/^['\"]+|['\"]+$/g, '');\n    });\n  };\n  var matchesStack = function matchesStack(fonts, stack) {\n    return stack.length > 0 && forall(stack, function (font) {\n      return fonts.indexOf(font.toLowerCase()) > -1;\n    });\n  };\n  var isSystemFontStack = function isSystemFontStack(fontFamily, userStack) {\n    if (fontFamily.indexOf('-apple-system') === 0 || userStack.length > 0) {\n      var fonts = splitFonts(fontFamily.toLowerCase());\n      return matchesStack(fonts, systemStackFonts) || matchesStack(fonts, userStack);\n    } else {\n      return false;\n    }\n  };\n  var getSpec$2 = function getSpec$2(editor) {\n    var getMatchingValue = function getMatchingValue() {\n      var getFirstFont = function getFirstFont(fontFamily) {\n        return fontFamily ? splitFonts(fontFamily)[0] : '';\n      };\n      var fontFamily = editor.queryCommandValue('FontName');\n      var items = dataset.data;\n      var font = fontFamily ? fontFamily.toLowerCase() : '';\n      var userStack = getDefaultFontStack(editor);\n      var matchOpt = find$5(items, function (item) {\n        var format = item.format;\n        return format.toLowerCase() === font || getFirstFont(format).toLowerCase() === getFirstFont(font).toLowerCase();\n      }).orThunk(function () {\n        return someIf(isSystemFontStack(font, userStack), {\n          title: systemFont,\n          format: font\n        });\n      });\n      return {\n        matchOpt: matchOpt,\n        font: fontFamily\n      };\n    };\n    var isSelectedFor = function isSelectedFor(item) {\n      return function (valueOpt) {\n        return valueOpt.exists(function (value) {\n          return value.format === item;\n        });\n      };\n    };\n    var getCurrentValue = function getCurrentValue() {\n      var _getMatchingValue = getMatchingValue(),\n        matchOpt = _getMatchingValue.matchOpt;\n      return matchOpt;\n    };\n    var getPreviewFor = function getPreviewFor(item) {\n      return function () {\n        return Optional.some({\n          tag: 'div',\n          styles: item.indexOf('dings') === -1 ? {\n            'font-family': item\n          } : {}\n        });\n      };\n    };\n    var onAction = function onAction(rawItem) {\n      return function () {\n        editor.undoManager.transact(function () {\n          editor.focus();\n          editor.execCommand('FontName', false, rawItem.format);\n        });\n      };\n    };\n    var updateSelectMenuText = function updateSelectMenuText(comp) {\n      var _getMatchingValue2 = getMatchingValue(),\n        matchOpt = _getMatchingValue2.matchOpt,\n        font = _getMatchingValue2.font;\n      var text = matchOpt.fold(constant$1(font), function (item) {\n        return item.title;\n      });\n      emitWith(comp, updateMenuText, {\n        text: text\n      });\n      fireFontFamilyTextUpdate(editor, {\n        value: text\n      });\n    };\n    var dataset = buildBasicSettingsDataset(editor, 'font_family_formats', Delimiter.SemiColon);\n    return {\n      tooltip: getTooltipText(editor, title$2, systemFont),\n      text: Optional.some(systemFont),\n      icon: Optional.none(),\n      isSelectedFor: isSelectedFor,\n      getCurrentValue: getCurrentValue,\n      getPreviewFor: getPreviewFor,\n      onAction: onAction,\n      updateText: updateSelectMenuText,\n      dataset: dataset,\n      shouldHide: false,\n      isInvalid: never\n    };\n  };\n  var createFontFamilyButton = function createFontFamilyButton(editor, backstage) {\n    return createSelectButton(editor, backstage, getSpec$2(editor), title$2, 'FontFamilyTextUpdate');\n  };\n  var createFontFamilyMenu = function createFontFamilyMenu(editor, backstage) {\n    var menuItems = createMenuItems(editor, backstage, getSpec$2(editor));\n    editor.ui.registry.addNestedMenuItem('fontfamily', {\n      text: backstage.shared.providers.translate(title$2),\n      onSetup: onSetupEditableToggle(editor),\n      getSubmenuItems: function getSubmenuItems() {\n        return menuItems.items.validateItems(menuItems.getStyleItems());\n      }\n    });\n  };\n  var units = {\n    unsupportedLength: ['em', 'ex', 'cap', 'ch', 'ic', 'rem', 'lh', 'rlh', 'vw', 'vh', 'vi', 'vb', 'vmin', 'vmax', 'cm', 'mm', 'Q', 'in', 'pc', 'pt', 'px'],\n    fixed: ['px', 'pt'],\n    relative: ['%'],\n    empty: ['']\n  };\n  var pattern = function () {\n    var decimalDigits = '[0-9]+';\n    var signedInteger = '[+-]?' + decimalDigits;\n    var exponentPart = '[eE]' + signedInteger;\n    var dot = '\\\\.';\n    var opt = function opt(input) {\n      return \"(?:\".concat(input, \")?\");\n    };\n    var unsignedDecimalLiteral = ['Infinity', decimalDigits + dot + opt(decimalDigits) + opt(exponentPart), dot + decimalDigits + opt(exponentPart), decimalDigits + opt(exponentPart)].join('|');\n    var float = \"[+-]?(?:\".concat(unsignedDecimalLiteral, \")\");\n    return new RegExp(\"^(\".concat(float, \")(.*)$\"));\n  }();\n  var isUnit = function isUnit(unit, accepted) {\n    return exists(accepted, function (acc) {\n      return exists(units[acc], function (check) {\n        return unit === check;\n      });\n    });\n  };\n  var parse = function parse(input, accepted) {\n    var match = Optional.from(pattern.exec(input));\n    return match.bind(function (array) {\n      var value = Number(array[1]);\n      var unitRaw = array[2];\n      if (isUnit(unitRaw, accepted)) {\n        return Optional.some({\n          value: value,\n          unit: unitRaw\n        });\n      } else {\n        return Optional.none();\n      }\n    });\n  };\n  var normalise = function normalise(input, accepted) {\n    return parse(input, accepted).map(function (_ref23) {\n      var value = _ref23.value,\n        unit = _ref23.unit;\n      return value + unit;\n    });\n  };\n  var Keys = {\n    tab: constant$1(9),\n    escape: constant$1(27),\n    enter: constant$1(13),\n    backspace: constant$1(8),\n    delete: constant$1(46),\n    left: constant$1(37),\n    up: constant$1(38),\n    right: constant$1(39),\n    down: constant$1(40),\n    space: constant$1(32),\n    home: constant$1(36),\n    end: constant$1(35),\n    pageUp: constant$1(33),\n    pageDown: constant$1(34)\n  };\n  var createBespokeNumberInput = function createBespokeNumberInput(editor, backstage, spec) {\n    var currentComp = Optional.none();\n    var getValueFromCurrentComp = function getValueFromCurrentComp(comp) {\n      return comp.map(function (alloyComp) {\n        return Representing.getValue(alloyComp);\n      }).getOr('');\n    };\n    var onSetup = onSetupEvent(editor, 'NodeChange SwitchMode', function (api) {\n      var comp = api.getComponent();\n      currentComp = Optional.some(comp);\n      spec.updateInputValue(comp);\n      Disabling.set(comp, !editor.selection.isEditable());\n    });\n    var getApi = function getApi(comp) {\n      return {\n        getComponent: constant$1(comp)\n      };\n    };\n    var editorOffCell = Cell(noop);\n    var customEvents = generate$6('custom-number-input-events');\n    var changeValue = function changeValue(f, fromInput, focusBack) {\n      var text = getValueFromCurrentComp(currentComp);\n      var newValue = spec.getNewValue(text, f);\n      var lenghtDelta = text.length - \"\".concat(newValue).length;\n      var oldStart = currentComp.map(function (comp) {\n        return comp.element.dom.selectionStart - lenghtDelta;\n      });\n      var oldEnd = currentComp.map(function (comp) {\n        return comp.element.dom.selectionEnd - lenghtDelta;\n      });\n      spec.onAction(newValue, focusBack);\n      currentComp.each(function (comp) {\n        Representing.setValue(comp, newValue);\n        if (fromInput) {\n          oldStart.each(function (oldStart) {\n            return comp.element.dom.selectionStart = oldStart;\n          });\n          oldEnd.each(function (oldEnd) {\n            return comp.element.dom.selectionEnd = oldEnd;\n          });\n        }\n      });\n    };\n    var decrease = function decrease(fromInput, focusBack) {\n      return changeValue(function (n, s) {\n        return n - s;\n      }, fromInput, focusBack);\n    };\n    var increase = function increase(fromInput, focusBack) {\n      return changeValue(function (n, s) {\n        return n + s;\n      }, fromInput, focusBack);\n    };\n    var goToParent = function goToParent(comp) {\n      return parentElement(comp.element).fold(Optional.none, function (parent) {\n        focus$3(parent);\n        return Optional.some(true);\n      });\n    };\n    var focusInput = function focusInput(comp) {\n      if (hasFocus(comp.element)) {\n        firstChild(comp.element).each(function (input) {\n          return focus$3(input);\n        });\n        return Optional.some(true);\n      } else {\n        return Optional.none();\n      }\n    };\n    var makeStepperButton = function makeStepperButton(action, title, tooltip, classes) {\n      var _eventOrder5;\n      var editorOffCellStepButton = Cell(noop);\n      var translatedTooltip = backstage.shared.providers.translate(tooltip);\n      var altExecuting = generate$6('altExecuting');\n      var onSetup = onSetupEvent(editor, 'NodeChange SwitchMode', function (api) {\n        Disabling.set(api.getComponent(), !editor.selection.isEditable());\n      });\n      var onClick = function onClick(comp) {\n        if (!Disabling.isDisabled(comp)) {\n          action(true);\n        }\n      };\n      return Button.sketch({\n        dom: {\n          tag: 'button',\n          attributes: {\n            'title': translatedTooltip,\n            'aria-label': translatedTooltip\n          },\n          classes: classes.concat(title)\n        },\n        components: [renderIconFromPack$1(title, backstage.shared.providers.icons)],\n        buttonBehaviours: derive$1([Disabling.config({}), config(altExecuting, [onControlAttached({\n          onSetup: onSetup,\n          getApi: getApi\n        }, editorOffCellStepButton), onControlDetached({\n          getApi: getApi\n        }, editorOffCellStepButton), run$1(keydown(), function (comp, se) {\n          if (se.event.raw.keyCode === Keys.space() || se.event.raw.keyCode === Keys.enter()) {\n            if (!Disabling.isDisabled(comp)) {\n              action(false);\n            }\n          }\n        }), run$1(click(), onClick), run$1(touchend(), onClick)])]),\n        eventOrder: (_eventOrder5 = {}, _defineProperty(_eventOrder5, keydown(), [altExecuting, 'keying']), _defineProperty(_eventOrder5, click(), [altExecuting, 'alloy.base.behaviour']), _defineProperty(_eventOrder5, touchend(), [altExecuting, 'alloy.base.behaviour']), _eventOrder5)\n      });\n    };\n    var memMinus = record(makeStepperButton(function (focusBack) {\n      return decrease(false, focusBack);\n    }, 'minus', 'Decrease font size', []));\n    var memPlus = record(makeStepperButton(function (focusBack) {\n      return increase(false, focusBack);\n    }, 'plus', 'Increase font size', []));\n    var memInput = record({\n      dom: {\n        tag: 'div',\n        classes: ['tox-input-wrapper']\n      },\n      components: [Input.sketch({\n        inputBehaviours: derive$1([Disabling.config({}), config(customEvents, [onControlAttached({\n          onSetup: onSetup,\n          getApi: getApi\n        }, editorOffCell), onControlDetached({\n          getApi: getApi\n        }, editorOffCell)]), config('input-update-display-text', [run$1(updateMenuText, function (comp, se) {\n          Representing.setValue(comp, se.event.text);\n        }), run$1(focusout(), function (comp) {\n          spec.onAction(Representing.getValue(comp));\n        }), run$1(change(), function (comp) {\n          spec.onAction(Representing.getValue(comp));\n        })]), Keying.config({\n          mode: 'special',\n          onEnter: function onEnter(_comp) {\n            changeValue(identity, true, true);\n            return Optional.some(true);\n          },\n          onEscape: goToParent,\n          onUp: function onUp(_comp) {\n            increase(true, false);\n            return Optional.some(true);\n          },\n          onDown: function onDown(_comp) {\n            decrease(true, false);\n            return Optional.some(true);\n          },\n          onLeft: function onLeft(_comp, se) {\n            se.cut();\n            return Optional.none();\n          },\n          onRight: function onRight(_comp, se) {\n            se.cut();\n            return Optional.none();\n          }\n        })])\n      })],\n      behaviours: derive$1([Focusing.config({}), Keying.config({\n        mode: 'special',\n        onEnter: focusInput,\n        onSpace: focusInput,\n        onEscape: goToParent\n      }), config('input-wrapper-events', [run$1(mouseover(), function (comp) {\n        each$1([memMinus, memPlus], function (button) {\n          var buttonNode = SugarElement.fromDom(button.get(comp).element.dom);\n          if (hasFocus(buttonNode)) {\n            blur$1(buttonNode);\n          }\n        });\n      })])])\n    });\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-number-input']\n      },\n      components: [memMinus.asSpec(), memInput.asSpec(), memPlus.asSpec()],\n      behaviours: derive$1([Focusing.config({}), Keying.config({\n        mode: 'flow',\n        focusInside: FocusInsideModes.OnEnterOrSpaceMode,\n        cycles: false,\n        selector: 'button, .tox-input-wrapper',\n        onEscape: function onEscape(wrapperComp) {\n          if (hasFocus(wrapperComp.element)) {\n            return Optional.none();\n          } else {\n            focus$3(wrapperComp.element);\n            return Optional.some(true);\n          }\n        }\n      })])\n    };\n  };\n  var title$1 = 'Font sizes';\n  var fallbackFontSize = '12pt';\n  var legacyFontSizes = {\n    '8pt': '1',\n    '10pt': '2',\n    '12pt': '3',\n    '14pt': '4',\n    '18pt': '5',\n    '24pt': '6',\n    '36pt': '7'\n  };\n  var keywordFontSizes = {\n    'xx-small': '7pt',\n    'x-small': '8pt',\n    'small': '10pt',\n    'medium': '12pt',\n    'large': '14pt',\n    'x-large': '18pt',\n    'xx-large': '24pt'\n  };\n  var round = function round(number, precision) {\n    var factor = Math.pow(10, precision);\n    return Math.round(number * factor) / factor;\n  };\n  var toPt = function toPt(fontSize, precision) {\n    if (/[0-9.]+px$/.test(fontSize)) {\n      return round(parseInt(fontSize, 10) * 72 / 96, precision || 0) + 'pt';\n    } else {\n      return get$g(keywordFontSizes, fontSize).getOr(fontSize);\n    }\n  };\n  var toLegacy = function toLegacy(fontSize) {\n    return get$g(legacyFontSizes, fontSize).getOr('');\n  };\n  var getSpec$1 = function getSpec$1(editor) {\n    var getMatchingValue = function getMatchingValue() {\n      var matchOpt = Optional.none();\n      var items = dataset.data;\n      var fontSize = editor.queryCommandValue('FontSize');\n      if (fontSize) {\n        var _loop = function _loop() {\n          var pt = toPt(fontSize, precision);\n          var legacy = toLegacy(pt);\n          matchOpt = find$5(items, function (item) {\n            return item.format === fontSize || item.format === pt || item.format === legacy;\n          });\n        };\n        for (var precision = 3; matchOpt.isNone() && precision >= 0; precision--) {\n          _loop();\n        }\n      }\n      return {\n        matchOpt: matchOpt,\n        size: fontSize\n      };\n    };\n    var isSelectedFor = function isSelectedFor(item) {\n      return function (valueOpt) {\n        return valueOpt.exists(function (value) {\n          return value.format === item;\n        });\n      };\n    };\n    var getCurrentValue = function getCurrentValue() {\n      var _getMatchingValue3 = getMatchingValue(),\n        matchOpt = _getMatchingValue3.matchOpt;\n      return matchOpt;\n    };\n    var getPreviewFor = constant$1(Optional.none);\n    var onAction = function onAction(rawItem) {\n      return function () {\n        editor.undoManager.transact(function () {\n          editor.focus();\n          editor.execCommand('FontSize', false, rawItem.format);\n        });\n      };\n    };\n    var updateSelectMenuText = function updateSelectMenuText(comp) {\n      var _getMatchingValue4 = getMatchingValue(),\n        matchOpt = _getMatchingValue4.matchOpt,\n        size = _getMatchingValue4.size;\n      var text = matchOpt.fold(constant$1(size), function (match) {\n        return match.title;\n      });\n      emitWith(comp, updateMenuText, {\n        text: text\n      });\n      fireFontSizeTextUpdate(editor, {\n        value: text\n      });\n    };\n    var dataset = buildBasicSettingsDataset(editor, 'font_size_formats', Delimiter.Space);\n    return {\n      tooltip: getTooltipText(editor, title$1, fallbackFontSize),\n      text: Optional.some(fallbackFontSize),\n      icon: Optional.none(),\n      isSelectedFor: isSelectedFor,\n      getPreviewFor: getPreviewFor,\n      getCurrentValue: getCurrentValue,\n      onAction: onAction,\n      updateText: updateSelectMenuText,\n      dataset: dataset,\n      shouldHide: false,\n      isInvalid: never\n    };\n  };\n  var createFontSizeButton = function createFontSizeButton(editor, backstage) {\n    return createSelectButton(editor, backstage, getSpec$1(editor), title$1, 'FontSizeTextUpdate');\n  };\n  var getConfigFromUnit = function getConfigFromUnit(unit) {\n    var _a;\n    var baseConfig = {\n      step: 1\n    };\n    var configs = {\n      em: {\n        step: 0.1\n      },\n      cm: {\n        step: 0.1\n      },\n      in: {\n        step: 0.1\n      },\n      pc: {\n        step: 0.1\n      },\n      ch: {\n        step: 0.1\n      },\n      rem: {\n        step: 0.1\n      }\n    };\n    return (_a = configs[unit]) !== null && _a !== void 0 ? _a : baseConfig;\n  };\n  var defaultValue = 16;\n  var isValidValue = function isValidValue(value) {\n    return value >= 0;\n  };\n  var getNumberInputSpec = function getNumberInputSpec(editor) {\n    var getCurrentValue = function getCurrentValue() {\n      return editor.queryCommandValue('FontSize');\n    };\n    var updateInputValue = function updateInputValue(comp) {\n      return emitWith(comp, updateMenuText, {\n        text: getCurrentValue()\n      });\n    };\n    return {\n      updateInputValue: updateInputValue,\n      onAction: function onAction(format, focusBack) {\n        return editor.execCommand('FontSize', false, format, {\n          skip_focus: !focusBack\n        });\n      },\n      getNewValue: function getNewValue(text, updateFunction) {\n        parse(text, ['unsupportedLength', 'empty']);\n        var currentValue = getCurrentValue();\n        var parsedText = parse(text, ['unsupportedLength', 'empty']).or(parse(currentValue, ['unsupportedLength', 'empty']));\n        var value = parsedText.map(function (res) {\n          return res.value;\n        }).getOr(defaultValue);\n        var defaultUnit = getFontSizeInputDefaultUnit(editor);\n        var unit = parsedText.map(function (res) {\n          return res.unit;\n        }).filter(function (u) {\n          return u !== '';\n        }).getOr(defaultUnit);\n        var newValue = updateFunction(value, getConfigFromUnit(unit).step);\n        var res = \"\".concat(isValidValue(newValue) ? newValue : value).concat(unit);\n        if (res !== currentValue) {\n          fireFontSizeInputTextUpdate(editor, {\n            value: res\n          });\n        }\n        return res;\n      }\n    };\n  };\n  var createFontSizeInputButton = function createFontSizeInputButton(editor, backstage) {\n    return createBespokeNumberInput(editor, backstage, getNumberInputSpec(editor));\n  };\n  var createFontSizeMenu = function createFontSizeMenu(editor, backstage) {\n    var menuItems = createMenuItems(editor, backstage, getSpec$1(editor));\n    editor.ui.registry.addNestedMenuItem('fontsize', {\n      text: title$1,\n      onSetup: onSetupEditableToggle(editor),\n      getSubmenuItems: function getSubmenuItems() {\n        return menuItems.items.validateItems(menuItems.getStyleItems());\n      }\n    });\n  };\n  var title = 'Formats';\n  var getSpec = function getSpec(editor, dataset) {\n    var fallbackFormat = 'Paragraph';\n    var isSelectedFor = function isSelectedFor(format) {\n      return function () {\n        return editor.formatter.match(format);\n      };\n    };\n    var getPreviewFor = function getPreviewFor(format) {\n      return function () {\n        var fmt = editor.formatter.get(format);\n        return fmt !== undefined ? Optional.some({\n          tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || 'div' : 'div',\n          styles: editor.dom.parseStyle(editor.formatter.getCssText(format))\n        }) : Optional.none();\n      };\n    };\n    var updateSelectMenuText = function updateSelectMenuText(comp) {\n      var getFormatItems = function getFormatItems(fmt) {\n        if (isNestedFormat(fmt)) {\n          return bind$3(fmt.items, getFormatItems);\n        } else if (isFormatReference(fmt)) {\n          return [{\n            title: fmt.title,\n            format: fmt.format\n          }];\n        } else {\n          return [];\n        }\n      };\n      var flattenedItems = bind$3(getStyleFormats(editor), getFormatItems);\n      var detectedFormat = findNearest(editor, constant$1(flattenedItems));\n      var text = detectedFormat.fold(constant$1(fallbackFormat), function (fmt) {\n        return fmt.title;\n      });\n      emitWith(comp, updateMenuText, {\n        text: text\n      });\n      fireStylesTextUpdate(editor, {\n        value: text\n      });\n    };\n    return {\n      tooltip: getTooltipText(editor, title, fallbackFormat),\n      text: Optional.some(fallbackFormat),\n      icon: Optional.none(),\n      isSelectedFor: isSelectedFor,\n      getCurrentValue: Optional.none,\n      getPreviewFor: getPreviewFor,\n      onAction: onActionToggleFormat$1(editor),\n      updateText: updateSelectMenuText,\n      shouldHide: shouldAutoHideStyleFormats(editor),\n      isInvalid: function isInvalid(item) {\n        return !editor.formatter.canApply(item.format);\n      },\n      dataset: dataset\n    };\n  };\n  var createStylesButton = function createStylesButton(editor, backstage) {\n    var dataset = _objectSpread({\n      type: 'advanced'\n    }, backstage.styles);\n    return createSelectButton(editor, backstage, getSpec(editor, dataset), title, 'StylesTextUpdate');\n  };\n  var createStylesMenu = function createStylesMenu(editor, backstage) {\n    var dataset = _objectSpread({\n      type: 'advanced'\n    }, backstage.styles);\n    var menuItems = createMenuItems(editor, backstage, getSpec(editor, dataset));\n    editor.ui.registry.addNestedMenuItem('styles', {\n      text: title,\n      onSetup: onSetupEditableToggle(editor),\n      getSubmenuItems: function getSubmenuItems() {\n        return menuItems.items.validateItems(menuItems.getStyleItems());\n      }\n    });\n  };\n  var schema$7 = constant$1([required$1('toggleClass'), required$1('fetch'), onStrictHandler('onExecute'), defaulted('getHotspot', Optional.some), defaulted('getAnchorOverrides', constant$1({})), schema$y(), onStrictHandler('onItemExecute'), option$3('lazySink'), required$1('dom'), onHandler('onOpen'), field('splitDropdownBehaviours', [Coupling, Keying, Focusing]), defaulted('matchWidth', false), defaulted('useMinWidth', false), defaulted('eventOrder', {}), option$3('role')].concat(sandboxFields()));\n  var arrowPart = required({\n    factory: Button,\n    schema: [required$1('dom')],\n    name: 'arrow',\n    defaults: function defaults() {\n      return {\n        buttonBehaviours: derive$1([Focusing.revoke()])\n      };\n    },\n    overrides: function overrides(detail) {\n      return {\n        dom: {\n          tag: 'span',\n          attributes: {\n            role: 'presentation'\n          }\n        },\n        action: function action(arrow) {\n          arrow.getSystem().getByUid(detail.uid).each(emitExecute);\n        },\n        buttonBehaviours: derive$1([Toggling.config({\n          toggleOnExecute: false,\n          toggleClass: detail.toggleClass\n        })])\n      };\n    }\n  });\n  var buttonPart = required({\n    factory: Button,\n    schema: [required$1('dom')],\n    name: 'button',\n    defaults: function defaults() {\n      return {\n        buttonBehaviours: derive$1([Focusing.revoke()])\n      };\n    },\n    overrides: function overrides(detail) {\n      return {\n        dom: {\n          tag: 'span',\n          attributes: {\n            role: 'presentation'\n          }\n        },\n        action: function action(btn) {\n          btn.getSystem().getByUid(detail.uid).each(function (splitDropdown) {\n            detail.onExecute(splitDropdown, btn);\n          });\n        }\n      };\n    }\n  });\n  var parts$3 = constant$1([arrowPart, buttonPart, optional({\n    factory: {\n      sketch: function sketch(spec) {\n        return {\n          uid: spec.uid,\n          dom: {\n            tag: 'span',\n            styles: {\n              display: 'none'\n            },\n            attributes: {\n              'aria-hidden': 'true'\n            },\n            innerHtml: spec.text\n          }\n        };\n      }\n    },\n    schema: [required$1('text')],\n    name: 'aria-descriptor'\n  }), external({\n    schema: [tieredMenuMarkers()],\n    name: 'menu',\n    defaults: function defaults(detail) {\n      return {\n        onExecute: function onExecute(tmenu, item) {\n          tmenu.getSystem().getByUid(detail.uid).each(function (splitDropdown) {\n            detail.onItemExecute(splitDropdown, tmenu, item);\n          });\n        }\n      };\n    }\n  }), partType$1()]);\n  var factory$5 = function factory$5(detail, components, spec, externals) {\n    var switchToMenu = function switchToMenu(sandbox) {\n      Composing.getCurrent(sandbox).each(function (current) {\n        Highlighting.highlightFirst(current);\n        Keying.focusIn(current);\n      });\n    };\n    var action = function action(component) {\n      var onOpenSync = switchToMenu;\n      togglePopup(detail, identity, component, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop);\n    };\n    var openMenu = function openMenu(comp) {\n      action(comp);\n      return Optional.some(true);\n    };\n    var executeOnButton = function executeOnButton(comp) {\n      var button = getPartOrDie(comp, detail, 'button');\n      emitExecute(button);\n      return Optional.some(true);\n    };\n    var buttonEvents = _objectSpread({}, derive$2([runOnAttached(function (component, _simulatedEvent) {\n      var ariaDescriptor = getPart(component, detail, 'aria-descriptor');\n      ariaDescriptor.each(function (descriptor) {\n        var descriptorId = generate$6('aria');\n        set$9(descriptor.element, 'id', descriptorId);\n        set$9(component.element, 'aria-describedby', descriptorId);\n      });\n    })]), events$a(Optional.some(action)));\n    var apis = {\n      repositionMenus: function repositionMenus(comp) {\n        if (Toggling.isOn(comp)) {\n          _repositionMenus(comp);\n        }\n      }\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      apis: apis,\n      eventOrder: _objectSpread({}, detail.eventOrder, _defineProperty({}, execute$5(), ['disabling', 'toggling', 'alloy.base.behaviour'])),\n      events: buttonEvents,\n      behaviours: augment(detail.splitDropdownBehaviours, [Coupling.config({\n        others: {\n          sandbox: function sandbox(hotspot) {\n            var arrow = getPartOrDie(hotspot, detail, 'arrow');\n            var extras = {\n              onOpen: function onOpen() {\n                Toggling.on(arrow);\n                Toggling.on(hotspot);\n              },\n              onClose: function onClose() {\n                Toggling.off(arrow);\n                Toggling.off(hotspot);\n              }\n            };\n            return makeSandbox$1(detail, hotspot, extras);\n          }\n        }\n      }), Keying.config({\n        mode: 'special',\n        onSpace: executeOnButton,\n        onEnter: executeOnButton,\n        onDown: openMenu\n      }), Focusing.config({}), Toggling.config({\n        toggleOnExecute: false,\n        aria: {\n          mode: 'expanded'\n        }\n      })]),\n      domModification: {\n        attributes: {\n          'role': detail.role.getOr('button'),\n          'aria-haspopup': true\n        }\n      }\n    };\n  };\n  var SplitDropdown = composite({\n    name: 'SplitDropdown',\n    configFields: schema$7(),\n    partFields: parts$3(),\n    factory: factory$5,\n    apis: {\n      repositionMenus: function repositionMenus(apis, comp) {\n        return apis.repositionMenus(comp);\n      }\n    }\n  });\n  var getButtonApi = function getButtonApi(component) {\n    return {\n      isEnabled: function isEnabled() {\n        return !Disabling.isDisabled(component);\n      },\n      setEnabled: function setEnabled(state) {\n        return Disabling.set(component, !state);\n      },\n      setText: function setText(text) {\n        return emitWith(component, updateMenuText, {\n          text: text\n        });\n      },\n      setIcon: function setIcon(icon) {\n        return emitWith(component, updateMenuIcon, {\n          icon: icon\n        });\n      }\n    };\n  };\n  var getToggleApi = function getToggleApi(component) {\n    return {\n      setActive: function setActive(state) {\n        Toggling.set(component, state);\n      },\n      isActive: function isActive() {\n        return Toggling.isOn(component);\n      },\n      isEnabled: function isEnabled() {\n        return !Disabling.isDisabled(component);\n      },\n      setEnabled: function setEnabled(state) {\n        return Disabling.set(component, !state);\n      },\n      setText: function setText(text) {\n        return emitWith(component, updateMenuText, {\n          text: text\n        });\n      },\n      setIcon: function setIcon(icon) {\n        return emitWith(component, updateMenuIcon, {\n          icon: icon\n        });\n      }\n    };\n  };\n  var getTooltipAttributes = function getTooltipAttributes(tooltip, providersBackstage) {\n    return tooltip.map(function (tooltip) {\n      return {\n        'aria-label': providersBackstage.translate(tooltip),\n        'title': providersBackstage.translate(tooltip)\n      };\n    }).getOr({});\n  };\n  var focusButtonEvent = generate$6('focus-button');\n  var renderCommonStructure = function renderCommonStructure(optIcon, optText, tooltip, behaviours, providersBackstage) {\n    var _eventOrder6;\n    var optMemDisplayText = optText.map(function (text) {\n      return record(renderLabel$1(text, 'tox-tbtn', providersBackstage));\n    });\n    var optMemDisplayIcon = optIcon.map(function (icon) {\n      return record(renderReplaceableIconFromPack(icon, providersBackstage.icons));\n    });\n    return {\n      dom: {\n        tag: 'button',\n        classes: ['tox-tbtn'].concat(optText.isSome() ? ['tox-tbtn--select'] : []),\n        attributes: getTooltipAttributes(tooltip, providersBackstage)\n      },\n      components: componentRenderPipeline([optMemDisplayIcon.map(function (mem) {\n        return mem.asSpec();\n      }), optMemDisplayText.map(function (mem) {\n        return mem.asSpec();\n      })]),\n      eventOrder: (_eventOrder6 = {}, _defineProperty(_eventOrder6, mousedown(), ['focusing', 'alloy.base.behaviour', commonButtonDisplayEvent]), _defineProperty(_eventOrder6, attachedToDom(), [commonButtonDisplayEvent, 'toolbar-group-button-events']), _eventOrder6),\n      buttonBehaviours: derive$1([DisablingConfigs.toolbarButton(providersBackstage.isDisabled), receivingConfig(), config(commonButtonDisplayEvent, [runOnAttached(function (comp, _se) {\n        return forceInitialSize(comp);\n      }), run$1(updateMenuText, function (comp, se) {\n        optMemDisplayText.bind(function (mem) {\n          return mem.getOpt(comp);\n        }).each(function (displayText) {\n          Replacing.set(displayText, [text$2(providersBackstage.translate(se.event.text))]);\n        });\n      }), run$1(updateMenuIcon, function (comp, se) {\n        optMemDisplayIcon.bind(function (mem) {\n          return mem.getOpt(comp);\n        }).each(function (displayIcon) {\n          Replacing.set(displayIcon, [renderReplaceableIconFromPack(se.event.icon, providersBackstage.icons)]);\n        });\n      }), run$1(mousedown(), function (button, se) {\n        se.event.prevent();\n        emit(button, focusButtonEvent);\n      })])].concat(behaviours.getOr([])))\n    };\n  };\n  var renderFloatingToolbarButton = function renderFloatingToolbarButton(spec, backstage, identifyButtons, attributes) {\n    var sharedBackstage = backstage.shared;\n    var editorOffCell = Cell(noop);\n    var specialisation = {\n      toolbarButtonBehaviours: [],\n      getApi: getButtonApi,\n      onSetup: spec.onSetup\n    };\n    var behaviours = [config('toolbar-group-button-events', [onControlAttached(specialisation, editorOffCell), onControlDetached(specialisation, editorOffCell)])];\n    return FloatingToolbarButton.sketch({\n      lazySink: sharedBackstage.getSink,\n      fetch: function fetch() {\n        return Future.nu(function (resolve) {\n          resolve(map$2(identifyButtons(spec.items), renderToolbarGroup));\n        });\n      },\n      markers: {\n        toggledClass: 'tox-tbtn--enabled'\n      },\n      parts: {\n        button: renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.some(behaviours), sharedBackstage.providers),\n        toolbar: {\n          dom: {\n            tag: 'div',\n            classes: ['tox-toolbar__overflow'],\n            attributes: attributes\n          }\n        }\n      }\n    });\n  };\n  var renderCommonToolbarButton = function renderCommonToolbarButton(spec, specialisation, providersBackstage) {\n    var _d;\n    var editorOffCell = Cell(noop);\n    var structure = renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.none(), providersBackstage);\n    return Button.sketch({\n      dom: structure.dom,\n      components: structure.components,\n      eventOrder: toolbarButtonEventOrder,\n      buttonBehaviours: _objectSpread({}, derive$1([config('toolbar-button-events', [onToolbarButtonExecute({\n        onAction: spec.onAction,\n        getApi: specialisation.getApi\n      }), onControlAttached(specialisation, editorOffCell), onControlDetached(specialisation, editorOffCell)]), DisablingConfigs.toolbarButton(function () {\n        return !spec.enabled || providersBackstage.isDisabled();\n      }), receivingConfig()].concat(specialisation.toolbarButtonBehaviours)), _defineProperty({}, commonButtonDisplayEvent, (_d = structure.buttonBehaviours) === null || _d === void 0 ? void 0 : _d[commonButtonDisplayEvent]))\n    });\n  };\n  var renderToolbarButton = function renderToolbarButton(spec, providersBackstage) {\n    return renderToolbarButtonWith(spec, providersBackstage, []);\n  };\n  var renderToolbarButtonWith = function renderToolbarButtonWith(spec, providersBackstage, bonusEvents) {\n    return renderCommonToolbarButton(spec, {\n      toolbarButtonBehaviours: bonusEvents.length > 0 ? [config('toolbarButtonWith', bonusEvents)] : [],\n      getApi: getButtonApi,\n      onSetup: spec.onSetup\n    }, providersBackstage);\n  };\n  var renderToolbarToggleButton = function renderToolbarToggleButton(spec, providersBackstage) {\n    return renderToolbarToggleButtonWith(spec, providersBackstage, []);\n  };\n  var renderToolbarToggleButtonWith = function renderToolbarToggleButtonWith(spec, providersBackstage, bonusEvents) {\n    return renderCommonToolbarButton(spec, {\n      toolbarButtonBehaviours: [Replacing.config({}), Toggling.config({\n        toggleClass: 'tox-tbtn--enabled',\n        aria: {\n          mode: 'pressed'\n        },\n        toggleOnExecute: false\n      })].concat(bonusEvents.length > 0 ? [config('toolbarToggleButtonWith', bonusEvents)] : []),\n      getApi: getToggleApi,\n      onSetup: spec.onSetup\n    }, providersBackstage);\n  };\n  var fetchChoices = function fetchChoices(getApi, spec, providersBackstage) {\n    return function (comp) {\n      return Future.nu(function (callback) {\n        return spec.fetch(callback);\n      }).map(function (items) {\n        return Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6('menu-value'), items, function (value) {\n          spec.onItemAction(getApi(comp), value);\n        }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), providersBackstage), {\n          movement: deriveMenuMovement(spec.columns, spec.presets),\n          menuBehaviours: SimpleBehaviours.unnamedEvents(spec.columns !== 'auto' ? [] : [runOnAttached(function (comp, _se) {\n            detectSize(comp, 4, classForPreset(spec.presets)).each(function (_ref24) {\n              var numRows = _ref24.numRows,\n                numColumns = _ref24.numColumns;\n              Keying.setGridSize(comp, numRows, numColumns);\n            });\n          })])\n        })));\n      });\n    };\n  };\n  var renderSplitButton = function renderSplitButton(spec, sharedBackstage) {\n    var getApi = function getApi(comp) {\n      return {\n        isEnabled: function isEnabled() {\n          return !Disabling.isDisabled(comp);\n        },\n        setEnabled: function setEnabled(state) {\n          return Disabling.set(comp, !state);\n        },\n        setIconFill: function setIconFill(id, value) {\n          descendant(comp.element, \"svg path[class=\\\"\".concat(id, \"\\\"], rect[class=\\\"\").concat(id, \"\\\"]\")).each(function (underlinePath) {\n            set$9(underlinePath, 'fill', value);\n          });\n        },\n        setActive: function setActive(state) {\n          set$9(comp.element, 'aria-pressed', state);\n          descendant(comp.element, 'span').each(function (button) {\n            comp.getSystem().getByDom(button).each(function (buttonComp) {\n              return Toggling.set(buttonComp, state);\n            });\n          });\n        },\n        isActive: function isActive() {\n          return descendant(comp.element, 'span').exists(function (button) {\n            return comp.getSystem().getByDom(button).exists(Toggling.isOn);\n          });\n        },\n        setText: function setText(text) {\n          return descendant(comp.element, 'span').each(function (button) {\n            return comp.getSystem().getByDom(button).each(function (buttonComp) {\n              return emitWith(buttonComp, updateMenuText, {\n                text: text\n              });\n            });\n          });\n        },\n        setIcon: function setIcon(icon) {\n          return descendant(comp.element, 'span').each(function (button) {\n            return comp.getSystem().getByDom(button).each(function (buttonComp) {\n              return emitWith(buttonComp, updateMenuIcon, {\n                icon: icon\n              });\n            });\n          });\n        },\n        setTooltip: function setTooltip(tooltip) {\n          var translatedTooltip = sharedBackstage.providers.translate(tooltip);\n          setAll$1(comp.element, {\n            'aria-label': translatedTooltip,\n            'title': translatedTooltip\n          });\n        }\n      };\n    };\n    var editorOffCell = Cell(noop);\n    var specialisation = {\n      getApi: getApi,\n      onSetup: spec.onSetup\n    };\n    return SplitDropdown.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-split-button'],\n        attributes: _objectSpread({\n          'aria-pressed': false\n        }, getTooltipAttributes(spec.tooltip, sharedBackstage.providers))\n      },\n      onExecute: function onExecute(button) {\n        var api = getApi(button);\n        if (api.isEnabled()) {\n          spec.onAction(api);\n        }\n      },\n      onItemExecute: function onItemExecute(_a, _b, _c) {},\n      splitDropdownBehaviours: derive$1([DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled), receivingConfig(), config('split-dropdown-events', [runOnAttached(function (comp, _se) {\n        return forceInitialSize(comp);\n      }), run$1(focusButtonEvent, Focusing.focus), onControlAttached(specialisation, editorOffCell), onControlDetached(specialisation, editorOffCell)]), Unselecting.config({})]),\n      eventOrder: _defineProperty({}, attachedToDom(), ['alloy.base.behaviour', 'split-dropdown-events']),\n      toggleClass: 'tox-tbtn--enabled',\n      lazySink: sharedBackstage.getSink,\n      fetch: fetchChoices(getApi, spec, sharedBackstage.providers),\n      parts: {\n        menu: part(false, spec.columns, spec.presets)\n      },\n      components: [SplitDropdown.parts.button(renderCommonStructure(spec.icon, spec.text, Optional.none(), Optional.some([Toggling.config({\n        toggleClass: 'tox-tbtn--enabled',\n        toggleOnExecute: false\n      })]), sharedBackstage.providers)), SplitDropdown.parts.arrow({\n        dom: {\n          tag: 'button',\n          classes: ['tox-tbtn', 'tox-split-button__chevron'],\n          innerHtml: get$2('chevron-down', sharedBackstage.providers.icons)\n        },\n        buttonBehaviours: derive$1([DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled), receivingConfig(), addFocusableBehaviour()])\n      }), SplitDropdown.parts['aria-descriptor']({\n        text: sharedBackstage.providers.translate('To open the popup, press Shift+Enter')\n      })]\n    });\n  };\n  var defaultToolbar = [{\n    name: 'history',\n    items: ['undo', 'redo']\n  }, {\n    name: 'ai',\n    items: ['aidialog', 'aishortcuts']\n  }, {\n    name: 'styles',\n    items: ['styles']\n  }, {\n    name: 'formatting',\n    items: ['bold', 'italic']\n  }, {\n    name: 'alignment',\n    items: ['alignleft', 'aligncenter', 'alignright', 'alignjustify']\n  }, {\n    name: 'indentation',\n    items: ['outdent', 'indent']\n  }, {\n    name: 'permanent pen',\n    items: ['permanentpen']\n  }, {\n    name: 'comments',\n    items: ['addcomment']\n  }];\n  var renderFromBridge = function renderFromBridge(bridgeBuilder, render) {\n    return function (spec, backstage, editor) {\n      var internal = bridgeBuilder(spec).mapError(function (errInfo) {\n        return formatError(errInfo);\n      }).getOrDie();\n      return render(internal, backstage, editor);\n    };\n  };\n  var types = {\n    button: renderFromBridge(createToolbarButton, function (s, backstage) {\n      return renderToolbarButton(s, backstage.shared.providers);\n    }),\n    togglebutton: renderFromBridge(createToggleButton, function (s, backstage) {\n      return renderToolbarToggleButton(s, backstage.shared.providers);\n    }),\n    menubutton: renderFromBridge(createMenuButton, function (s, backstage) {\n      return renderMenuButton(s, 'tox-tbtn', backstage, Optional.none(), false);\n    }),\n    splitbutton: renderFromBridge(createSplitButton, function (s, backstage) {\n      return renderSplitButton(s, backstage.shared);\n    }),\n    grouptoolbarbutton: renderFromBridge(createGroupToolbarButton, function (s, backstage, editor) {\n      var buttons = editor.ui.registry.getAll().buttons;\n      var identify = function identify(toolbar) {\n        return identifyButtons(editor, {\n          buttons: buttons,\n          toolbar: toolbar,\n          allowToolbarGroups: false\n        }, backstage, Optional.none());\n      };\n      var attributes = _defineProperty({}, Attribute, backstage.shared.header.isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop);\n      switch (getToolbarMode(editor)) {\n        case ToolbarMode$1.floating:\n          return renderFloatingToolbarButton(s, backstage, identify, attributes);\n        default:\n          throw new Error('Toolbar groups are only supported when using floating toolbar mode');\n      }\n    })\n  };\n  var extractFrom = function extractFrom(spec, backstage, editor) {\n    return get$g(types, spec.type).fold(function () {\n      console.error('skipping button defined by', spec);\n      return Optional.none();\n    }, function (render) {\n      return Optional.some(render(spec, backstage, editor));\n    });\n  };\n  var bespokeButtons = {\n    styles: createStylesButton,\n    fontsize: createFontSizeButton,\n    fontsizeinput: createFontSizeInputButton,\n    fontfamily: createFontFamilyButton,\n    blocks: createBlocksButton,\n    align: createAlignButton\n  };\n  var removeUnusedDefaults = function removeUnusedDefaults(buttons) {\n    var filteredItemGroups = map$2(defaultToolbar, function (group) {\n      var items = filter$2(group.items, function (subItem) {\n        return has$2(buttons, subItem) || has$2(bespokeButtons, subItem);\n      });\n      return {\n        name: group.name,\n        items: items\n      };\n    });\n    return filter$2(filteredItemGroups, function (group) {\n      return group.items.length > 0;\n    });\n  };\n  var convertStringToolbar = function convertStringToolbar(strToolbar) {\n    var groupsStrings = strToolbar.split('|');\n    return map$2(groupsStrings, function (g) {\n      return {\n        items: g.trim().split(' ')\n      };\n    });\n  };\n  var isToolbarGroupSettingArray = function isToolbarGroupSettingArray(toolbar) {\n    return isArrayOf(toolbar, function (t) {\n      return has$2(t, 'name') && has$2(t, 'items');\n    });\n  };\n  var createToolbar = function createToolbar(toolbarConfig) {\n    var toolbar = toolbarConfig.toolbar;\n    var buttons = toolbarConfig.buttons;\n    if (toolbar === false) {\n      return [];\n    } else if (toolbar === undefined || toolbar === true) {\n      return removeUnusedDefaults(buttons);\n    } else if (isString(toolbar)) {\n      return convertStringToolbar(toolbar);\n    } else if (isToolbarGroupSettingArray(toolbar)) {\n      return toolbar;\n    } else {\n      console.error('Toolbar type should be string, string[], boolean or ToolbarGroup[]');\n      return [];\n    }\n  };\n  var lookupButton = function lookupButton(editor, buttons, toolbarItem, allowToolbarGroups, backstage, prefixes) {\n    return get$g(buttons, toolbarItem.toLowerCase()).orThunk(function () {\n      return prefixes.bind(function (ps) {\n        return findMap(ps, function (prefix) {\n          return get$g(buttons, prefix + toolbarItem.toLowerCase());\n        });\n      });\n    }).fold(function () {\n      return get$g(bespokeButtons, toolbarItem.toLowerCase()).map(function (r) {\n        return r(editor, backstage);\n      });\n    }, function (spec) {\n      if (spec.type === 'grouptoolbarbutton' && !allowToolbarGroups) {\n        console.warn(\"Ignoring the '\".concat(toolbarItem, \"' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.\"));\n        return Optional.none();\n      } else {\n        return extractFrom(spec, backstage, editor);\n      }\n    });\n  };\n  var identifyButtons = function identifyButtons(editor, toolbarConfig, backstage, prefixes) {\n    var toolbarGroups = createToolbar(toolbarConfig);\n    var groups = map$2(toolbarGroups, function (group) {\n      var items = bind$3(group.items, function (toolbarItem) {\n        return toolbarItem.trim().length === 0 ? [] : lookupButton(editor, toolbarConfig.buttons, toolbarItem, toolbarConfig.allowToolbarGroups, backstage, prefixes).toArray();\n      });\n      return {\n        title: Optional.from(editor.translate(group.name)),\n        items: items\n      };\n    });\n    return filter$2(groups, function (group) {\n      return group.items.length > 0;\n    });\n  };\n  var setToolbar = function setToolbar(editor, uiRefs, rawUiConfig, backstage) {\n    var outerContainer = uiRefs.mainUi.outerContainer;\n    var toolbarConfig = rawUiConfig.toolbar;\n    var toolbarButtonsConfig = rawUiConfig.buttons;\n    if (isArrayOf(toolbarConfig, isString)) {\n      var toolbars = toolbarConfig.map(function (t) {\n        var config = {\n          toolbar: t,\n          buttons: toolbarButtonsConfig,\n          allowToolbarGroups: rawUiConfig.allowToolbarGroups\n        };\n        return identifyButtons(editor, config, backstage, Optional.none());\n      });\n      OuterContainer.setToolbars(outerContainer, toolbars);\n    } else {\n      OuterContainer.setToolbar(outerContainer, identifyButtons(editor, rawUiConfig, backstage, Optional.none()));\n    }\n  };\n  var detection = detect$2();\n  var isiOS12 = detection.os.isiOS() && detection.os.version.major <= 12;\n  var setupEvents$1 = function setupEvents$1(editor, uiRefs) {\n    var uiMotherships = uiRefs.uiMotherships;\n    var dom = editor.dom;\n    var contentWindow = editor.getWin();\n    var initialDocEle = editor.getDoc().documentElement;\n    var lastWindowDimensions = Cell(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));\n    var lastDocumentDimensions = Cell(SugarPosition(initialDocEle.offsetWidth, initialDocEle.offsetHeight));\n    var resizeWindow = function resizeWindow() {\n      var outer = lastWindowDimensions.get();\n      if (outer.left !== contentWindow.innerWidth || outer.top !== contentWindow.innerHeight) {\n        lastWindowDimensions.set(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));\n        fireResizeContent(editor);\n      }\n    };\n    var resizeDocument = function resizeDocument() {\n      var docEle = editor.getDoc().documentElement;\n      var inner = lastDocumentDimensions.get();\n      if (inner.left !== docEle.offsetWidth || inner.top !== docEle.offsetHeight) {\n        lastDocumentDimensions.set(SugarPosition(docEle.offsetWidth, docEle.offsetHeight));\n        fireResizeContent(editor);\n      }\n    };\n    var scroll = function scroll(e) {\n      fireScrollContent(editor, e);\n    };\n    dom.bind(contentWindow, 'resize', resizeWindow);\n    dom.bind(contentWindow, 'scroll', scroll);\n    var elementLoad = capture(SugarElement.fromDom(editor.getBody()), 'load', resizeDocument);\n    editor.on('hide', function () {\n      each$1(uiMotherships, function (m) {\n        set$8(m.element, 'display', 'none');\n      });\n    });\n    editor.on('show', function () {\n      each$1(uiMotherships, function (m) {\n        remove$6(m.element, 'display');\n      });\n    });\n    editor.on('NodeChange', resizeDocument);\n    editor.on('remove', function () {\n      elementLoad.unbind();\n      dom.unbind(contentWindow, 'resize', resizeWindow);\n      dom.unbind(contentWindow, 'scroll', scroll);\n      contentWindow = null;\n    });\n  };\n  var attachUiMotherships = function attachUiMotherships(editor, uiRoot, uiRefs) {\n    if (isSplitUiMode(editor)) {\n      attachSystemAfter(uiRefs.mainUi.mothership.element, uiRefs.popupUi.mothership);\n    }\n    attachSystem(uiRoot, uiRefs.dialogUi.mothership);\n  };\n  var render$1 = function render$1(editor, uiRefs, rawUiConfig, backstage, args) {\n    var mainUi = uiRefs.mainUi,\n      uiMotherships = uiRefs.uiMotherships;\n    var lastToolbarWidth = Cell(0);\n    var outerContainer = mainUi.outerContainer;\n    iframe(editor);\n    var eTargetNode = SugarElement.fromDom(args.targetNode);\n    var uiRoot = getContentContainer(getRootNode(eTargetNode));\n    attachSystemAfter(eTargetNode, mainUi.mothership);\n    attachUiMotherships(editor, uiRoot, uiRefs);\n    editor.on('SkinLoaded', function () {\n      OuterContainer.setSidebar(outerContainer, rawUiConfig.sidebar, getSidebarShow(editor));\n      setToolbar(editor, uiRefs, rawUiConfig, backstage);\n      lastToolbarWidth.set(editor.getWin().innerWidth);\n      OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));\n      OuterContainer.setViews(outerContainer, rawUiConfig.views);\n      setupEvents$1(editor, uiRefs);\n    });\n    var socket = OuterContainer.getSocket(outerContainer).getOrDie('Could not find expected socket element');\n    if (isiOS12) {\n      setAll(socket.element, {\n        'overflow': 'scroll',\n        '-webkit-overflow-scrolling': 'touch'\n      });\n      var limit = first(function () {\n        editor.dispatch('ScrollContent');\n      }, 20);\n      var unbinder = bind(socket.element, 'scroll', limit.throttle);\n      editor.on('remove', unbinder.unbind);\n    }\n    setupReadonlyModeSwitch(editor, uiRefs);\n    editor.addCommand('ToggleSidebar', function (_ui, value) {\n      OuterContainer.toggleSidebar(outerContainer, value);\n      editor.dispatch('ToggleSidebar');\n    });\n    editor.addQueryValueHandler('ToggleSidebar', function () {\n      var _a;\n      return (_a = OuterContainer.whichSidebar(outerContainer)) !== null && _a !== void 0 ? _a : '';\n    });\n    editor.addCommand('ToggleView', function (_ui, value) {\n      if (OuterContainer.toggleView(outerContainer, value)) {\n        var target = outerContainer.element;\n        mainUi.mothership.broadcastOn([dismissPopups()], {\n          target: target\n        });\n        each$1(uiMotherships, function (m) {\n          m.broadcastOn([dismissPopups()], {\n            target: target\n          });\n        });\n        if (isNull(OuterContainer.whichView(outerContainer))) {\n          editor.focus();\n          editor.nodeChanged();\n          OuterContainer.refreshToolbar(outerContainer);\n        }\n      }\n    });\n    editor.addQueryValueHandler('ToggleView', function () {\n      var _a;\n      return (_a = OuterContainer.whichView(outerContainer)) !== null && _a !== void 0 ? _a : '';\n    });\n    var toolbarMode = getToolbarMode(editor);\n    var refreshDrawer = function refreshDrawer() {\n      OuterContainer.refreshToolbar(uiRefs.mainUi.outerContainer);\n    };\n    if (toolbarMode === ToolbarMode$1.sliding || toolbarMode === ToolbarMode$1.floating) {\n      editor.on('ResizeWindow ResizeEditor ResizeContent', function () {\n        var width = editor.getWin().innerWidth;\n        if (width !== lastToolbarWidth.get()) {\n          refreshDrawer();\n          lastToolbarWidth.set(width);\n        }\n      });\n    }\n    var api = {\n      setEnabled: function setEnabled(state) {\n        broadcastReadonly(uiRefs, !state);\n      },\n      isEnabled: function isEnabled() {\n        return !Disabling.isDisabled(outerContainer);\n      }\n    };\n    return {\n      iframeContainer: socket.element.dom,\n      editorContainer: outerContainer.element.dom,\n      api: api\n    };\n  };\n  var Iframe = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    render: render$1\n  });\n  var parseToInt = function parseToInt(val) {\n    var re = /^[0-9\\.]+(|px)$/i;\n    if (re.test('' + val)) {\n      return Optional.some(parseInt('' + val, 10));\n    }\n    return Optional.none();\n  };\n  var numToPx = function numToPx(val) {\n    return isNumber(val) ? val + 'px' : val;\n  };\n  var calcCappedSize = function calcCappedSize(size, minSize, maxSize) {\n    var minOverride = minSize.filter(function (min) {\n      return size < min;\n    });\n    var maxOverride = maxSize.filter(function (max) {\n      return size > max;\n    });\n    return minOverride.or(maxOverride).getOr(size);\n  };\n  var getHeight = function getHeight(editor) {\n    var baseHeight = getHeightOption(editor);\n    var minHeight = getMinHeightOption(editor);\n    var maxHeight = getMaxHeightOption(editor);\n    return parseToInt(baseHeight).map(function (height) {\n      return calcCappedSize(height, minHeight, maxHeight);\n    });\n  };\n  var getHeightWithFallback = function getHeightWithFallback(editor) {\n    var height = getHeight(editor);\n    return height.getOr(getHeightOption(editor));\n  };\n  var getWidth = function getWidth(editor) {\n    var baseWidth = getWidthOption(editor);\n    var minWidth = getMinWidthOption(editor);\n    var maxWidth = getMaxWidthOption(editor);\n    return parseToInt(baseWidth).map(function (width) {\n      return calcCappedSize(width, minWidth, maxWidth);\n    });\n  };\n  var getWidthWithFallback = function getWidthWithFallback(editor) {\n    var width = getWidth(editor);\n    return width.getOr(getWidthOption(editor));\n  };\n  var ToolbarLocation = Options.ToolbarLocation,\n    ToolbarMode = Options.ToolbarMode;\n  var maximumDistanceToEdge = 40;\n  var InlineHeader = function InlineHeader(editor, targetElm, uiRefs, backstage, floatContainer) {\n    var mainUi = uiRefs.mainUi,\n      uiMotherships = uiRefs.uiMotherships;\n    var DOM = global$7.DOM;\n    var useFixedToolbarContainer = useFixedContainer(editor);\n    var isSticky = isStickyToolbar(editor);\n    var editorMaxWidthOpt = getMaxWidthOption(editor).or(getWidth(editor));\n    var headerBackstage = backstage.shared.header;\n    var isPositionedAtTop = headerBackstage.isPositionedAtTop;\n    var toolbarMode = getToolbarMode(editor);\n    var isSplitToolbar = toolbarMode === ToolbarMode.sliding || toolbarMode === ToolbarMode.floating;\n    var visible = Cell(false);\n    var isVisible = function isVisible() {\n      return visible.get() && !editor.removed;\n    };\n    var calcToolbarOffset = function calcToolbarOffset(toolbar) {\n      return isSplitToolbar ? toolbar.fold(constant$1(0), function (tbar) {\n        return tbar.components().length > 1 ? get$d(tbar.components()[1].element) : 0;\n      }) : 0;\n    };\n    var calcMode = function calcMode(container) {\n      switch (getToolbarLocation(editor)) {\n        case ToolbarLocation.auto:\n          var toolbar = OuterContainer.getToolbar(mainUi.outerContainer);\n          var _offset2 = calcToolbarOffset(toolbar);\n          var toolbarHeight = get$d(container.element) - _offset2;\n          var targetBounds = box$1(targetElm);\n          var roomAtTop = targetBounds.y > toolbarHeight;\n          if (roomAtTop) {\n            return 'top';\n          } else {\n            var doc = documentElement(targetElm);\n            var docHeight = Math.max(doc.dom.scrollHeight, get$d(doc));\n            var roomAtBottom = targetBounds.bottom < docHeight - toolbarHeight;\n            if (roomAtBottom) {\n              return 'bottom';\n            } else {\n              var winBounds = win();\n              var isRoomAtBottomViewport = winBounds.bottom < targetBounds.bottom - toolbarHeight;\n              return isRoomAtBottomViewport ? 'bottom' : 'top';\n            }\n          }\n        case ToolbarLocation.bottom:\n          return 'bottom';\n        case ToolbarLocation.top:\n        default:\n          return 'top';\n      }\n    };\n    var setupMode = function setupMode(mode) {\n      floatContainer.on(function (container) {\n        Docking.setModes(container, [mode]);\n        headerBackstage.setDockingMode(mode);\n        var verticalDir = isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop;\n        set$9(container.element, Attribute, verticalDir);\n      });\n    };\n    var updateChromeWidth = function updateChromeWidth() {\n      floatContainer.on(function (container) {\n        var maxWidth = editorMaxWidthOpt.getOrThunk(function () {\n          var bodyMargin = parseToInt(get$e(body(), 'margin-left')).getOr(0);\n          return get$c(body()) - absolute$3(targetElm).left + bodyMargin;\n        });\n        set$8(container.element, 'max-width', maxWidth + 'px');\n      });\n    };\n    var updateChromePosition = function updateChromePosition(optToolbarWidth) {\n      floatContainer.on(function (container) {\n        var toolbar = OuterContainer.getToolbar(mainUi.outerContainer);\n        var offset = calcToolbarOffset(toolbar);\n        var targetBounds = box$1(targetElm);\n        var _getOffsetParent$1$fo = getOffsetParent$1(editor, mainUi.outerContainer.element).fold(function () {\n            return {\n              top: isPositionedAtTop() ? Math.max(targetBounds.y - get$d(container.element) + offset, 0) : targetBounds.bottom,\n              left: targetBounds.x\n            };\n          }, function (offsetParent) {\n            var _a;\n            var offsetBox = box$1(offsetParent);\n            var scrollDelta = (_a = offsetParent.dom.scrollTop) !== null && _a !== void 0 ? _a : 0;\n            var isOffsetParentBody = eq(offsetParent, body());\n            var topValue = isOffsetParentBody ? Math.max(targetBounds.y - get$d(container.element) + offset, 0) : targetBounds.y - offsetBox.y + scrollDelta - get$d(container.element) + offset;\n            return {\n              top: isPositionedAtTop() ? topValue : targetBounds.bottom,\n              left: isOffsetParentBody ? targetBounds.x : targetBounds.x - offsetBox.x\n            };\n          }),\n          top = _getOffsetParent$1$fo.top,\n          left = _getOffsetParent$1$fo.left;\n        var baseProperties = {\n          position: 'absolute',\n          left: Math.round(left) + 'px',\n          top: Math.round(top) + 'px'\n        };\n        var widthProperties = optToolbarWidth.map(function (toolbarWidth) {\n          var scroll = get$b();\n          var minimumToolbarWidth = 150;\n          var availableWidth = window.innerWidth - (left - scroll.left);\n          var width = Math.max(Math.min(toolbarWidth, availableWidth), minimumToolbarWidth);\n          return {\n            width: width + 'px'\n          };\n        }).getOr({});\n        setAll(mainUi.outerContainer.element, _objectSpread({}, baseProperties, widthProperties));\n      });\n    };\n    var getOffsetParent$1 = function getOffsetParent$1(editor, element) {\n      return isSplitUiMode(editor) ? getOffsetParent(element) : Optional.none();\n    };\n    var repositionPopups$1 = function repositionPopups$1() {\n      each$1(uiMotherships, function (m) {\n        m.broadcastOn([repositionPopups()], {});\n      });\n    };\n    var restoreAndGetCompleteOuterContainerWidth = function restoreAndGetCompleteOuterContainerWidth() {\n      if (!useFixedToolbarContainer) {\n        var toolbarCurrentRightsidePosition = absolute$3(mainUi.outerContainer.element).left + getOuter$1(mainUi.outerContainer.element);\n        if (toolbarCurrentRightsidePosition >= window.innerWidth - maximumDistanceToEdge || getRaw(mainUi.outerContainer.element, 'width').isSome()) {\n          set$8(mainUi.outerContainer.element, 'position', 'absolute');\n          set$8(mainUi.outerContainer.element, 'left', '0px');\n          remove$6(mainUi.outerContainer.element, 'width');\n          var w = getOuter$1(mainUi.outerContainer.element);\n          return Optional.some(w);\n        } else {\n          return Optional.none();\n        }\n      } else {\n        return Optional.none();\n      }\n    };\n    var update = function update(stickyAction) {\n      if (!isVisible()) {\n        return;\n      }\n      if (!useFixedToolbarContainer) {\n        updateChromeWidth();\n      }\n      var optToolbarWidth = useFixedToolbarContainer ? Optional.none() : restoreAndGetCompleteOuterContainerWidth();\n      if (isSplitToolbar) {\n        OuterContainer.refreshToolbar(mainUi.outerContainer);\n      }\n      if (!useFixedToolbarContainer) {\n        updateChromePosition(optToolbarWidth);\n      }\n      if (isSticky) {\n        floatContainer.on(stickyAction);\n      }\n      repositionPopups$1();\n    };\n    var doUpdateMode = function doUpdateMode() {\n      if (useFixedToolbarContainer || !isSticky || !isVisible()) {\n        return false;\n      }\n      return floatContainer.get().exists(function (fc) {\n        var currentMode = headerBackstage.getDockingMode();\n        var newMode = calcMode(fc);\n        if (newMode !== currentMode) {\n          setupMode(newMode);\n          return true;\n        } else {\n          return false;\n        }\n      });\n    };\n    var show = function show() {\n      visible.set(true);\n      set$8(mainUi.outerContainer.element, 'display', 'flex');\n      DOM.addClass(editor.getBody(), 'mce-edit-focus');\n      each$1(uiMotherships, function (m) {\n        remove$6(m.element, 'display');\n      });\n      doUpdateMode();\n      if (isSplitUiMode(editor)) {\n        update(function (elem) {\n          return Docking.isDocked(elem) ? Docking.reset(elem) : Docking.refresh(elem);\n        });\n      } else {\n        update(Docking.refresh);\n      }\n    };\n    var hide = function hide() {\n      visible.set(false);\n      set$8(mainUi.outerContainer.element, 'display', 'none');\n      DOM.removeClass(editor.getBody(), 'mce-edit-focus');\n      each$1(uiMotherships, function (m) {\n        set$8(m.element, 'display', 'none');\n      });\n    };\n    var updateMode = function updateMode() {\n      var changedMode = doUpdateMode();\n      if (changedMode) {\n        update(Docking.reset);\n      }\n    };\n    return {\n      isVisible: isVisible,\n      isPositionedAtTop: isPositionedAtTop,\n      show: show,\n      hide: hide,\n      update: update,\n      updateMode: updateMode,\n      repositionPopups: repositionPopups$1\n    };\n  };\n  var getTargetPosAndBounds = function getTargetPosAndBounds(targetElm, isToolbarTop) {\n    var bounds = box$1(targetElm);\n    return {\n      pos: isToolbarTop ? bounds.y : bounds.bottom,\n      bounds: bounds\n    };\n  };\n  var setupEvents = function setupEvents(editor, targetElm, ui, toolbarPersist) {\n    var prevPosAndBounds = Cell(getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()));\n    var resizeContent = function resizeContent(e) {\n      var _getTargetPosAndBound = getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()),\n        pos = _getTargetPosAndBound.pos,\n        bounds = _getTargetPosAndBound.bounds;\n      var _prevPosAndBounds$get = prevPosAndBounds.get(),\n        prevPos = _prevPosAndBounds$get.pos,\n        prevBounds = _prevPosAndBounds$get.bounds;\n      var hasResized = bounds.height !== prevBounds.height || bounds.width !== prevBounds.width;\n      prevPosAndBounds.set({\n        pos: pos,\n        bounds: bounds\n      });\n      if (hasResized) {\n        fireResizeContent(editor, e);\n      }\n      if (ui.isVisible()) {\n        if (prevPos !== pos) {\n          ui.update(Docking.reset);\n        } else if (hasResized) {\n          ui.updateMode();\n          ui.repositionPopups();\n        }\n      }\n    };\n    if (!toolbarPersist) {\n      editor.on('activate', ui.show);\n      editor.on('deactivate', ui.hide);\n    }\n    editor.on('SkinLoaded ResizeWindow', function () {\n      return ui.update(Docking.reset);\n    });\n    editor.on('NodeChange keydown', function (e) {\n      requestAnimationFrame(function () {\n        return resizeContent(e);\n      });\n    });\n    var lastScrollX = 0;\n    var updateUi = last(function () {\n      return ui.update(Docking.refresh);\n    }, 33);\n    editor.on('ScrollWindow', function () {\n      var newScrollX = get$b().left;\n      if (newScrollX !== lastScrollX) {\n        lastScrollX = newScrollX;\n        updateUi.throttle();\n      }\n      ui.updateMode();\n    });\n    if (isSplitUiMode(editor)) {\n      editor.on('ElementScroll', function (_args) {\n        ui.update(Docking.refresh);\n      });\n    }\n    var elementLoad = unbindable();\n    elementLoad.set(capture(SugarElement.fromDom(editor.getBody()), 'load', function (e) {\n      return resizeContent(e.raw);\n    }));\n    editor.on('remove', function () {\n      elementLoad.clear();\n    });\n  };\n  var render = function render(editor, uiRefs, rawUiConfig, backstage, args) {\n    var mainUi = uiRefs.mainUi;\n    var floatContainer = value$2();\n    var targetElm = SugarElement.fromDom(args.targetNode);\n    var ui = InlineHeader(editor, targetElm, uiRefs, backstage, floatContainer);\n    var toolbarPersist = isToolbarPersist(editor);\n    inline(editor);\n    var render = function render() {\n      if (floatContainer.isSet()) {\n        ui.show();\n        return;\n      }\n      floatContainer.set(OuterContainer.getHeader(mainUi.outerContainer).getOrDie());\n      var uiContainer = getUiContainer(editor);\n      if (isSplitUiMode(editor)) {\n        attachSystemAfter(targetElm, mainUi.mothership);\n        attachSystemAfter(targetElm, uiRefs.popupUi.mothership);\n      } else {\n        attachSystem(uiContainer, mainUi.mothership);\n      }\n      attachSystem(uiContainer, uiRefs.dialogUi.mothership);\n      setToolbar(editor, uiRefs, rawUiConfig, backstage);\n      OuterContainer.setMenubar(mainUi.outerContainer, identifyMenus(editor, rawUiConfig));\n      ui.show();\n      setupEvents(editor, targetElm, ui, toolbarPersist);\n      editor.nodeChanged();\n    };\n    editor.on('show', render);\n    editor.on('hide', ui.hide);\n    if (!toolbarPersist) {\n      editor.on('focus', render);\n      editor.on('blur', ui.hide);\n    }\n    editor.on('init', function () {\n      if (editor.hasFocus() || toolbarPersist) {\n        render();\n      }\n    });\n    setupReadonlyModeSwitch(editor, uiRefs);\n    var api = {\n      show: render,\n      hide: ui.hide,\n      setEnabled: function setEnabled(state) {\n        broadcastReadonly(uiRefs, !state);\n      },\n      isEnabled: function isEnabled() {\n        return !Disabling.isDisabled(mainUi.outerContainer);\n      }\n    };\n    return {\n      editorContainer: mainUi.outerContainer.element.dom,\n      api: api\n    };\n  };\n  var Inline = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    render: render\n  });\n  var LazyUiReferences = function LazyUiReferences() {\n    var dialogUi = value$2();\n    var popupUi = value$2();\n    var mainUi = value$2();\n    var lazyGetInOuterOrDie = function lazyGetInOuterOrDie(label, f) {\n      return function () {\n        return mainUi.get().bind(function (oc) {\n          return f(oc.outerContainer);\n        }).getOrDie(\"Could not find \".concat(label, \" element in OuterContainer\"));\n      };\n    };\n    var getUiMotherships = function getUiMotherships() {\n      var optDialogMothership = dialogUi.get().map(function (ui) {\n        return ui.mothership;\n      });\n      var optPopupMothership = popupUi.get().map(function (ui) {\n        return ui.mothership;\n      });\n      return optDialogMothership.fold(function () {\n        return optPopupMothership.toArray();\n      }, function (dm) {\n        return optPopupMothership.fold(function () {\n          return [dm];\n        }, function (pm) {\n          return eq(dm.element, pm.element) ? [dm] : [dm, pm];\n        });\n      });\n    };\n    return {\n      dialogUi: dialogUi,\n      popupUi: popupUi,\n      mainUi: mainUi,\n      getUiMotherships: getUiMotherships,\n      lazyGetInOuterOrDie: lazyGetInOuterOrDie\n    };\n  };\n  var showContextToolbarEvent = 'contexttoolbar-show';\n  var hideContextToolbarEvent = 'contexttoolbar-hide';\n  var getFormApi = function getFormApi(input) {\n    return {\n      hide: function hide() {\n        return emit(input, sandboxClose());\n      },\n      getValue: function getValue() {\n        return Representing.getValue(input);\n      }\n    };\n  };\n  var runOnExecute = function runOnExecute(memInput, original) {\n    return run$1(internalToolbarButtonExecute, function (comp, se) {\n      var input = memInput.get(comp);\n      var formApi = getFormApi(input);\n      original.onAction(formApi, se.event.buttonApi);\n    });\n  };\n  var renderContextButton = function renderContextButton(memInput, button, providers) {\n    var _button$original = button.original,\n      primary = _button$original.primary,\n      rest = _objectWithoutProperties(_button$original, [\"primary\"]);\n    var bridged = getOrDie(createToolbarButton(_objectSpread({}, rest, {\n      type: 'button',\n      onAction: noop\n    })));\n    return renderToolbarButtonWith(bridged, providers, [runOnExecute(memInput, button)]);\n  };\n  var renderContextToggleButton = function renderContextToggleButton(memInput, button, providers) {\n    var _button$original2 = button.original,\n      primary = _button$original2.primary,\n      rest = _objectWithoutProperties(_button$original2, [\"primary\"]);\n    var bridged = getOrDie(createToggleButton(_objectSpread({}, rest, {\n      type: 'togglebutton',\n      onAction: noop\n    })));\n    return renderToolbarToggleButtonWith(bridged, providers, [runOnExecute(memInput, button)]);\n  };\n  var isToggleButton = function isToggleButton(button) {\n    return button.type === 'contextformtogglebutton';\n  };\n  var generateOne = function generateOne(memInput, button, providersBackstage) {\n    if (isToggleButton(button)) {\n      return renderContextToggleButton(memInput, button, providersBackstage);\n    } else {\n      return renderContextButton(memInput, button, providersBackstage);\n    }\n  };\n  var generate = function generate(memInput, buttons, providersBackstage) {\n    var mementos = map$2(buttons, function (button) {\n      return record(generateOne(memInput, button, providersBackstage));\n    });\n    var asSpecs = function asSpecs() {\n      return map$2(mementos, function (mem) {\n        return mem.asSpec();\n      });\n    };\n    var findPrimary = function findPrimary(compInSystem) {\n      return findMap(buttons, function (button, i) {\n        if (button.primary) {\n          return Optional.from(mementos[i]).bind(function (mem) {\n            return mem.getOpt(compInSystem);\n          }).filter(not(Disabling.isDisabled));\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n    return {\n      asSpecs: asSpecs,\n      findPrimary: findPrimary\n    };\n  };\n  var buildInitGroups = function buildInitGroups(ctx, providers) {\n    var inputAttributes = ctx.label.fold(function () {\n      return {};\n    }, function (label) {\n      return {\n        'aria-label': label\n      };\n    });\n    var memInput = record(Input.sketch({\n      inputClasses: ['tox-toolbar-textfield', 'tox-toolbar-nav-js'],\n      data: ctx.initValue(),\n      inputAttributes: inputAttributes,\n      selectOnFocus: true,\n      inputBehaviours: derive$1([Keying.config({\n        mode: 'special',\n        onEnter: function onEnter(input) {\n          return commands.findPrimary(input).map(function (primary) {\n            emitExecute(primary);\n            return true;\n          });\n        },\n        onLeft: function onLeft(comp, se) {\n          se.cut();\n          return Optional.none();\n        },\n        onRight: function onRight(comp, se) {\n          se.cut();\n          return Optional.none();\n        }\n      })])\n    }));\n    var commands = generate(memInput, ctx.commands, providers);\n    return [{\n      title: Optional.none(),\n      items: [memInput.asSpec()]\n    }, {\n      title: Optional.none(),\n      items: commands.asSpecs()\n    }];\n  };\n  var renderContextForm = function renderContextForm(toolbarType, ctx, providers) {\n    return renderToolbar({\n      type: toolbarType,\n      uid: generate$6('context-toolbar'),\n      initGroups: buildInitGroups(ctx, providers),\n      onEscape: Optional.none,\n      cyclicKeying: true,\n      providers: providers\n    });\n  };\n  var ContextForm = {\n    renderContextForm: renderContextForm,\n    buildInitGroups: buildInitGroups\n  };\n  var isVerticalOverlap = function isVerticalOverlap(a, b, threshold) {\n    return b.bottom - a.y >= threshold && a.bottom - b.y >= threshold;\n  };\n  var getRangeRect = function getRangeRect(rng) {\n    var rect = rng.getBoundingClientRect();\n    if (rect.height <= 0 && rect.width <= 0) {\n      var leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset).element;\n      var elm = isText(leaf$1) ? parent(leaf$1) : Optional.some(leaf$1);\n      return elm.filter(isElement$1).map(function (e) {\n        return e.dom.getBoundingClientRect();\n      }).getOr(rect);\n    } else {\n      return rect;\n    }\n  };\n  var getSelectionBounds = function getSelectionBounds(editor) {\n    var rng = editor.selection.getRng();\n    var rect = getRangeRect(rng);\n    if (editor.inline) {\n      var scroll = get$b();\n      return bounds(scroll.left + rect.left, scroll.top + rect.top, rect.width, rect.height);\n    } else {\n      var bodyPos = absolute$2(SugarElement.fromDom(editor.getBody()));\n      return bounds(bodyPos.x + rect.left, bodyPos.y + rect.top, rect.width, rect.height);\n    }\n  };\n  var getAnchorElementBounds = function getAnchorElementBounds(editor, lastElement) {\n    return lastElement.filter(function (elem) {\n      return inBody(elem) && isHTMLElement(elem);\n    }).map(absolute$2).getOrThunk(function () {\n      return getSelectionBounds(editor);\n    });\n  };\n  var getHorizontalBounds = function getHorizontalBounds(contentAreaBox, viewportBounds, margin) {\n    var x = Math.max(contentAreaBox.x + margin, viewportBounds.x);\n    var right = Math.min(contentAreaBox.right - margin, viewportBounds.right);\n    return {\n      x: x,\n      width: right - x\n    };\n  };\n  var getVerticalBounds = function getVerticalBounds(editor, contentAreaBox, viewportBounds, isToolbarLocationTop, toolbarType, margin) {\n    var container = SugarElement.fromDom(editor.getContainer());\n    var header = descendant(container, '.tox-editor-header').getOr(container);\n    var headerBox = box$1(header);\n    var isToolbarBelowContentArea = headerBox.y >= contentAreaBox.bottom;\n    var isToolbarAbove = isToolbarLocationTop && !isToolbarBelowContentArea;\n    if (editor.inline && isToolbarAbove) {\n      return {\n        y: Math.max(headerBox.bottom + margin, viewportBounds.y),\n        bottom: viewportBounds.bottom\n      };\n    }\n    if (editor.inline && !isToolbarAbove) {\n      return {\n        y: viewportBounds.y,\n        bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)\n      };\n    }\n    var containerBounds = toolbarType === 'line' ? box$1(container) : contentAreaBox;\n    if (isToolbarAbove) {\n      return {\n        y: Math.max(headerBox.bottom + margin, viewportBounds.y),\n        bottom: Math.min(containerBounds.bottom - margin, viewportBounds.bottom)\n      };\n    }\n    return {\n      y: Math.max(containerBounds.y + margin, viewportBounds.y),\n      bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)\n    };\n  };\n  var getContextToolbarBounds = function getContextToolbarBounds(editor, sharedBackstage, toolbarType) {\n    var margin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var viewportBounds = getBounds$3(window);\n    var contentAreaBox = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));\n    var toolbarOrMenubarEnabled = isMenubarEnabled(editor) || isToolbarEnabled(editor) || isMultipleToolbars(editor);\n    var _getHorizontalBounds = getHorizontalBounds(contentAreaBox, viewportBounds, margin),\n      x = _getHorizontalBounds.x,\n      width = _getHorizontalBounds.width;\n    if (editor.inline && !toolbarOrMenubarEnabled) {\n      return bounds(x, viewportBounds.y, width, viewportBounds.height);\n    } else {\n      var isToolbarTop = sharedBackstage.header.isPositionedAtTop();\n      var _getVerticalBounds = getVerticalBounds(editor, contentAreaBox, viewportBounds, isToolbarTop, toolbarType, margin),\n        y = _getVerticalBounds.y,\n        _bottom2 = _getVerticalBounds.bottom;\n      return bounds(x, y, width, _bottom2 - y);\n    }\n  };\n  var bubbleSize$1 = 12;\n  var bubbleAlignments$1 = {\n    valignCentre: [],\n    alignCentre: [],\n    alignLeft: ['tox-pop--align-left'],\n    alignRight: ['tox-pop--align-right'],\n    right: ['tox-pop--right'],\n    left: ['tox-pop--left'],\n    bottom: ['tox-pop--bottom'],\n    top: ['tox-pop--top'],\n    inset: ['tox-pop--inset']\n  };\n  var anchorOverrides = {\n    maxHeightFunction: expandable$1(),\n    maxWidthFunction: expandable()\n  };\n  var isEntireElementSelected = function isEntireElementSelected(editor, elem) {\n    var rng = editor.selection.getRng();\n    var leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n    return rng.startContainer === rng.endContainer && rng.startOffset === rng.endOffset - 1 && eq(leaf$1.element, elem);\n  };\n  var preservePosition = function preservePosition(elem, position, f) {\n    var currentPosition = getRaw(elem, 'position');\n    set$8(elem, 'position', position);\n    var result = f(elem);\n    currentPosition.each(function (pos) {\n      return set$8(elem, 'position', pos);\n    });\n    return result;\n  };\n  var shouldUseInsetLayouts = function shouldUseInsetLayouts(position) {\n    return position === 'node';\n  };\n  var determineInsetLayout = function determineInsetLayout(editor, contextbar, elem, data, bounds) {\n    var selectionBounds = getSelectionBounds(editor);\n    var isSameAnchorElement = data.lastElement().exists(function (prev) {\n      return eq(elem, prev);\n    });\n    if (isEntireElementSelected(editor, elem)) {\n      return isSameAnchorElement ? preserve : north;\n    } else if (isSameAnchorElement) {\n      return preservePosition(contextbar, data.getMode(), function () {\n        var isOverlapping = isVerticalOverlap(selectionBounds, box$1(contextbar), -20);\n        return isOverlapping && !data.isReposition() ? flip : preserve;\n      });\n    } else {\n      var yBounds = data.getMode() === 'fixed' ? bounds.y + get$b().top : bounds.y;\n      var contextbarHeight = get$d(contextbar) + bubbleSize$1;\n      return yBounds + contextbarHeight <= selectionBounds.y ? north : south;\n    }\n  };\n  var getAnchorSpec$2 = function getAnchorSpec$2(editor, mobile, data, position) {\n    var smartInsetLayout = function smartInsetLayout(elem) {\n      return function (anchor, element, bubbles, placee, bounds) {\n        var layout = determineInsetLayout(editor, placee, elem, data, bounds);\n        var newAnchor = _objectSpread({}, anchor, {\n          y: bounds.y,\n          height: bounds.height\n        });\n        return _objectSpread({}, layout(newAnchor, element, bubbles, placee, bounds), {\n          alwaysFit: true\n        });\n      };\n    };\n    var getInsetLayouts = function getInsetLayouts(elem) {\n      return shouldUseInsetLayouts(position) ? [smartInsetLayout(elem)] : [];\n    };\n    var desktopAnchorSpecLayouts = {\n      onLtr: function onLtr(elem) {\n        return [north$2, south$2, northeast$2, southeast$2, northwest$2, southwest$2].concat(getInsetLayouts(elem));\n      },\n      onRtl: function onRtl(elem) {\n        return [north$2, south$2, northwest$2, southwest$2, northeast$2, southeast$2].concat(getInsetLayouts(elem));\n      }\n    };\n    var mobileAnchorSpecLayouts = {\n      onLtr: function onLtr(elem) {\n        return [south$2, southeast$2, southwest$2, northeast$2, northwest$2, north$2].concat(getInsetLayouts(elem));\n      },\n      onRtl: function onRtl(elem) {\n        return [south$2, southwest$2, southeast$2, northwest$2, northeast$2, north$2].concat(getInsetLayouts(elem));\n      }\n    };\n    return mobile ? mobileAnchorSpecLayouts : desktopAnchorSpecLayouts;\n  };\n  var getAnchorLayout = function getAnchorLayout(editor, position, isTouch, data) {\n    if (position === 'line') {\n      return {\n        bubble: nu$5(bubbleSize$1, 0, bubbleAlignments$1),\n        layouts: {\n          onLtr: function onLtr() {\n            return [east$2];\n          },\n          onRtl: function onRtl() {\n            return [west$2];\n          }\n        },\n        overrides: anchorOverrides\n      };\n    } else {\n      return {\n        bubble: nu$5(0, bubbleSize$1, bubbleAlignments$1, 1 / bubbleSize$1),\n        layouts: getAnchorSpec$2(editor, isTouch, data, position),\n        overrides: anchorOverrides\n      };\n    }\n  };\n  var matchTargetWith = function matchTargetWith(elem, candidates) {\n    var ctxs = filter$2(candidates, function (toolbarApi) {\n      return toolbarApi.predicate(elem.dom);\n    });\n    var _partition$ = partition$3(ctxs, function (t) {\n        return t.type === 'contexttoolbar';\n      }),\n      pass = _partition$.pass,\n      fail = _partition$.fail;\n    return {\n      contextToolbars: pass,\n      contextForms: fail\n    };\n  };\n  var filterByPositionForStartNode = function filterByPositionForStartNode(toolbars) {\n    if (toolbars.length <= 1) {\n      return toolbars;\n    } else {\n      var doesPositionExist = function doesPositionExist(value) {\n        return exists(toolbars, function (t) {\n          return t.position === value;\n        });\n      };\n      var filterToolbarsByPosition = function filterToolbarsByPosition(value) {\n        return filter$2(toolbars, function (t) {\n          return t.position === value;\n        });\n      };\n      var hasSelectionToolbars = doesPositionExist('selection');\n      var hasNodeToolbars = doesPositionExist('node');\n      if (hasSelectionToolbars || hasNodeToolbars) {\n        if (hasNodeToolbars && hasSelectionToolbars) {\n          var nodeToolbars = filterToolbarsByPosition('node');\n          var selectionToolbars = map$2(filterToolbarsByPosition('selection'), function (t) {\n            return _objectSpread({}, t, {\n              position: 'node'\n            });\n          });\n          return nodeToolbars.concat(selectionToolbars);\n        } else {\n          return hasSelectionToolbars ? filterToolbarsByPosition('selection') : filterToolbarsByPosition('node');\n        }\n      } else {\n        return filterToolbarsByPosition('line');\n      }\n    }\n  };\n  var filterByPositionForAncestorNode = function filterByPositionForAncestorNode(toolbars) {\n    if (toolbars.length <= 1) {\n      return toolbars;\n    } else {\n      var findPosition = function findPosition(value) {\n        return find$5(toolbars, function (t) {\n          return t.position === value;\n        });\n      };\n      var basePosition = findPosition('selection').orThunk(function () {\n        return findPosition('node');\n      }).orThunk(function () {\n        return findPosition('line');\n      }).map(function (t) {\n        return t.position;\n      });\n      return basePosition.fold(function () {\n        return [];\n      }, function (pos) {\n        return filter$2(toolbars, function (t) {\n          return t.position === pos;\n        });\n      });\n    }\n  };\n  var matchStartNode = function matchStartNode(elem, nodeCandidates, editorCandidates) {\n    var nodeMatches = matchTargetWith(elem, nodeCandidates);\n    if (nodeMatches.contextForms.length > 0) {\n      return Optional.some({\n        elem: elem,\n        toolbars: [nodeMatches.contextForms[0]]\n      });\n    } else {\n      var editorMatches = matchTargetWith(elem, editorCandidates);\n      if (editorMatches.contextForms.length > 0) {\n        return Optional.some({\n          elem: elem,\n          toolbars: [editorMatches.contextForms[0]]\n        });\n      } else if (nodeMatches.contextToolbars.length > 0 || editorMatches.contextToolbars.length > 0) {\n        var toolbars = filterByPositionForStartNode(nodeMatches.contextToolbars.concat(editorMatches.contextToolbars));\n        return Optional.some({\n          elem: elem,\n          toolbars: toolbars\n        });\n      } else {\n        return Optional.none();\n      }\n    }\n  };\n  var matchAncestor = function matchAncestor(isRoot, startNode, scopes) {\n    if (isRoot(startNode)) {\n      return Optional.none();\n    } else {\n      return ancestor$2(startNode, function (ancestorElem) {\n        if (isElement$1(ancestorElem)) {\n          var _matchTargetWith = matchTargetWith(ancestorElem, scopes.inNodeScope),\n            contextToolbars = _matchTargetWith.contextToolbars,\n            contextForms = _matchTargetWith.contextForms;\n          var toolbars = contextForms.length > 0 ? contextForms : filterByPositionForAncestorNode(contextToolbars);\n          return toolbars.length > 0 ? Optional.some({\n            elem: ancestorElem,\n            toolbars: toolbars\n          }) : Optional.none();\n        } else {\n          return Optional.none();\n        }\n      }, isRoot);\n    }\n  };\n  var lookup$1 = function lookup$1(scopes, editor) {\n    var rootElem = SugarElement.fromDom(editor.getBody());\n    var isRoot = function isRoot(elem) {\n      return eq(elem, rootElem);\n    };\n    var isOutsideRoot = function isOutsideRoot(startNode) {\n      return !isRoot(startNode) && !contains(rootElem, startNode);\n    };\n    var startNode = SugarElement.fromDom(editor.selection.getNode());\n    if (isOutsideRoot(startNode)) {\n      return Optional.none();\n    }\n    return matchStartNode(startNode, scopes.inNodeScope, scopes.inEditorScope).orThunk(function () {\n      return matchAncestor(isRoot, startNode, scopes);\n    });\n  };\n  var categorise = function categorise(contextToolbars, navigate) {\n    var forms = {};\n    var inNodeScope = [];\n    var inEditorScope = [];\n    var formNavigators = {};\n    var lookupTable = {};\n    var registerForm = function registerForm(key, toolbarSpec) {\n      var contextForm = getOrDie(createContextForm(toolbarSpec));\n      forms[key] = contextForm;\n      contextForm.launch.map(function (launch) {\n        formNavigators['form:' + key + ''] = _objectSpread({}, toolbarSpec.launch, {\n          type: launch.type === 'contextformtogglebutton' ? 'togglebutton' : 'button',\n          onAction: function onAction() {\n            navigate(contextForm);\n          }\n        });\n      });\n      if (contextForm.scope === 'editor') {\n        inEditorScope.push(contextForm);\n      } else {\n        inNodeScope.push(contextForm);\n      }\n      lookupTable[key] = contextForm;\n    };\n    var registerToolbar = function registerToolbar(key, toolbarSpec) {\n      createContextToolbar(toolbarSpec).each(function (contextToolbar) {\n        if (toolbarSpec.scope === 'editor') {\n          inEditorScope.push(contextToolbar);\n        } else {\n          inNodeScope.push(contextToolbar);\n        }\n        lookupTable[key] = contextToolbar;\n      });\n    };\n    var keys$1 = keys(contextToolbars);\n    each$1(keys$1, function (key) {\n      var toolbarApi = contextToolbars[key];\n      if (toolbarApi.type === 'contextform') {\n        registerForm(key, toolbarApi);\n      } else if (toolbarApi.type === 'contexttoolbar') {\n        registerToolbar(key, toolbarApi);\n      }\n    });\n    return {\n      forms: forms,\n      inNodeScope: inNodeScope,\n      inEditorScope: inEditorScope,\n      lookupTable: lookupTable,\n      formNavigators: formNavigators\n    };\n  };\n  var forwardSlideEvent = generate$6('forward-slide');\n  var backSlideEvent = generate$6('backward-slide');\n  var changeSlideEvent = generate$6('change-slide-event');\n  var resizingClass = 'tox-pop--resizing';\n  var renderContextToolbar = function renderContextToolbar(spec) {\n    var stack = Cell([]);\n    return InlineView.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-pop']\n      },\n      fireDismissalEventInstead: {\n        event: 'doNotDismissYet'\n      },\n      onShow: function onShow(comp) {\n        stack.set([]);\n        InlineView.getContent(comp).each(function (c) {\n          remove$6(c.element, 'visibility');\n        });\n        remove$2(comp.element, resizingClass);\n        remove$6(comp.element, 'width');\n      },\n      inlineBehaviours: derive$1([config('context-toolbar-events', [runOnSource(transitionend(), function (comp, se) {\n        if (se.event.raw.propertyName === 'width') {\n          remove$2(comp.element, resizingClass);\n          remove$6(comp.element, 'width');\n        }\n      }), run$1(changeSlideEvent, function (comp, se) {\n        var elem = comp.element;\n        remove$6(elem, 'width');\n        var currentWidth = get$c(elem);\n        InlineView.setContent(comp, se.event.contents);\n        add$2(elem, resizingClass);\n        var newWidth = get$c(elem);\n        set$8(elem, 'width', currentWidth + 'px');\n        InlineView.getContent(comp).each(function (newContents) {\n          se.event.focus.bind(function (f) {\n            focus$3(f);\n            return search(elem);\n          }).orThunk(function () {\n            Keying.focusIn(newContents);\n            return active$1(getRootNode(elem));\n          });\n        });\n        setTimeout(function () {\n          set$8(comp.element, 'width', newWidth + 'px');\n        }, 0);\n      }), run$1(forwardSlideEvent, function (comp, se) {\n        InlineView.getContent(comp).each(function (oldContents) {\n          stack.set(stack.get().concat([{\n            bar: oldContents,\n            focus: active$1(getRootNode(comp.element))\n          }]));\n        });\n        emitWith(comp, changeSlideEvent, {\n          contents: se.event.forwardContents,\n          focus: Optional.none()\n        });\n      }), run$1(backSlideEvent, function (comp, _se) {\n        last$1(stack.get()).each(function (last) {\n          stack.set(stack.get().slice(0, stack.get().length - 1));\n          emitWith(comp, changeSlideEvent, {\n            contents: premade(last.bar),\n            focus: last.focus\n          });\n        });\n      })]), Keying.config({\n        mode: 'special',\n        onEscape: function onEscape(comp) {\n          return last$1(stack.get()).fold(function () {\n            return spec.onEscape();\n          }, function (_) {\n            emit(comp, backSlideEvent);\n            return Optional.some(true);\n          });\n        }\n      })]),\n      lazySink: function lazySink() {\n        return Result.value(spec.sink);\n      }\n    });\n  };\n  var transitionClass = 'tox-pop--transition';\n  var register$9 = function register$9(editor, registryContextToolbars, sink, extras) {\n    var backstage = extras.backstage;\n    var sharedBackstage = backstage.shared;\n    var isTouch = detect$2().deviceType.isTouch;\n    var lastElement = value$2();\n    var lastTrigger = value$2();\n    var lastContextPosition = value$2();\n    var contextbar = build$1(renderContextToolbar({\n      sink: sink,\n      onEscape: function onEscape() {\n        editor.focus();\n        return Optional.some(true);\n      }\n    }));\n    var getBounds = function getBounds() {\n      var position = lastContextPosition.get().getOr('node');\n      var margin = shouldUseInsetLayouts(position) ? 1 : 0;\n      return getContextToolbarBounds(editor, sharedBackstage, position, margin);\n    };\n    var canLaunchToolbar = function canLaunchToolbar() {\n      return !editor.removed && !(isTouch() && backstage.isContextMenuOpen());\n    };\n    var isSameLaunchElement = function isSameLaunchElement(elem) {\n      return is$1(lift2(elem, lastElement.get(), eq), true);\n    };\n    var shouldContextToolbarHide = function shouldContextToolbarHide() {\n      if (!canLaunchToolbar()) {\n        return true;\n      } else {\n        var contextToolbarBounds = getBounds();\n        var anchorBounds = is$1(lastContextPosition.get(), 'node') ? getAnchorElementBounds(editor, lastElement.get()) : getSelectionBounds(editor);\n        return contextToolbarBounds.height <= 0 || !isVerticalOverlap(anchorBounds, contextToolbarBounds, 0.01);\n      }\n    };\n    var close = function close() {\n      lastElement.clear();\n      lastTrigger.clear();\n      lastContextPosition.clear();\n      InlineView.hide(contextbar);\n    };\n    var hideOrRepositionIfNecessary = function hideOrRepositionIfNecessary() {\n      if (InlineView.isOpen(contextbar)) {\n        var contextBarEle = contextbar.element;\n        remove$6(contextBarEle, 'display');\n        if (shouldContextToolbarHide()) {\n          set$8(contextBarEle, 'display', 'none');\n        } else {\n          lastTrigger.set(0);\n          InlineView.reposition(contextbar);\n        }\n      }\n    };\n    var wrapInPopDialog = function wrapInPopDialog(toolbarSpec) {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-pop__dialog']\n        },\n        components: [toolbarSpec],\n        behaviours: derive$1([Keying.config({\n          mode: 'acyclic'\n        }), config('pop-dialog-wrap-events', [runOnAttached(function (comp) {\n          editor.shortcuts.add('ctrl+F9', 'focus statusbar', function () {\n            return Keying.focusIn(comp);\n          });\n        }), runOnDetached(function (_comp) {\n          editor.shortcuts.remove('ctrl+F9');\n        })])])\n      };\n    };\n    var getScopes = cached(function () {\n      return categorise(registryContextToolbars, function (toolbarApi) {\n        var alloySpec = buildToolbar([toolbarApi]);\n        emitWith(contextbar, forwardSlideEvent, {\n          forwardContents: wrapInPopDialog(alloySpec)\n        });\n      });\n    });\n    var buildContextToolbarGroups = function buildContextToolbarGroups(allButtons, ctx) {\n      return identifyButtons(editor, {\n        buttons: allButtons,\n        toolbar: ctx.items,\n        allowToolbarGroups: false\n      }, extras.backstage, Optional.some(['form:']));\n    };\n    var buildContextFormGroups = function buildContextFormGroups(ctx, providers) {\n      return ContextForm.buildInitGroups(ctx, providers);\n    };\n    var buildToolbar = function buildToolbar(toolbars) {\n      var _editor$ui$registry$g2 = editor.ui.registry.getAll(),\n        buttons = _editor$ui$registry$g2.buttons;\n      var scopes = getScopes();\n      var allButtons = _objectSpread({}, buttons, scopes.formNavigators);\n      var toolbarType = getToolbarMode(editor) === ToolbarMode$1.scrolling ? ToolbarMode$1.scrolling : ToolbarMode$1.default;\n      var initGroups = flatten(map$2(toolbars, function (ctx) {\n        return ctx.type === 'contexttoolbar' ? buildContextToolbarGroups(allButtons, ctx) : buildContextFormGroups(ctx, sharedBackstage.providers);\n      }));\n      return renderToolbar({\n        type: toolbarType,\n        uid: generate$6('context-toolbar'),\n        initGroups: initGroups,\n        onEscape: Optional.none,\n        cyclicKeying: true,\n        providers: sharedBackstage.providers\n      });\n    };\n    var getAnchor = function getAnchor(position, element) {\n      var anchorage = position === 'node' ? sharedBackstage.anchors.node(element) : sharedBackstage.anchors.cursor();\n      var anchorLayout = getAnchorLayout(editor, position, isTouch(), {\n        lastElement: lastElement.get,\n        isReposition: function isReposition() {\n          return is$1(lastTrigger.get(), 0);\n        },\n        getMode: function getMode() {\n          return Positioning.getMode(sink);\n        }\n      });\n      return deepMerge(anchorage, anchorLayout);\n    };\n    var launchContext = function launchContext(toolbarApi, elem) {\n      launchContextToolbar.cancel();\n      if (!canLaunchToolbar()) {\n        return;\n      }\n      var toolbarSpec = buildToolbar(toolbarApi);\n      var position = toolbarApi[0].position;\n      var anchor = getAnchor(position, elem);\n      lastContextPosition.set(position);\n      lastTrigger.set(1);\n      var contextBarEle = contextbar.element;\n      remove$6(contextBarEle, 'display');\n      if (!isSameLaunchElement(elem)) {\n        remove$2(contextBarEle, transitionClass);\n        Positioning.reset(sink, contextbar);\n      }\n      InlineView.showWithinBounds(contextbar, wrapInPopDialog(toolbarSpec), {\n        anchor: anchor,\n        transition: {\n          classes: [transitionClass],\n          mode: 'placement'\n        }\n      }, function () {\n        return Optional.some(getBounds());\n      });\n      elem.fold(lastElement.clear, lastElement.set);\n      if (shouldContextToolbarHide()) {\n        set$8(contextBarEle, 'display', 'none');\n      }\n    };\n    var isDragging = false;\n    var launchContextToolbar = last(function () {\n      if (!editor.hasFocus() || editor.removed || isDragging) {\n        return;\n      }\n      if (has(contextbar.element, transitionClass)) {\n        launchContextToolbar.throttle();\n      } else {\n        var scopes = getScopes();\n        lookup$1(scopes, editor).fold(close, function (info) {\n          launchContext(info.toolbars, Optional.some(info.elem));\n        });\n      }\n    }, 17);\n    editor.on('init', function () {\n      editor.on('remove', close);\n      editor.on('ScrollContent ScrollWindow ObjectResized ResizeEditor longpress', hideOrRepositionIfNecessary);\n      editor.on('click keyup focus SetContent', launchContextToolbar.throttle);\n      editor.on(hideContextToolbarEvent, close);\n      editor.on(showContextToolbarEvent, function (e) {\n        var scopes = getScopes();\n        get$g(scopes.lookupTable, e.toolbarKey).each(function (ctx) {\n          launchContext([ctx], someIf(e.target !== editor, e.target));\n          InlineView.getContent(contextbar).each(Keying.focusIn);\n        });\n      });\n      editor.on('focusout', function (_e) {\n        global$9.setEditorTimeout(editor, function () {\n          if (search(sink.element).isNone() && search(contextbar.element).isNone()) {\n            close();\n          }\n        }, 0);\n      });\n      editor.on('SwitchMode', function () {\n        if (editor.mode.isReadOnly()) {\n          close();\n        }\n      });\n      editor.on('AfterProgressState', function (event) {\n        if (event.state) {\n          close();\n        } else if (editor.hasFocus()) {\n          launchContextToolbar.throttle();\n        }\n      });\n      editor.on('dragstart', function () {\n        isDragging = true;\n      });\n      editor.on('dragend drop', function () {\n        isDragging = false;\n      });\n      editor.on('NodeChange', function (_e) {\n        search(contextbar.element).fold(launchContextToolbar.throttle, noop);\n      });\n    });\n  };\n  var register$8 = function register$8(editor) {\n    var alignToolbarButtons = [{\n      name: 'alignleft',\n      text: 'Align left',\n      cmd: 'JustifyLeft',\n      icon: 'align-left'\n    }, {\n      name: 'aligncenter',\n      text: 'Align center',\n      cmd: 'JustifyCenter',\n      icon: 'align-center'\n    }, {\n      name: 'alignright',\n      text: 'Align right',\n      cmd: 'JustifyRight',\n      icon: 'align-right'\n    }, {\n      name: 'alignjustify',\n      text: 'Justify',\n      cmd: 'JustifyFull',\n      icon: 'align-justify'\n    }];\n    each$1(alignToolbarButtons, function (item) {\n      editor.ui.registry.addToggleButton(item.name, {\n        tooltip: item.text,\n        icon: item.icon,\n        onAction: onActionExecCommand(editor, item.cmd),\n        onSetup: onSetupStateToggle(editor, item.name)\n      });\n    });\n    editor.ui.registry.addButton('alignnone', {\n      tooltip: 'No alignment',\n      icon: 'align-none',\n      onSetup: onSetupEditableToggle(editor),\n      onAction: onActionExecCommand(editor, 'JustifyNone')\n    });\n  };\n  var registerController = function registerController(editor, spec) {\n    var getMenuItems = function getMenuItems() {\n      var options = spec.getOptions(editor);\n      var initial = spec.getCurrent(editor).map(spec.hash);\n      var current = value$2();\n      return map$2(options, function (value) {\n        return {\n          type: 'togglemenuitem',\n          text: spec.display(value),\n          onSetup: function onSetup(api) {\n            var setActive = function setActive(active) {\n              if (active) {\n                current.on(function (oldApi) {\n                  return oldApi.setActive(false);\n                });\n                current.set(api);\n              }\n              api.setActive(active);\n            };\n            setActive(is$1(initial, spec.hash(value)));\n            var unbindWatcher = spec.watcher(editor, value, setActive);\n            return function () {\n              current.clear();\n              unbindWatcher();\n            };\n          },\n          onAction: function onAction() {\n            return spec.setCurrent(editor, value);\n          }\n        };\n      });\n    };\n    editor.ui.registry.addMenuButton(spec.name, {\n      tooltip: spec.text,\n      icon: spec.icon,\n      fetch: function fetch(callback) {\n        return callback(getMenuItems());\n      },\n      onSetup: spec.onToolbarSetup\n    });\n    editor.ui.registry.addNestedMenuItem(spec.name, {\n      type: 'nestedmenuitem',\n      text: spec.text,\n      getSubmenuItems: getMenuItems,\n      onSetup: spec.onMenuSetup\n    });\n  };\n  var lineHeightSpec = function lineHeightSpec(editor) {\n    return {\n      name: 'lineheight',\n      text: 'Line height',\n      icon: 'line-height',\n      getOptions: getLineHeightFormats,\n      hash: function hash(input) {\n        return normalise(input, ['fixed', 'relative', 'empty']).getOr(input);\n      },\n      display: identity,\n      watcher: function watcher(editor, value, callback) {\n        return editor.formatter.formatChanged('lineheight', callback, false, {\n          value: value\n        }).unbind;\n      },\n      getCurrent: function getCurrent(editor) {\n        return Optional.from(editor.queryCommandValue('LineHeight'));\n      },\n      setCurrent: function setCurrent(editor, value) {\n        return editor.execCommand('LineHeight', false, value);\n      },\n      onToolbarSetup: onSetupEditableToggle(editor),\n      onMenuSetup: onSetupEditableToggle(editor)\n    };\n  };\n  var languageSpec = function languageSpec(editor) {\n    var settingsOpt = Optional.from(getContentLanguages(editor));\n    return settingsOpt.map(function (settings) {\n      return {\n        name: 'language',\n        text: 'Language',\n        icon: 'language',\n        getOptions: constant$1(settings),\n        hash: function hash(input) {\n          return isUndefined(input.customCode) ? input.code : \"\".concat(input.code, \"/\").concat(input.customCode);\n        },\n        display: function display(input) {\n          return input.title;\n        },\n        watcher: function watcher(editor, value, callback) {\n          var _a;\n          return editor.formatter.formatChanged('lang', callback, false, {\n            value: value.code,\n            customValue: (_a = value.customCode) !== null && _a !== void 0 ? _a : null\n          }).unbind;\n        },\n        getCurrent: function getCurrent(editor) {\n          var node = SugarElement.fromDom(editor.selection.getNode());\n          return closest$4(node, function (n) {\n            return Optional.some(n).filter(isElement$1).bind(function (ele) {\n              var codeOpt = getOpt(ele, 'lang');\n              return codeOpt.map(function (code) {\n                var customCode = getOpt(ele, 'data-mce-lang').getOrUndefined();\n                return {\n                  code: code,\n                  customCode: customCode,\n                  title: ''\n                };\n              });\n            });\n          });\n        },\n        setCurrent: function setCurrent(editor, lang) {\n          return editor.execCommand('Lang', false, lang);\n        },\n        onToolbarSetup: function onToolbarSetup(api) {\n          var unbinder = unbindable();\n          api.setActive(editor.formatter.match('lang', {}, undefined, true));\n          unbinder.set(editor.formatter.formatChanged('lang', api.setActive, true));\n          return composeUnbinders(unbinder.clear, onSetupEditableToggle(editor)(api));\n        },\n        onMenuSetup: onSetupEditableToggle(editor)\n      };\n    });\n  };\n  var register$7 = function register$7(editor) {\n    registerController(editor, lineHeightSpec(editor));\n    languageSpec(editor).each(function (spec) {\n      return registerController(editor, spec);\n    });\n  };\n  var register$6 = function register$6(editor, backstage) {\n    createAlignMenu(editor, backstage);\n    createFontFamilyMenu(editor, backstage);\n    createStylesMenu(editor, backstage);\n    createBlocksMenu(editor, backstage);\n    createFontSizeMenu(editor, backstage);\n  };\n  var onSetupOutdentState = function onSetupOutdentState(editor) {\n    return onSetupEvent(editor, 'NodeChange', function (api) {\n      api.setEnabled(editor.queryCommandState('outdent') && editor.selection.isEditable());\n    });\n  };\n  var registerButtons$2 = function registerButtons$2(editor) {\n    editor.ui.registry.addButton('outdent', {\n      tooltip: 'Decrease indent',\n      icon: 'outdent',\n      onSetup: onSetupOutdentState(editor),\n      onAction: onActionExecCommand(editor, 'outdent')\n    });\n    editor.ui.registry.addButton('indent', {\n      tooltip: 'Increase indent',\n      icon: 'indent',\n      onSetup: onSetupEditableToggle(editor),\n      onAction: onActionExecCommand(editor, 'indent')\n    });\n  };\n  var register$5 = function register$5(editor) {\n    registerButtons$2(editor);\n  };\n  var makeSetupHandler = function makeSetupHandler(editor, pasteAsText) {\n    return function (api) {\n      api.setActive(pasteAsText.get());\n      var pastePlainTextToggleHandler = function pastePlainTextToggleHandler(e) {\n        pasteAsText.set(e.state);\n        api.setActive(e.state);\n      };\n      editor.on('PastePlainTextToggle', pastePlainTextToggleHandler);\n      return composeUnbinders(function () {\n        return editor.off('PastePlainTextToggle', pastePlainTextToggleHandler);\n      }, onSetupEditableToggle(editor)(api));\n    };\n  };\n  var register$4 = function register$4(editor) {\n    var pasteAsText = Cell(getPasteAsText(editor));\n    var onAction = function onAction() {\n      return editor.execCommand('mceTogglePlainTextPaste');\n    };\n    editor.ui.registry.addToggleButton('pastetext', {\n      active: false,\n      icon: 'paste-text',\n      tooltip: 'Paste as text',\n      onAction: onAction,\n      onSetup: makeSetupHandler(editor, pasteAsText)\n    });\n    editor.ui.registry.addToggleMenuItem('pastetext', {\n      text: 'Paste as text',\n      icon: 'paste-text',\n      onAction: onAction,\n      onSetup: makeSetupHandler(editor, pasteAsText)\n    });\n  };\n  var onActionToggleFormat = function onActionToggleFormat(editor, fmt) {\n    return function () {\n      editor.execCommand('mceToggleFormat', false, fmt);\n    };\n  };\n  var registerFormatButtons = function registerFormatButtons(editor) {\n    global$1.each([{\n      name: 'bold',\n      text: 'Bold',\n      icon: 'bold'\n    }, {\n      name: 'italic',\n      text: 'Italic',\n      icon: 'italic'\n    }, {\n      name: 'underline',\n      text: 'Underline',\n      icon: 'underline'\n    }, {\n      name: 'strikethrough',\n      text: 'Strikethrough',\n      icon: 'strike-through'\n    }, {\n      name: 'subscript',\n      text: 'Subscript',\n      icon: 'subscript'\n    }, {\n      name: 'superscript',\n      text: 'Superscript',\n      icon: 'superscript'\n    }], function (btn, _idx) {\n      editor.ui.registry.addToggleButton(btn.name, {\n        tooltip: btn.text,\n        icon: btn.icon,\n        onSetup: onSetupStateToggle(editor, btn.name),\n        onAction: onActionToggleFormat(editor, btn.name)\n      });\n    });\n    for (var i = 1; i <= 6; i++) {\n      var _name3 = 'h' + i;\n      editor.ui.registry.addToggleButton(_name3, {\n        text: _name3.toUpperCase(),\n        tooltip: 'Heading ' + i,\n        onSetup: onSetupStateToggle(editor, _name3),\n        onAction: onActionToggleFormat(editor, _name3)\n      });\n    }\n  };\n  var registerCommandButtons = function registerCommandButtons(editor) {\n    global$1.each([{\n      name: 'copy',\n      text: 'Copy',\n      action: 'Copy',\n      icon: 'copy'\n    }, {\n      name: 'help',\n      text: 'Help',\n      action: 'mceHelp',\n      icon: 'help'\n    }, {\n      name: 'selectall',\n      text: 'Select all',\n      action: 'SelectAll',\n      icon: 'select-all'\n    }, {\n      name: 'newdocument',\n      text: 'New document',\n      action: 'mceNewDocument',\n      icon: 'new-document'\n    }, {\n      name: 'print',\n      text: 'Print',\n      action: 'mcePrint',\n      icon: 'print'\n    }], function (btn) {\n      editor.ui.registry.addButton(btn.name, {\n        tooltip: btn.text,\n        icon: btn.icon,\n        onAction: onActionExecCommand(editor, btn.action)\n      });\n    });\n    global$1.each([{\n      name: 'cut',\n      text: 'Cut',\n      action: 'Cut',\n      icon: 'cut'\n    }, {\n      name: 'paste',\n      text: 'Paste',\n      action: 'Paste',\n      icon: 'paste'\n    }, {\n      name: 'removeformat',\n      text: 'Clear formatting',\n      action: 'RemoveFormat',\n      icon: 'remove-formatting'\n    }, {\n      name: 'remove',\n      text: 'Remove',\n      action: 'Delete',\n      icon: 'remove'\n    }, {\n      name: 'hr',\n      text: 'Horizontal line',\n      action: 'InsertHorizontalRule',\n      icon: 'horizontal-rule'\n    }], function (btn) {\n      editor.ui.registry.addButton(btn.name, {\n        tooltip: btn.text,\n        icon: btn.icon,\n        onSetup: onSetupEditableToggle(editor),\n        onAction: onActionExecCommand(editor, btn.action)\n      });\n    });\n  };\n  var registerCommandToggleButtons = function registerCommandToggleButtons(editor) {\n    global$1.each([{\n      name: 'blockquote',\n      text: 'Blockquote',\n      action: 'mceBlockQuote',\n      icon: 'quote'\n    }], function (btn) {\n      editor.ui.registry.addToggleButton(btn.name, {\n        tooltip: btn.text,\n        icon: btn.icon,\n        onAction: onActionExecCommand(editor, btn.action),\n        onSetup: onSetupStateToggle(editor, btn.name)\n      });\n    });\n  };\n  var registerButtons$1 = function registerButtons$1(editor) {\n    registerFormatButtons(editor);\n    registerCommandButtons(editor);\n    registerCommandToggleButtons(editor);\n  };\n  var registerMenuItems$2 = function registerMenuItems$2(editor) {\n    global$1.each([{\n      name: 'newdocument',\n      text: 'New document',\n      action: 'mceNewDocument',\n      icon: 'new-document'\n    }, {\n      name: 'copy',\n      text: 'Copy',\n      action: 'Copy',\n      icon: 'copy',\n      shortcut: 'Meta+C'\n    }, {\n      name: 'selectall',\n      text: 'Select all',\n      action: 'SelectAll',\n      icon: 'select-all',\n      shortcut: 'Meta+A'\n    }, {\n      name: 'print',\n      text: 'Print...',\n      action: 'mcePrint',\n      icon: 'print',\n      shortcut: 'Meta+P'\n    }], function (menuitem) {\n      editor.ui.registry.addMenuItem(menuitem.name, {\n        text: menuitem.text,\n        icon: menuitem.icon,\n        shortcut: menuitem.shortcut,\n        onAction: onActionExecCommand(editor, menuitem.action)\n      });\n    });\n    global$1.each([{\n      name: 'bold',\n      text: 'Bold',\n      action: 'Bold',\n      icon: 'bold',\n      shortcut: 'Meta+B'\n    }, {\n      name: 'italic',\n      text: 'Italic',\n      action: 'Italic',\n      icon: 'italic',\n      shortcut: 'Meta+I'\n    }, {\n      name: 'underline',\n      text: 'Underline',\n      action: 'Underline',\n      icon: 'underline',\n      shortcut: 'Meta+U'\n    }, {\n      name: 'strikethrough',\n      text: 'Strikethrough',\n      action: 'Strikethrough',\n      icon: 'strike-through'\n    }, {\n      name: 'subscript',\n      text: 'Subscript',\n      action: 'Subscript',\n      icon: 'subscript'\n    }, {\n      name: 'superscript',\n      text: 'Superscript',\n      action: 'Superscript',\n      icon: 'superscript'\n    }, {\n      name: 'removeformat',\n      text: 'Clear formatting',\n      action: 'RemoveFormat',\n      icon: 'remove-formatting'\n    }, {\n      name: 'cut',\n      text: 'Cut',\n      action: 'Cut',\n      icon: 'cut',\n      shortcut: 'Meta+X'\n    }, {\n      name: 'paste',\n      text: 'Paste',\n      action: 'Paste',\n      icon: 'paste',\n      shortcut: 'Meta+V'\n    }, {\n      name: 'hr',\n      text: 'Horizontal line',\n      action: 'InsertHorizontalRule',\n      icon: 'horizontal-rule'\n    }], function (menuitem) {\n      editor.ui.registry.addMenuItem(menuitem.name, {\n        text: menuitem.text,\n        icon: menuitem.icon,\n        shortcut: menuitem.shortcut,\n        onSetup: onSetupEditableToggle(editor),\n        onAction: onActionExecCommand(editor, menuitem.action)\n      });\n    });\n    editor.ui.registry.addMenuItem('codeformat', {\n      text: 'Code',\n      icon: 'sourcecode',\n      onSetup: onSetupEditableToggle(editor),\n      onAction: onActionToggleFormat(editor, 'code')\n    });\n  };\n  var register$3 = function register$3(editor) {\n    registerButtons$1(editor);\n    registerMenuItems$2(editor);\n  };\n  var onSetupUndoRedoState = function onSetupUndoRedoState(editor, type) {\n    return onSetupEvent(editor, 'Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', function (api) {\n      api.setEnabled(!editor.mode.isReadOnly() && editor.undoManager[type]());\n    });\n  };\n  var registerMenuItems$1 = function registerMenuItems$1(editor) {\n    editor.ui.registry.addMenuItem('undo', {\n      text: 'Undo',\n      icon: 'undo',\n      shortcut: 'Meta+Z',\n      onSetup: onSetupUndoRedoState(editor, 'hasUndo'),\n      onAction: onActionExecCommand(editor, 'undo')\n    });\n    editor.ui.registry.addMenuItem('redo', {\n      text: 'Redo',\n      icon: 'redo',\n      shortcut: 'Meta+Y',\n      onSetup: onSetupUndoRedoState(editor, 'hasRedo'),\n      onAction: onActionExecCommand(editor, 'redo')\n    });\n  };\n  var registerButtons = function registerButtons(editor) {\n    editor.ui.registry.addButton('undo', {\n      tooltip: 'Undo',\n      icon: 'undo',\n      enabled: false,\n      onSetup: onSetupUndoRedoState(editor, 'hasUndo'),\n      onAction: onActionExecCommand(editor, 'undo')\n    });\n    editor.ui.registry.addButton('redo', {\n      tooltip: 'Redo',\n      icon: 'redo',\n      enabled: false,\n      onSetup: onSetupUndoRedoState(editor, 'hasRedo'),\n      onAction: onActionExecCommand(editor, 'redo')\n    });\n  };\n  var register$2 = function register$2(editor) {\n    registerMenuItems$1(editor);\n    registerButtons(editor);\n  };\n  var onSetupVisualAidState = function onSetupVisualAidState(editor) {\n    return onSetupEvent(editor, 'VisualAid', function (api) {\n      api.setActive(editor.hasVisual);\n    });\n  };\n  var registerMenuItems = function registerMenuItems(editor) {\n    editor.ui.registry.addToggleMenuItem('visualaid', {\n      text: 'Visual aids',\n      onSetup: onSetupVisualAidState(editor),\n      onAction: onActionExecCommand(editor, 'mceToggleVisualAid')\n    });\n  };\n  var registerToolbarButton = function registerToolbarButton(editor) {\n    editor.ui.registry.addButton('visualaid', {\n      tooltip: 'Visual aids',\n      text: 'Visual aids',\n      onAction: onActionExecCommand(editor, 'mceToggleVisualAid')\n    });\n  };\n  var register$1 = function register$1(editor) {\n    registerToolbarButton(editor);\n    registerMenuItems(editor);\n  };\n  var setup$6 = function setup$6(editor, backstage) {\n    register$8(editor);\n    register$3(editor);\n    register$6(editor, backstage);\n    register$2(editor);\n    register$c(editor);\n    register$1(editor);\n    register$5(editor);\n    register$7(editor);\n    register$4(editor);\n  };\n  var patchPipeConfig = function patchPipeConfig(config) {\n    return isString(config) ? config.split(/[ ,]/) : config;\n  };\n  var option = function option(name) {\n    return function (editor) {\n      return editor.options.get(name);\n    };\n  };\n  var register = function register(editor) {\n    var registerOption = editor.options.register;\n    registerOption('contextmenu_avoid_overlap', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('contextmenu_never_use_native', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('contextmenu', {\n      processor: function processor(value) {\n        if (value === false) {\n          return {\n            value: [],\n            valid: true\n          };\n        } else if (isString(value) || isArrayOf(value, isString)) {\n          return {\n            value: patchPipeConfig(value),\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be false or a string.'\n          };\n        }\n      },\n      default: 'link linkchecker image editimage table spellchecker configurepermanentpen'\n    });\n  };\n  var shouldNeverUseNative = option('contextmenu_never_use_native');\n  var getAvoidOverlapSelector = option('contextmenu_avoid_overlap');\n  var isContextMenuDisabled = function isContextMenuDisabled(editor) {\n    return getContextMenu(editor).length === 0;\n  };\n  var getContextMenu = function getContextMenu(editor) {\n    var contextMenus = editor.ui.registry.getAll().contextMenus;\n    var contextMenu = editor.options.get('contextmenu');\n    if (editor.options.isSet('contextmenu')) {\n      return contextMenu;\n    } else {\n      return filter$2(contextMenu, function (item) {\n        return has$2(contextMenus, item);\n      });\n    }\n  };\n  var nu = function nu(x, y) {\n    return {\n      type: 'makeshift',\n      x: x,\n      y: y\n    };\n  };\n  var transpose = function transpose(pos, dx, dy) {\n    return nu(pos.x + dx, pos.y + dy);\n  };\n  var isTouchEvent$1 = function isTouchEvent$1(e) {\n    return e.type === 'longpress' || e.type.indexOf('touch') === 0;\n  };\n  var fromPageXY = function fromPageXY(e) {\n    if (isTouchEvent$1(e)) {\n      var _touch = e.touches[0];\n      return nu(_touch.pageX, _touch.pageY);\n    } else {\n      return nu(e.pageX, e.pageY);\n    }\n  };\n  var fromClientXY = function fromClientXY(e) {\n    if (isTouchEvent$1(e)) {\n      var _touch2 = e.touches[0];\n      return nu(_touch2.clientX, _touch2.clientY);\n    } else {\n      return nu(e.clientX, e.clientY);\n    }\n  };\n  var transposeContentAreaContainer = function transposeContentAreaContainer(element, pos) {\n    var containerPos = global$7.DOM.getPos(element);\n    return transpose(pos, containerPos.x, containerPos.y);\n  };\n  var getPointAnchor = function getPointAnchor(editor, e) {\n    if (e.type === 'contextmenu' || e.type === 'longpress') {\n      if (editor.inline) {\n        return fromPageXY(e);\n      } else {\n        return transposeContentAreaContainer(editor.getContentAreaContainer(), fromClientXY(e));\n      }\n    } else {\n      return getSelectionAnchor(editor);\n    }\n  };\n  var getSelectionAnchor = function getSelectionAnchor(editor) {\n    return {\n      type: 'selection',\n      root: SugarElement.fromDom(editor.selection.getNode())\n    };\n  };\n  var getNodeAnchor = function getNodeAnchor(editor) {\n    return {\n      type: 'node',\n      node: Optional.some(SugarElement.fromDom(editor.selection.getNode())),\n      root: SugarElement.fromDom(editor.getBody())\n    };\n  };\n  var getAnchorSpec$1 = function getAnchorSpec$1(editor, e, anchorType) {\n    switch (anchorType) {\n      case 'node':\n        return getNodeAnchor(editor);\n      case 'point':\n        return getPointAnchor(editor, e);\n      case 'selection':\n        return getSelectionAnchor(editor);\n    }\n  };\n  var initAndShow$1 = function initAndShow$1(editor, e, buildMenu, backstage, contextmenu, anchorType) {\n    var items = buildMenu();\n    var anchorSpec = getAnchorSpec$1(editor, e, anchorType);\n    build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {\n      isHorizontalMenu: false,\n      search: Optional.none()\n    }).map(function (menuData) {\n      e.preventDefault();\n      InlineView.showMenuAt(contextmenu, {\n        anchor: anchorSpec\n      }, {\n        menu: {\n          markers: markers('normal')\n        },\n        data: menuData\n      });\n    });\n  };\n  var layouts = {\n    onLtr: function onLtr() {\n      return [south$2, southeast$2, southwest$2, northeast$2, northwest$2, north$2, north, south, northeast, southeast, northwest, southwest];\n    },\n    onRtl: function onRtl() {\n      return [south$2, southwest$2, southeast$2, northwest$2, northeast$2, north$2, north, south, northwest, southwest, northeast, southeast];\n    }\n  };\n  var bubbleSize = 12;\n  var bubbleAlignments = {\n    valignCentre: [],\n    alignCentre: [],\n    alignLeft: ['tox-pop--align-left'],\n    alignRight: ['tox-pop--align-right'],\n    right: ['tox-pop--right'],\n    left: ['tox-pop--left'],\n    bottom: ['tox-pop--bottom'],\n    top: ['tox-pop--top']\n  };\n  var isTouchWithinSelection = function isTouchWithinSelection(editor, e) {\n    var selection = editor.selection;\n    if (selection.isCollapsed() || e.touches.length < 1) {\n      return false;\n    } else {\n      var _touch3 = e.touches[0];\n      var rng = selection.getRng();\n      var rngRectOpt = getFirstRect(editor.getWin(), SimSelection.domRange(rng));\n      return rngRectOpt.exists(function (rngRect) {\n        return rngRect.left <= _touch3.clientX && rngRect.right >= _touch3.clientX && rngRect.top <= _touch3.clientY && rngRect.bottom >= _touch3.clientY;\n      });\n    }\n  };\n  var setupiOSOverrides = function setupiOSOverrides(editor) {\n    var originalSelection = editor.selection.getRng();\n    var selectionReset = function selectionReset() {\n      global$9.setEditorTimeout(editor, function () {\n        editor.selection.setRng(originalSelection);\n      }, 10);\n      unbindEventListeners();\n    };\n    editor.once('touchend', selectionReset);\n    var preventMousedown = function preventMousedown(e) {\n      e.preventDefault();\n      e.stopImmediatePropagation();\n    };\n    editor.on('mousedown', preventMousedown, true);\n    var clearSelectionReset = function clearSelectionReset() {\n      return unbindEventListeners();\n    };\n    editor.once('longpresscancel', clearSelectionReset);\n    var unbindEventListeners = function unbindEventListeners() {\n      editor.off('touchend', selectionReset);\n      editor.off('longpresscancel', clearSelectionReset);\n      editor.off('mousedown', preventMousedown);\n    };\n  };\n  var getAnchorSpec = function getAnchorSpec(editor, e, anchorType) {\n    var anchorSpec = getAnchorSpec$1(editor, e, anchorType);\n    var bubbleYOffset = anchorType === 'point' ? bubbleSize : 0;\n    return _objectSpread({\n      bubble: nu$5(0, bubbleYOffset, bubbleAlignments),\n      layouts: layouts,\n      overrides: {\n        maxWidthFunction: expandable(),\n        maxHeightFunction: expandable$1()\n      }\n    }, anchorSpec);\n  };\n  var show = function show(editor, e, items, backstage, contextmenu, anchorType, highlightImmediately) {\n    var anchorSpec = getAnchorSpec(editor, e, anchorType);\n    build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {\n      isHorizontalMenu: true,\n      search: Optional.none()\n    }).map(function (menuData) {\n      e.preventDefault();\n      var highlightOnOpen = highlightImmediately ? HighlightOnOpen.HighlightMenuAndItem : HighlightOnOpen.HighlightNone;\n      InlineView.showMenuWithinBounds(contextmenu, {\n        anchor: anchorSpec\n      }, {\n        menu: {\n          markers: markers('normal'),\n          highlightOnOpen: highlightOnOpen\n        },\n        data: menuData,\n        type: 'horizontal'\n      }, function () {\n        return Optional.some(getContextToolbarBounds(editor, backstage.shared, anchorType === 'node' ? 'node' : 'selection'));\n      });\n      editor.dispatch(hideContextToolbarEvent);\n    });\n  };\n  var initAndShow = function initAndShow(editor, e, buildMenu, backstage, contextmenu, anchorType) {\n    var detection = detect$2();\n    var isiOS = detection.os.isiOS();\n    var isMacOS = detection.os.isMacOS();\n    var isAndroid = detection.os.isAndroid();\n    var isTouch = detection.deviceType.isTouch();\n    var shouldHighlightImmediately = function shouldHighlightImmediately() {\n      return !(isAndroid || isiOS || isMacOS && isTouch);\n    };\n    var open = function open() {\n      var items = buildMenu();\n      show(editor, e, items, backstage, contextmenu, anchorType, shouldHighlightImmediately());\n    };\n    if ((isMacOS || isiOS) && anchorType !== 'node') {\n      var openiOS = function openiOS() {\n        setupiOSOverrides(editor);\n        open();\n      };\n      if (isTouchWithinSelection(editor, e)) {\n        openiOS();\n      } else {\n        editor.once('selectionchange', openiOS);\n        editor.once('touchend', function () {\n          return editor.off('selectionchange', openiOS);\n        });\n      }\n    } else {\n      open();\n    }\n  };\n  var isSeparator = function isSeparator(item) {\n    return isString(item) ? item === '|' : item.type === 'separator';\n  };\n  var separator = {\n    type: 'separator'\n  };\n  var makeContextItem = function makeContextItem(item) {\n    var commonMenuItem = function commonMenuItem(item) {\n      return {\n        text: item.text,\n        icon: item.icon,\n        enabled: item.enabled,\n        shortcut: item.shortcut\n      };\n    };\n    if (isString(item)) {\n      return item;\n    } else {\n      switch (item.type) {\n        case 'separator':\n          return separator;\n        case 'submenu':\n          return _objectSpread({\n            type: 'nestedmenuitem'\n          }, commonMenuItem(item), {\n            getSubmenuItems: function getSubmenuItems() {\n              var items = item.getSubmenuItems();\n              if (isString(items)) {\n                return items;\n              } else {\n                return map$2(items, makeContextItem);\n              }\n            }\n          });\n        default:\n          var commonItem = item;\n          return _objectSpread({\n            type: 'menuitem'\n          }, commonMenuItem(commonItem), {\n            onAction: noarg(commonItem.onAction)\n          });\n      }\n    }\n  };\n  var addContextMenuGroup = function addContextMenuGroup(xs, groupItems) {\n    if (groupItems.length === 0) {\n      return xs;\n    }\n    var lastMenuItem = last$1(xs).filter(function (item) {\n      return !isSeparator(item);\n    });\n    var before = lastMenuItem.fold(function () {\n      return [];\n    }, function (_) {\n      return [separator];\n    });\n    return xs.concat(before).concat(groupItems).concat([separator]);\n  };\n  var generateContextMenu = function generateContextMenu(contextMenus, menuConfig, selectedElement) {\n    var sections = foldl(menuConfig, function (acc, name) {\n      return get$g(contextMenus, name.toLowerCase()).map(function (menu) {\n        var items = menu.update(selectedElement);\n        if (isString(items) && isNotEmpty(trim$1(items))) {\n          return addContextMenuGroup(acc, items.split(' '));\n        } else if (isArray(items) && items.length > 0) {\n          var allItems = map$2(items, makeContextItem);\n          return addContextMenuGroup(acc, allItems);\n        } else {\n          return acc;\n        }\n      }).getOrThunk(function () {\n        return acc.concat([name]);\n      });\n    }, []);\n    if (sections.length > 0 && isSeparator(sections[sections.length - 1])) {\n      sections.pop();\n    }\n    return sections;\n  };\n  var isNativeOverrideKeyEvent = function isNativeOverrideKeyEvent(editor, e) {\n    return e.ctrlKey && !shouldNeverUseNative(editor);\n  };\n  var isTouchEvent = function isTouchEvent(e) {\n    return e.type === 'longpress' || has$2(e, 'touches');\n  };\n  var isTriggeredByKeyboard = function isTriggeredByKeyboard(editor, e) {\n    return !isTouchEvent(e) && (e.button !== 2 || e.target === editor.getBody() && e.pointerType === '');\n  };\n  var getSelectedElement = function getSelectedElement(editor, e) {\n    return isTriggeredByKeyboard(editor, e) ? editor.selection.getStart(true) : e.target;\n  };\n  var getAnchorType = function getAnchorType(editor, e) {\n    var selector = getAvoidOverlapSelector(editor);\n    var anchorType = isTriggeredByKeyboard(editor, e) ? 'selection' : 'point';\n    if (isNotEmpty(selector)) {\n      var target = getSelectedElement(editor, e);\n      var selectorExists = closest(SugarElement.fromDom(target), selector);\n      return selectorExists ? 'node' : anchorType;\n    } else {\n      return anchorType;\n    }\n  };\n  var setup$5 = function setup$5(editor, lazySink, backstage) {\n    var detection = detect$2();\n    var isTouch = detection.deviceType.isTouch;\n    var contextmenu = build$1(InlineView.sketch({\n      dom: {\n        tag: 'div'\n      },\n      lazySink: lazySink,\n      onEscape: function onEscape() {\n        return editor.focus();\n      },\n      onShow: function onShow() {\n        return backstage.setContextMenuState(true);\n      },\n      onHide: function onHide() {\n        return backstage.setContextMenuState(false);\n      },\n      fireDismissalEventInstead: {},\n      inlineBehaviours: derive$1([config('dismissContextMenu', [run$1(dismissRequested(), function (comp, _se) {\n        Sandboxing.close(comp);\n        editor.focus();\n      })])])\n    }));\n    var hideContextMenu = function hideContextMenu() {\n      return InlineView.hide(contextmenu);\n    };\n    var showContextMenu = function showContextMenu(e) {\n      if (shouldNeverUseNative(editor)) {\n        e.preventDefault();\n      }\n      if (isNativeOverrideKeyEvent(editor, e) || isContextMenuDisabled(editor)) {\n        return;\n      }\n      var anchorType = getAnchorType(editor, e);\n      var buildMenu = function buildMenu() {\n        var selectedElement = getSelectedElement(editor, e);\n        var registry = editor.ui.registry.getAll();\n        var menuConfig = getContextMenu(editor);\n        return generateContextMenu(registry.contextMenus, menuConfig, selectedElement);\n      };\n      var initAndShow$2 = isTouch() ? initAndShow : initAndShow$1;\n      initAndShow$2(editor, e, buildMenu, backstage, contextmenu, anchorType);\n    };\n    editor.on('init', function () {\n      var hideEvents = 'ResizeEditor ScrollContent ScrollWindow longpresscancel' + (isTouch() ? '' : ' ResizeWindow');\n      editor.on(hideEvents, hideContextMenu);\n      editor.on('longpress contextmenu', showContextMenu);\n    });\n  };\n  var adt = Adt.generate([{\n    offset: ['x', 'y']\n  }, {\n    absolute: ['x', 'y']\n  }, {\n    fixed: ['x', 'y']\n  }]);\n  var subtract = function subtract(change) {\n    return function (point) {\n      return point.translate(-change.left, -change.top);\n    };\n  };\n  var add = function add(change) {\n    return function (point) {\n      return point.translate(change.left, change.top);\n    };\n  };\n  var transform = function transform(changes) {\n    return function (x, y) {\n      return foldl(changes, function (rest, f) {\n        return f(rest);\n      }, SugarPosition(x, y));\n    };\n  };\n  var asFixed = function asFixed(coord, scroll, origin) {\n    return coord.fold(transform([add(origin), subtract(scroll)]), transform([subtract(scroll)]), transform([]));\n  };\n  var asAbsolute = function asAbsolute(coord, scroll, origin) {\n    return coord.fold(transform([add(origin)]), transform([]), transform([add(scroll)]));\n  };\n  var asOffset = function asOffset(coord, scroll, origin) {\n    return coord.fold(transform([]), transform([subtract(origin)]), transform([add(scroll), subtract(origin)]));\n  };\n  var withinRange = function withinRange(coord1, coord2, xRange, yRange, scroll, origin) {\n    var a1 = asAbsolute(coord1, scroll, origin);\n    var a2 = asAbsolute(coord2, scroll, origin);\n    return Math.abs(a1.left - a2.left) <= xRange && Math.abs(a1.top - a2.top) <= yRange;\n  };\n  var getDeltas = function getDeltas(coord1, coord2, xRange, yRange, scroll, origin) {\n    var a1 = asAbsolute(coord1, scroll, origin);\n    var a2 = asAbsolute(coord2, scroll, origin);\n    var left = Math.abs(a1.left - a2.left);\n    var top = Math.abs(a1.top - a2.top);\n    return SugarPosition(left, top);\n  };\n  var toStyles = function toStyles(coord, scroll, origin) {\n    var stylesOpt = coord.fold(function (x, y) {\n      return {\n        position: Optional.some('absolute'),\n        left: Optional.some(x + 'px'),\n        top: Optional.some(y + 'px')\n      };\n    }, function (x, y) {\n      return {\n        position: Optional.some('absolute'),\n        left: Optional.some(x - origin.left + 'px'),\n        top: Optional.some(y - origin.top + 'px')\n      };\n    }, function (x, y) {\n      return {\n        position: Optional.some('fixed'),\n        left: Optional.some(x + 'px'),\n        top: Optional.some(y + 'px')\n      };\n    });\n    return _objectSpread({\n      right: Optional.none(),\n      bottom: Optional.none()\n    }, stylesOpt);\n  };\n  var translate = function translate(coord, deltaX, deltaY) {\n    return coord.fold(function (x, y) {\n      return offset(x + deltaX, y + deltaY);\n    }, function (x, y) {\n      return absolute(x + deltaX, y + deltaY);\n    }, function (x, y) {\n      return fixed(x + deltaX, y + deltaY);\n    });\n  };\n  var absorb = function absorb(partialCoord, originalCoord, scroll, origin) {\n    var absorbOne = function absorbOne(stencil, nu) {\n      return function (optX, optY) {\n        var original = stencil(originalCoord, scroll, origin);\n        return nu(optX.getOr(original.left), optY.getOr(original.top));\n      };\n    };\n    return partialCoord.fold(absorbOne(asOffset, offset), absorbOne(asAbsolute, absolute), absorbOne(asFixed, fixed));\n  };\n  var offset = adt.offset;\n  var absolute = adt.absolute;\n  var fixed = adt.fixed;\n  var parseAttrToInt = function parseAttrToInt(element, name) {\n    var value = get$f(element, name);\n    return isUndefined(value) ? NaN : parseInt(value, 10);\n  };\n  var get = function get(component, snapsInfo) {\n    var element = component.element;\n    var x = parseAttrToInt(element, snapsInfo.leftAttr);\n    var y = parseAttrToInt(element, snapsInfo.topAttr);\n    return isNaN(x) || isNaN(y) ? Optional.none() : Optional.some(SugarPosition(x, y));\n  };\n  var set = function set(component, snapsInfo, pt) {\n    var element = component.element;\n    set$9(element, snapsInfo.leftAttr, pt.left + 'px');\n    set$9(element, snapsInfo.topAttr, pt.top + 'px');\n  };\n  var clear = function clear(component, snapsInfo) {\n    var element = component.element;\n    remove$7(element, snapsInfo.leftAttr);\n    remove$7(element, snapsInfo.topAttr);\n  };\n  var getCoords = function getCoords(component, snapInfo, coord, delta) {\n    return get(component, snapInfo).fold(function () {\n      return coord;\n    }, function (fixed$1) {\n      return fixed(fixed$1.left + delta.left, fixed$1.top + delta.top);\n    });\n  };\n  var moveOrSnap = function moveOrSnap(component, snapInfo, coord, delta, scroll, origin) {\n    var newCoord = getCoords(component, snapInfo, coord, delta);\n    var snap = snapInfo.mustSnap ? findClosestSnap(component, snapInfo, newCoord, scroll, origin) : findSnap(component, snapInfo, newCoord, scroll, origin);\n    var fixedCoord = asFixed(newCoord, scroll, origin);\n    set(component, snapInfo, fixedCoord);\n    return snap.fold(function () {\n      return {\n        coord: fixed(fixedCoord.left, fixedCoord.top),\n        extra: Optional.none()\n      };\n    }, function (spanned) {\n      return {\n        coord: spanned.output,\n        extra: spanned.extra\n      };\n    });\n  };\n  var stopDrag = function stopDrag(component, snapInfo) {\n    clear(component, snapInfo);\n  };\n  var findMatchingSnap = function findMatchingSnap(snaps, newCoord, scroll, origin) {\n    return findMap(snaps, function (snap) {\n      var sensor = snap.sensor;\n      var inRange = withinRange(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);\n      return inRange ? Optional.some({\n        output: absorb(snap.output, newCoord, scroll, origin),\n        extra: snap.extra\n      }) : Optional.none();\n    });\n  };\n  var findClosestSnap = function findClosestSnap(component, snapInfo, newCoord, scroll, origin) {\n    var snaps = snapInfo.getSnapPoints(component);\n    var matchSnap = findMatchingSnap(snaps, newCoord, scroll, origin);\n    return matchSnap.orThunk(function () {\n      var bestSnap = foldl(snaps, function (acc, snap) {\n        var sensor = snap.sensor;\n        var deltas = getDeltas(newCoord, sensor, snap.range.left, snap.range.top, scroll, origin);\n        return acc.deltas.fold(function () {\n          return {\n            deltas: Optional.some(deltas),\n            snap: Optional.some(snap)\n          };\n        }, function (bestDeltas) {\n          var currAvg = (deltas.left + deltas.top) / 2;\n          var bestAvg = (bestDeltas.left + bestDeltas.top) / 2;\n          if (currAvg <= bestAvg) {\n            return {\n              deltas: Optional.some(deltas),\n              snap: Optional.some(snap)\n            };\n          } else {\n            return acc;\n          }\n        });\n      }, {\n        deltas: Optional.none(),\n        snap: Optional.none()\n      });\n      return bestSnap.snap.map(function (snap) {\n        return {\n          output: absorb(snap.output, newCoord, scroll, origin),\n          extra: snap.extra\n        };\n      });\n    });\n  };\n  var findSnap = function findSnap(component, snapInfo, newCoord, scroll, origin) {\n    var snaps = snapInfo.getSnapPoints(component);\n    return findMatchingSnap(snaps, newCoord, scroll, origin);\n  };\n  var snapTo$1 = function snapTo$1(snap, scroll, origin) {\n    return {\n      coord: absorb(snap.output, snap.output, scroll, origin),\n      extra: snap.extra\n    };\n  };\n  var snapTo = function snapTo(component, dragConfig, _state, snap) {\n    var target = dragConfig.getTarget(component.element);\n    if (dragConfig.repositionTarget) {\n      var doc = owner$4(component.element);\n      var scroll = get$b(doc);\n      var origin = getOrigin(target);\n      var snapPin = snapTo$1(snap, scroll, origin);\n      var styles = toStyles(snapPin.coord, scroll, origin);\n      setOptions(target, styles);\n    }\n  };\n  var DraggingApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    snapTo: snapTo\n  });\n  var initialAttribute = 'data-initial-z-index';\n  var resetZIndex = function resetZIndex(blocker) {\n    parent(blocker.element).filter(isElement$1).each(function (root) {\n      getOpt(root, initialAttribute).fold(function () {\n        return remove$6(root, 'z-index');\n      }, function (zIndex) {\n        return set$8(root, 'z-index', zIndex);\n      });\n      remove$7(root, initialAttribute);\n    });\n  };\n  var changeZIndex = function changeZIndex(blocker) {\n    parent(blocker.element).filter(isElement$1).each(function (root) {\n      getRaw(root, 'z-index').each(function (zindex) {\n        set$9(root, initialAttribute, zindex);\n      });\n      set$8(root, 'z-index', get$e(blocker.element, 'z-index'));\n    });\n  };\n  var instigate = function instigate(anyComponent, blocker) {\n    anyComponent.getSystem().addToGui(blocker);\n    changeZIndex(blocker);\n  };\n  var discard = function discard(blocker) {\n    resetZIndex(blocker);\n    blocker.getSystem().removeFromGui(blocker);\n  };\n  var createComponent = function createComponent(component, blockerClass, blockerEvents) {\n    return component.getSystem().build(Container.sketch({\n      dom: {\n        styles: {\n          'left': '0px',\n          'top': '0px',\n          'width': '100%',\n          'height': '100%',\n          'position': 'fixed',\n          'z-index': '1000000000000000'\n        },\n        classes: [blockerClass]\n      },\n      events: blockerEvents\n    }));\n  };\n  var SnapSchema = optionObjOf('snaps', [required$1('getSnapPoints'), onHandler('onSensor'), required$1('leftAttr'), required$1('topAttr'), defaulted('lazyViewport', win), defaulted('mustSnap', false)]);\n  var schema$6 = [defaulted('useFixed', never), required$1('blockerClass'), defaulted('getTarget', identity), defaulted('onDrag', noop), defaulted('repositionTarget', true), defaulted('onDrop', noop), defaultedFunction('getBounds', win), SnapSchema];\n  var getCurrentCoord = function getCurrentCoord(target) {\n    return lift3(getRaw(target, 'left'), getRaw(target, 'top'), getRaw(target, 'position'), function (left, top, position) {\n      var nu = position === 'fixed' ? fixed : offset;\n      return nu(parseInt(left, 10), parseInt(top, 10));\n    }).getOrThunk(function () {\n      var location = absolute$3(target);\n      return absolute(location.left, location.top);\n    });\n  };\n  var clampCoords = function clampCoords(component, coords, scroll, origin, startData) {\n    var bounds = startData.bounds;\n    var absoluteCoord = asAbsolute(coords, scroll, origin);\n    var newX = clamp(absoluteCoord.left, bounds.x, bounds.x + bounds.width - startData.width);\n    var newY = clamp(absoluteCoord.top, bounds.y, bounds.y + bounds.height - startData.height);\n    var newCoords = absolute(newX, newY);\n    return coords.fold(function () {\n      var offset$1 = asOffset(newCoords, scroll, origin);\n      return offset(offset$1.left, offset$1.top);\n    }, constant$1(newCoords), function () {\n      var fixed$1 = asFixed(newCoords, scroll, origin);\n      return fixed(fixed$1.left, fixed$1.top);\n    });\n  };\n  var calcNewCoord = function calcNewCoord(component, optSnaps, currentCoord, scroll, origin, delta, startData) {\n    var newCoord = optSnaps.fold(function () {\n      var translated = translate(currentCoord, delta.left, delta.top);\n      var fixedCoord = asFixed(translated, scroll, origin);\n      return fixed(fixedCoord.left, fixedCoord.top);\n    }, function (snapInfo) {\n      var snapping = moveOrSnap(component, snapInfo, currentCoord, delta, scroll, origin);\n      snapping.extra.each(function (extra) {\n        snapInfo.onSensor(component, extra);\n      });\n      return snapping.coord;\n    });\n    return clampCoords(component, newCoord, scroll, origin, startData);\n  };\n  var dragBy = function dragBy(component, dragConfig, startData, delta) {\n    var target = dragConfig.getTarget(component.element);\n    if (dragConfig.repositionTarget) {\n      var doc = owner$4(component.element);\n      var scroll = get$b(doc);\n      var origin = getOrigin(target);\n      var currentCoord = getCurrentCoord(target);\n      var newCoord = calcNewCoord(component, dragConfig.snaps, currentCoord, scroll, origin, delta, startData);\n      var styles = toStyles(newCoord, scroll, origin);\n      setOptions(target, styles);\n    }\n    dragConfig.onDrag(component, target, delta);\n  };\n  var calcStartData = function calcStartData(dragConfig, comp) {\n    return {\n      bounds: dragConfig.getBounds(),\n      height: getOuter$2(comp.element),\n      width: getOuter$1(comp.element)\n    };\n  };\n  var _move = function move(component, dragConfig, dragState, dragMode, event) {\n    var delta = dragState.update(dragMode, event);\n    var dragStartData = dragState.getStartData().getOrThunk(function () {\n      return calcStartData(dragConfig, component);\n    });\n    delta.each(function (dlt) {\n      dragBy(component, dragConfig, dragStartData, dlt);\n    });\n  };\n  var stop = function stop(component, blocker, dragConfig, dragState) {\n    blocker.each(discard);\n    dragConfig.snaps.each(function (snapInfo) {\n      stopDrag(component, snapInfo);\n    });\n    var target = dragConfig.getTarget(component.element);\n    dragState.reset();\n    dragConfig.onDrop(component, target);\n  };\n  var handlers = function handlers(events) {\n    return function (dragConfig, dragState) {\n      var updateStartState = function updateStartState(comp) {\n        dragState.setStartData(calcStartData(dragConfig, comp));\n      };\n      return derive$2([run$1(windowScroll(), function (comp) {\n        dragState.getStartData().each(function () {\n          return updateStartState(comp);\n        });\n      })].concat(_toConsumableArray(events(dragConfig, dragState, updateStartState))));\n    };\n  };\n  var init$3 = function init$3(dragApi) {\n    return derive$2([run$1(mousedown(), dragApi.forceDrop), run$1(mouseup(), dragApi.drop), run$1(mousemove(), function (comp, simulatedEvent) {\n      dragApi.move(simulatedEvent.event);\n    }), run$1(mouseout(), dragApi.delayDrop)]);\n  };\n  var getData$1 = function getData$1(event) {\n    return Optional.from(SugarPosition(event.x, event.y));\n  };\n  var getDelta$1 = function getDelta$1(old, nu) {\n    return SugarPosition(nu.left - old.left, nu.top - old.top);\n  };\n  var MouseData = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getData: getData$1,\n    getDelta: getDelta$1\n  });\n  var events$3 = function events$3(dragConfig, dragState, updateStartState) {\n    return [run$1(mousedown(), function (component, simulatedEvent) {\n      var raw = simulatedEvent.event.raw;\n      if (raw.button !== 0) {\n        return;\n      }\n      simulatedEvent.stop();\n      var stop$1 = function stop$1() {\n        return stop(component, Optional.some(blocker), dragConfig, dragState);\n      };\n      var delayDrop = DelayedFunction(stop$1, 200);\n      var dragApi = {\n        drop: stop$1,\n        delayDrop: delayDrop.schedule,\n        forceDrop: stop$1,\n        move: function move(event) {\n          delayDrop.cancel();\n          _move(component, dragConfig, dragState, MouseData, event);\n        }\n      };\n      var blocker = createComponent(component, dragConfig.blockerClass, init$3(dragApi));\n      var start = function start() {\n        updateStartState(component);\n        instigate(component, blocker);\n      };\n      start();\n    })];\n  };\n  var schema$5 = [].concat(schema$6, [output$1('dragger', {\n    handlers: handlers(events$3)\n  })]);\n  var init$2 = function init$2(dragApi) {\n    return derive$2([run$1(touchstart(), dragApi.forceDrop), run$1(touchend(), dragApi.drop), run$1(touchcancel(), dragApi.drop), run$1(touchmove(), function (comp, simulatedEvent) {\n      dragApi.move(simulatedEvent.event);\n    })]);\n  };\n  var getDataFrom = function getDataFrom(touches) {\n    var touch = touches[0];\n    return Optional.some(SugarPosition(touch.clientX, touch.clientY));\n  };\n  var getData = function getData(event) {\n    var raw = event.raw;\n    var touches = raw.touches;\n    return touches.length === 1 ? getDataFrom(touches) : Optional.none();\n  };\n  var getDelta = function getDelta(old, nu) {\n    return SugarPosition(nu.left - old.left, nu.top - old.top);\n  };\n  var TouchData = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getData: getData,\n    getDelta: getDelta\n  });\n  var events$2 = function events$2(dragConfig, dragState, updateStartState) {\n    var blockerSingleton = value$2();\n    var stopBlocking = function stopBlocking(component) {\n      stop(component, blockerSingleton.get(), dragConfig, dragState);\n      blockerSingleton.clear();\n    };\n    return [run$1(touchstart(), function (component, simulatedEvent) {\n      simulatedEvent.stop();\n      var stop = function stop() {\n        return stopBlocking(component);\n      };\n      var dragApi = {\n        drop: stop,\n        delayDrop: noop,\n        forceDrop: stop,\n        move: function move(event) {\n          _move(component, dragConfig, dragState, TouchData, event);\n        }\n      };\n      var blocker = createComponent(component, dragConfig.blockerClass, init$2(dragApi));\n      blockerSingleton.set(blocker);\n      var start = function start() {\n        updateStartState(component);\n        instigate(component, blocker);\n      };\n      start();\n    }), run$1(touchmove(), function (component, simulatedEvent) {\n      simulatedEvent.stop();\n      _move(component, dragConfig, dragState, TouchData, simulatedEvent.event);\n    }), run$1(touchend(), function (component, simulatedEvent) {\n      simulatedEvent.stop();\n      stopBlocking(component);\n    }), run$1(touchcancel(), stopBlocking)];\n  };\n  var schema$4 = [].concat(schema$6, [output$1('dragger', {\n    handlers: handlers(events$2)\n  })]);\n  var events$1 = function events$1(dragConfig, dragState, updateStartState) {\n    return [].concat(_toConsumableArray(events$3(dragConfig, dragState, updateStartState)), _toConsumableArray(events$2(dragConfig, dragState, updateStartState)));\n  };\n  var schema$3 = [].concat(schema$6, [output$1('dragger', {\n    handlers: handlers(events$1)\n  })]);\n  var mouse = schema$5;\n  var touch = schema$4;\n  var mouseOrTouch = schema$3;\n  var DraggingBranches = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    mouse: mouse,\n    touch: touch,\n    mouseOrTouch: mouseOrTouch\n  });\n  var init$1 = function init$1() {\n    var previous = Optional.none();\n    var startData = Optional.none();\n    var reset = function reset() {\n      previous = Optional.none();\n      startData = Optional.none();\n    };\n    var calculateDelta = function calculateDelta(mode, nu) {\n      var result = previous.map(function (old) {\n        return mode.getDelta(old, nu);\n      });\n      previous = Optional.some(nu);\n      return result;\n    };\n    var update = function update(mode, dragEvent) {\n      return mode.getData(dragEvent).bind(function (nuData) {\n        return calculateDelta(mode, nuData);\n      });\n    };\n    var setStartData = function setStartData(data) {\n      startData = Optional.some(data);\n    };\n    var getStartData = function getStartData() {\n      return startData;\n    };\n    var readState = constant$1({});\n    return nu$8({\n      readState: readState,\n      reset: reset,\n      update: update,\n      getStartData: getStartData,\n      setStartData: setStartData\n    });\n  };\n  var DragState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    init: init$1\n  });\n  var Dragging = createModes({\n    branchKey: 'mode',\n    branches: DraggingBranches,\n    name: 'dragging',\n    active: {\n      events: function events(dragConfig, dragState) {\n        var dragger = dragConfig.dragger;\n        return dragger.handlers(dragConfig, dragState);\n      }\n    },\n    extra: {\n      snap: function snap(sConfig) {\n        return {\n          sensor: sConfig.sensor,\n          range: sConfig.range,\n          output: sConfig.output,\n          extra: Optional.from(sConfig.extra)\n        };\n      }\n    },\n    state: DragState,\n    apis: DraggingApis\n  });\n  var snapWidth = 40;\n  var snapOffset = snapWidth / 2;\n  var calcSnap = function calcSnap(selectorOpt, td, x, y, width, height) {\n    return selectorOpt.fold(function () {\n      return Dragging.snap({\n        sensor: absolute(x - snapOffset, y - snapOffset),\n        range: SugarPosition(width, height),\n        output: absolute(Optional.some(x), Optional.some(y)),\n        extra: {\n          td: td\n        }\n      });\n    }, function (selectorHandle) {\n      var sensorLeft = x - snapOffset;\n      var sensorTop = y - snapOffset;\n      var sensorWidth = snapWidth;\n      var sensorHeight = snapWidth;\n      var rect = selectorHandle.element.dom.getBoundingClientRect();\n      return Dragging.snap({\n        sensor: absolute(sensorLeft, sensorTop),\n        range: SugarPosition(sensorWidth, sensorHeight),\n        output: absolute(Optional.some(x - rect.width / 2), Optional.some(y - rect.height / 2)),\n        extra: {\n          td: td\n        }\n      });\n    });\n  };\n  var getSnapsConfig = function getSnapsConfig(getSnapPoints, cell, onChange) {\n    var isSameCell = function isSameCell(cellOpt, td) {\n      return cellOpt.exists(function (currentTd) {\n        return eq(currentTd, td);\n      });\n    };\n    return {\n      getSnapPoints: getSnapPoints,\n      leftAttr: 'data-drag-left',\n      topAttr: 'data-drag-top',\n      onSensor: function onSensor(component, extra) {\n        var td = extra.td;\n        if (!isSameCell(cell.get(), td)) {\n          cell.set(td);\n          onChange(td);\n        }\n      },\n      mustSnap: true\n    };\n  };\n  var createSelector = function createSelector(snaps) {\n    return record(Button.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-selector']\n      },\n      buttonBehaviours: derive$1([Dragging.config({\n        mode: 'mouseOrTouch',\n        blockerClass: 'blocker',\n        snaps: snaps\n      }), Unselecting.config({})]),\n      eventOrder: {\n        mousedown: ['dragging', 'alloy.base.behaviour'],\n        touchstart: ['dragging', 'alloy.base.behaviour']\n      }\n    }));\n  };\n  var setup$4 = function setup$4(editor, sink) {\n    var tlTds = Cell([]);\n    var brTds = Cell([]);\n    var isVisible = Cell(false);\n    var startCell = value$2();\n    var finishCell = value$2();\n    var getTopLeftSnap = function getTopLeftSnap(td) {\n      var box = absolute$2(td);\n      return calcSnap(memTopLeft.getOpt(sink), td, box.x, box.y, box.width, box.height);\n    };\n    var getTopLeftSnaps = function getTopLeftSnaps() {\n      return map$2(tlTds.get(), function (td) {\n        return getTopLeftSnap(td);\n      });\n    };\n    var getBottomRightSnap = function getBottomRightSnap(td) {\n      var box = absolute$2(td);\n      return calcSnap(memBottomRight.getOpt(sink), td, box.right, box.bottom, box.width, box.height);\n    };\n    var getBottomRightSnaps = function getBottomRightSnaps() {\n      return map$2(brTds.get(), function (td) {\n        return getBottomRightSnap(td);\n      });\n    };\n    var topLeftSnaps = getSnapsConfig(getTopLeftSnaps, startCell, function (start) {\n      finishCell.get().each(function (finish) {\n        editor.dispatch('TableSelectorChange', {\n          start: start,\n          finish: finish\n        });\n      });\n    });\n    var bottomRightSnaps = getSnapsConfig(getBottomRightSnaps, finishCell, function (finish) {\n      startCell.get().each(function (start) {\n        editor.dispatch('TableSelectorChange', {\n          start: start,\n          finish: finish\n        });\n      });\n    });\n    var memTopLeft = createSelector(topLeftSnaps);\n    var memBottomRight = createSelector(bottomRightSnaps);\n    var topLeft = build$1(memTopLeft.asSpec());\n    var bottomRight = build$1(memBottomRight.asSpec());\n    var showOrHideHandle = function showOrHideHandle(selector, cell, isAbove, isBelow) {\n      var cellRect = cell.dom.getBoundingClientRect();\n      remove$6(selector.element, 'display');\n      var viewportHeight = defaultView(SugarElement.fromDom(editor.getBody())).dom.innerHeight;\n      var aboveViewport = isAbove(cellRect);\n      var belowViewport = isBelow(cellRect, viewportHeight);\n      if (aboveViewport || belowViewport) {\n        set$8(selector.element, 'display', 'none');\n      }\n    };\n    var snapTo = function snapTo(selector, cell, getSnapConfig, pos) {\n      var snap = getSnapConfig(cell);\n      Dragging.snapTo(selector, snap);\n      var isAbove = function isAbove(rect) {\n        return rect[pos] < 0;\n      };\n      var isBelow = function isBelow(rect, viewportHeight) {\n        return rect[pos] > viewportHeight;\n      };\n      showOrHideHandle(selector, cell, isAbove, isBelow);\n    };\n    var snapTopLeft = function snapTopLeft(cell) {\n      return snapTo(topLeft, cell, getTopLeftSnap, 'top');\n    };\n    var snapLastTopLeft = function snapLastTopLeft() {\n      return startCell.get().each(snapTopLeft);\n    };\n    var snapBottomRight = function snapBottomRight(cell) {\n      return snapTo(bottomRight, cell, getBottomRightSnap, 'bottom');\n    };\n    var snapLastBottomRight = function snapLastBottomRight() {\n      return finishCell.get().each(snapBottomRight);\n    };\n    if (detect$2().deviceType.isTouch()) {\n      editor.on('TableSelectionChange', function (e) {\n        if (!isVisible.get()) {\n          attach(sink, topLeft);\n          attach(sink, bottomRight);\n          isVisible.set(true);\n        }\n        startCell.set(e.start);\n        finishCell.set(e.finish);\n        e.otherCells.each(function (otherCells) {\n          tlTds.set(otherCells.upOrLeftCells);\n          brTds.set(otherCells.downOrRightCells);\n          snapTopLeft(e.start);\n          snapBottomRight(e.finish);\n        });\n      });\n      editor.on('ResizeEditor ResizeWindow ScrollContent', function () {\n        snapLastTopLeft();\n        snapLastBottomRight();\n      });\n      editor.on('TableSelectionClear', function () {\n        if (isVisible.get()) {\n          detach(topLeft);\n          detach(bottomRight);\n          isVisible.set(false);\n        }\n        startCell.clear();\n        finishCell.clear();\n      });\n    }\n  };\n  var Logo = \"<svg width=\\\"50px\\\" height=\\\"16px\\\" viewBox=\\\"0 0 50 16\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <path fill-rule=\\\"evenodd\\\" clip-rule=\\\"evenodd\\\" d=\\\"M10.143 0c2.608.015 5.186 2.178 5.186 5.331 0 0 .077 3.812-.084 4.87-.361 2.41-2.164 4.074-4.65 4.496-1.453.284-2.523.49-3.212.623-.373.071-.634.122-.785.152-.184.038-.997.145-1.35.145-2.732 0-5.21-2.04-5.248-5.33 0 0 0-3.514.03-4.442.093-2.4 1.758-4.342 4.926-4.963 0 0 3.875-.752 4.036-.782.368-.07.775-.1 1.15-.1Zm1.826 2.8L5.83 3.989v2.393l-2.455.475v5.968l6.137-1.189V9.243l2.456-.476V2.8ZM5.83 6.382l3.682-.713v3.574l-3.682.713V6.382Zm27.173-1.64-.084-1.066h-2.226v9.132h2.456V7.743c-.008-1.151.998-2.064 2.149-2.072 1.15-.008 1.987.92 1.995 2.072v5.065h2.455V7.359c-.015-2.18-1.657-3.929-3.837-3.913a3.993 3.993 0 0 0-2.908 1.296Zm-6.3-4.266L29.16 0v2.387l-2.456.475V.476Zm0 3.2v9.132h2.456V3.676h-2.456Zm18.179 11.787L49.11 3.676H46.58l-1.612 4.527-.46 1.382-.384-1.382-1.611-4.527H39.98l3.3 9.132L42.15 16l2.732-.537ZM22.867 9.738c0 .752.568 1.075.921 1.075.353 0 .668-.047.998-.154l.537 1.765c-.23.154-.92.537-2.225.537-1.305 0-2.655-.997-2.686-2.686a136.877 136.877 0 0 1 0-4.374H18.8V3.676h1.612v-1.98l2.455-.476v2.456h2.302V5.9h-2.302v3.837Z\\\"/>\\n</svg>\\n\";\n  var isHidden = function isHidden(elm) {\n    return elm.nodeName === 'BR' || !!elm.getAttribute('data-mce-bogus') || elm.getAttribute('data-mce-type') === 'bookmark';\n  };\n  var renderElementPath = function renderElementPath(editor, settings, providersBackstage) {\n    var _a;\n    var delimiter = (_a = settings.delimiter) !== null && _a !== void 0 ? _a : \"\\u203A\";\n    var renderElement = function renderElement(name, element, index) {\n      return Button.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox-statusbar__path-item'],\n          attributes: {\n            'data-index': index,\n            'aria-level': index + 1\n          }\n        },\n        components: [text$2(name)],\n        action: function action(_btn) {\n          editor.focus();\n          editor.selection.select(element);\n          editor.nodeChanged();\n        },\n        buttonBehaviours: derive$1([DisablingConfigs.button(providersBackstage.isDisabled), receivingConfig()])\n      });\n    };\n    var renderDivider = function renderDivider() {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-statusbar__path-divider'],\n          attributes: {\n            'aria-hidden': true\n          }\n        },\n        components: [text$2(\" \".concat(delimiter, \" \"))]\n      };\n    };\n    var renderPathData = function renderPathData(data) {\n      return foldl(data, function (acc, path, index) {\n        var element = renderElement(path.name, path.element, index);\n        if (index === 0) {\n          return acc.concat([element]);\n        } else {\n          return acc.concat([renderDivider(), element]);\n        }\n      }, []);\n    };\n    var updatePath = function updatePath(parents) {\n      var newPath = [];\n      var i = parents.length;\n      while (i-- > 0) {\n        var _parent = parents[i];\n        if (_parent.nodeType === 1 && !isHidden(_parent)) {\n          var args = fireResolveName(editor, _parent);\n          if (!args.isDefaultPrevented()) {\n            newPath.push({\n              name: args.name,\n              element: _parent\n            });\n          }\n          if (args.isPropagationStopped()) {\n            break;\n          }\n        }\n      }\n      return newPath;\n    };\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-statusbar__path'],\n        attributes: {\n          role: 'navigation'\n        }\n      },\n      behaviours: derive$1([Keying.config({\n        mode: 'flow',\n        selector: 'div[role=button]'\n      }), Disabling.config({\n        disabled: providersBackstage.isDisabled\n      }), receivingConfig(), Tabstopping.config({}), Replacing.config({}), config('elementPathEvents', [runOnAttached(function (comp, _e) {\n        editor.shortcuts.add('alt+F11', 'focus statusbar elementpath', function () {\n          return Keying.focusIn(comp);\n        });\n        editor.on('NodeChange', function (e) {\n          var newPath = updatePath(e.parents);\n          var newChildren = newPath.length > 0 ? renderPathData(newPath) : [];\n          Replacing.set(comp, newChildren);\n        });\n      })])]),\n      components: []\n    };\n  };\n  var ResizeTypes;\n  (function (ResizeTypes) {\n    ResizeTypes[ResizeTypes['None'] = 0] = 'None';\n    ResizeTypes[ResizeTypes['Both'] = 1] = 'Both';\n    ResizeTypes[ResizeTypes['Vertical'] = 2] = 'Vertical';\n  })(ResizeTypes || (ResizeTypes = {}));\n  var getDimensions = function getDimensions(editor, deltas, resizeType, originalHeight, originalWidth) {\n    var dimensions = {\n      height: calcCappedSize(originalHeight + deltas.top, getMinHeightOption(editor), getMaxHeightOption(editor))\n    };\n    if (resizeType === ResizeTypes.Both) {\n      dimensions.width = calcCappedSize(originalWidth + deltas.left, getMinWidthOption(editor), getMaxWidthOption(editor));\n    }\n    return dimensions;\n  };\n  var resize = function resize(editor, deltas, resizeType) {\n    var container = SugarElement.fromDom(editor.getContainer());\n    var dimensions = getDimensions(editor, deltas, resizeType, get$d(container), get$c(container));\n    each(dimensions, function (val, dim) {\n      if (isNumber(val)) {\n        set$8(container, dim, numToPx(val));\n      }\n    });\n    fireResizeEditor(editor);\n  };\n  var getResizeType = function getResizeType(editor) {\n    var resize = getResize(editor);\n    if (resize === false) {\n      return ResizeTypes.None;\n    } else if (resize === 'both') {\n      return ResizeTypes.Both;\n    } else {\n      return ResizeTypes.Vertical;\n    }\n  };\n  var keyboardHandler = function keyboardHandler(editor, resizeType, x, y) {\n    var scale = 20;\n    var delta = SugarPosition(x * scale, y * scale);\n    resize(editor, delta, resizeType);\n    return Optional.some(true);\n  };\n  var renderResizeHandler = function renderResizeHandler(editor, providersBackstage) {\n    var resizeType = getResizeType(editor);\n    if (resizeType === ResizeTypes.None) {\n      return Optional.none();\n    }\n    var resizeLabel = resizeType === ResizeTypes.Both ? 'Press the arrow keys to resize the editor.' : 'Press the Up and Down arrow keys to resize the editor.';\n    return Optional.some(render$3('resize-handle', {\n      tag: 'div',\n      classes: ['tox-statusbar__resize-handle'],\n      attributes: {\n        'title': providersBackstage.translate('Resize'),\n        'aria-label': providersBackstage.translate(resizeLabel)\n      },\n      behaviours: [Dragging.config({\n        mode: 'mouse',\n        repositionTarget: false,\n        onDrag: function onDrag(_comp, _target, delta) {\n          return resize(editor, delta, resizeType);\n        },\n        blockerClass: 'tox-blocker'\n      }), Keying.config({\n        mode: 'special',\n        onLeft: function onLeft() {\n          return keyboardHandler(editor, resizeType, -1, 0);\n        },\n        onRight: function onRight() {\n          return keyboardHandler(editor, resizeType, 1, 0);\n        },\n        onUp: function onUp() {\n          return keyboardHandler(editor, resizeType, 0, -1);\n        },\n        onDown: function onDown() {\n          return keyboardHandler(editor, resizeType, 0, 1);\n        }\n      }), Tabstopping.config({}), Focusing.config({})]\n    }, providersBackstage.icons));\n  };\n  var renderWordCount = function renderWordCount(editor, providersBackstage) {\n    var replaceCountText = function replaceCountText(comp, count, mode) {\n      return Replacing.set(comp, [text$2(providersBackstage.translate(['{0} ' + mode, count[mode]]))]);\n    };\n    return Button.sketch({\n      dom: {\n        tag: 'button',\n        classes: ['tox-statusbar__wordcount']\n      },\n      components: [],\n      buttonBehaviours: derive$1([DisablingConfigs.button(providersBackstage.isDisabled), receivingConfig(), Tabstopping.config({}), Replacing.config({}), Representing.config({\n        store: {\n          mode: 'memory',\n          initialValue: {\n            mode: 'words',\n            count: {\n              words: 0,\n              characters: 0\n            }\n          }\n        }\n      }), config('wordcount-events', [runOnExecute$1(function (comp) {\n        var currentVal = Representing.getValue(comp);\n        var newMode = currentVal.mode === 'words' ? 'characters' : 'words';\n        Representing.setValue(comp, {\n          mode: newMode,\n          count: currentVal.count\n        });\n        replaceCountText(comp, currentVal.count, newMode);\n      }), runOnAttached(function (comp) {\n        editor.on('wordCountUpdate', function (e) {\n          var _Representing$getValu = Representing.getValue(comp),\n            mode = _Representing$getValu.mode;\n          Representing.setValue(comp, {\n            mode: mode,\n            count: e.wordCount\n          });\n          replaceCountText(comp, e.wordCount, mode);\n        });\n      })])]),\n      eventOrder: _defineProperty({}, execute$5(), ['disabling', 'alloy.base.behaviour', 'wordcount-events'])\n    });\n  };\n  var renderStatusbar = function renderStatusbar(editor, providersBackstage) {\n    var renderBranding = function renderBranding() {\n      return {\n        dom: {\n          tag: 'span',\n          classes: ['tox-statusbar__branding']\n        },\n        components: [{\n          dom: {\n            tag: 'a',\n            attributes: {\n              'href': 'https://www.tiny.cloud/powered-by-tiny?utm_campaign=editor_referral&utm_medium=poweredby&utm_source=tinymce&utm_content=v6',\n              'rel': 'noopener',\n              'target': '_blank',\n              'aria-label': global$8.translate(['Powered by {0}', 'Tiny'])\n            },\n            innerHtml: Logo.trim()\n          },\n          behaviours: derive$1([Focusing.config({})])\n        }]\n      };\n    };\n    var renderHelpAccessibility = function renderHelpAccessibility() {\n      var shortcutText = convertText('Alt+0');\n      var text = \"Press {0} for help\";\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-statusbar__help-text']\n        },\n        components: [text$2(global$8.translate([text, shortcutText]))]\n      };\n    };\n    var renderRightContainer = function renderRightContainer() {\n      var components = [];\n      if (editor.hasPlugin('wordcount')) {\n        components.push(renderWordCount(editor, providersBackstage));\n      }\n      if (useBranding(editor)) {\n        components.push(renderBranding());\n      }\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-statusbar__right-container']\n        },\n        components: components\n      };\n    };\n    var getTextComponents = function getTextComponents() {\n      var components = [];\n      var shouldRenderHelp = useHelpAccessibility(editor);\n      var shouldRenderElementPath = useElementPath(editor);\n      var shouldRenderRightContainer = useBranding(editor) || editor.hasPlugin('wordcount');\n      var getTextComponentClasses = function getTextComponentClasses() {\n        var flexStart = 'tox-statusbar__text-container--flex-start';\n        var flexEnd = 'tox-statusbar__text-container--flex-end';\n        var spaceAround = 'tox-statusbar__text-container--space-around';\n        if (shouldRenderHelp) {\n          var container3Columns = 'tox-statusbar__text-container-3-cols';\n          if (!shouldRenderRightContainer && !shouldRenderElementPath) {\n            return [container3Columns, spaceAround];\n          }\n          if (shouldRenderRightContainer && !shouldRenderElementPath) {\n            return [container3Columns, flexEnd];\n          }\n          return [container3Columns, flexStart];\n        }\n        return [shouldRenderRightContainer && !shouldRenderElementPath ? flexEnd : flexStart];\n      };\n      if (shouldRenderElementPath) {\n        components.push(renderElementPath(editor, {}, providersBackstage));\n      }\n      if (shouldRenderHelp) {\n        components.push(renderHelpAccessibility());\n      }\n      if (shouldRenderRightContainer) {\n        components.push(renderRightContainer());\n      }\n      if (components.length > 0) {\n        return [{\n          dom: {\n            tag: 'div',\n            classes: ['tox-statusbar__text-container'].concat(_toConsumableArray(getTextComponentClasses()))\n          },\n          components: components\n        }];\n      }\n      return [];\n    };\n    var getComponents = function getComponents() {\n      var components = getTextComponents();\n      var resizeHandler = renderResizeHandler(editor, providersBackstage);\n      return components.concat(resizeHandler.toArray());\n    };\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-statusbar']\n      },\n      components: getComponents()\n    };\n  };\n  var getLazyMothership = function getLazyMothership(label, singleton) {\n    return singleton.get().getOrDie(\"UI for \".concat(label, \" has not been rendered\"));\n  };\n  var setup$3 = function setup$3(editor, setupForTheme) {\n    var isInline = editor.inline;\n    var mode = isInline ? Inline : Iframe;\n    var header = isStickyToolbar(editor) ? StickyHeader : StaticHeader;\n    var lazyUiRefs = LazyUiReferences();\n    var lazyMothership = value$2();\n    var lazyDialogMothership = value$2();\n    var lazyPopupMothership = value$2();\n    var platform = detect$2();\n    var isTouch = platform.deviceType.isTouch();\n    var touchPlatformClass = 'tox-platform-touch';\n    var deviceClasses = isTouch ? [touchPlatformClass] : [];\n    var isToolbarBottom = isToolbarLocationBottom(editor);\n    var toolbarMode = getToolbarMode(editor);\n    var memAnchorBar = record({\n      dom: {\n        tag: 'div',\n        classes: ['tox-anchorbar']\n      }\n    });\n    var memBottomAnchorBar = record({\n      dom: {\n        tag: 'div',\n        classes: ['tox-bottom-anchorbar']\n      }\n    });\n    var _lazyHeader = function lazyHeader() {\n      return lazyUiRefs.mainUi.get().map(function (ui) {\n        return ui.outerContainer;\n      }).bind(OuterContainer.getHeader);\n    };\n    var lazyDialogSinkResult = function lazyDialogSinkResult() {\n      return Result.fromOption(lazyUiRefs.dialogUi.get().map(function (ui) {\n        return ui.sink;\n      }), 'UI has not been rendered');\n    };\n    var lazyPopupSinkResult = function lazyPopupSinkResult() {\n      return Result.fromOption(lazyUiRefs.popupUi.get().map(function (ui) {\n        return ui.sink;\n      }), '(popup) UI has not been rendered');\n    };\n    var lazyAnchorBar = lazyUiRefs.lazyGetInOuterOrDie('anchor bar', memAnchorBar.getOpt);\n    var lazyBottomAnchorBar = lazyUiRefs.lazyGetInOuterOrDie('bottom anchor bar', memBottomAnchorBar.getOpt);\n    var lazyToolbar = lazyUiRefs.lazyGetInOuterOrDie('toolbar', OuterContainer.getToolbar);\n    var lazyThrobber = lazyUiRefs.lazyGetInOuterOrDie('throbber', OuterContainer.getThrobber);\n    var backstages = init$6({\n      popup: lazyPopupSinkResult,\n      dialog: lazyDialogSinkResult\n    }, editor, lazyAnchorBar, lazyBottomAnchorBar);\n    var makeHeaderPart = function makeHeaderPart() {\n      var verticalDirAttributes = {\n        attributes: _defineProperty({}, Attribute, isToolbarBottom ? AttributeValue.BottomToTop : AttributeValue.TopToBottom)\n      };\n      var partMenubar = OuterContainer.parts.menubar({\n        dom: {\n          tag: 'div',\n          classes: ['tox-menubar']\n        },\n        backstage: backstages.popup,\n        onEscape: function onEscape() {\n          editor.focus();\n        }\n      });\n      var partToolbar = OuterContainer.parts.toolbar(_objectSpread({\n        dom: {\n          tag: 'div',\n          classes: ['tox-toolbar']\n        },\n        getSink: backstages.popup.shared.getSink,\n        providers: backstages.popup.shared.providers,\n        onEscape: function onEscape() {\n          editor.focus();\n        },\n        onToolbarToggled: function onToolbarToggled(state) {\n          fireToggleToolbarDrawer(editor, state);\n        },\n        type: toolbarMode,\n        lazyToolbar: lazyToolbar,\n        lazyHeader: function lazyHeader() {\n          return _lazyHeader().getOrDie('Could not find header element');\n        }\n      }, verticalDirAttributes));\n      var partMultipleToolbar = OuterContainer.parts['multiple-toolbar']({\n        dom: {\n          tag: 'div',\n          classes: ['tox-toolbar-overlord']\n        },\n        providers: backstages.popup.shared.providers,\n        onEscape: function onEscape() {\n          editor.focus();\n        },\n        type: toolbarMode\n      });\n      var hasMultipleToolbar = isMultipleToolbars(editor);\n      var hasToolbar = isToolbarEnabled(editor);\n      var hasMenubar = isMenubarEnabled(editor);\n      var shouldHavePromotion = promotionEnabled(editor);\n      var partPromotion = makePromotion();\n      var hasAnyContents = hasMultipleToolbar || hasToolbar || hasMenubar;\n      var getPartToolbar = function getPartToolbar() {\n        if (hasMultipleToolbar) {\n          return [partMultipleToolbar];\n        } else if (hasToolbar) {\n          return [partToolbar];\n        } else {\n          return [];\n        }\n      };\n      var menubarCollection = shouldHavePromotion ? [partPromotion, partMenubar] : [partMenubar];\n      return OuterContainer.parts.header({\n        dom: _objectSpread({\n          tag: 'div',\n          classes: ['tox-editor-header'].concat(hasAnyContents ? [] : ['tox-editor-header--empty'])\n        }, verticalDirAttributes),\n        components: flatten([hasMenubar ? menubarCollection : [], getPartToolbar(), useFixedContainer(editor) ? [] : [memAnchorBar.asSpec()]]),\n        sticky: isStickyToolbar(editor),\n        editor: editor,\n        sharedBackstage: backstages.popup.shared\n      });\n    };\n    var makePromotion = function makePromotion() {\n      return OuterContainer.parts.promotion({\n        dom: {\n          tag: 'div',\n          classes: ['tox-promotion']\n        }\n      });\n    };\n    var makeSidebarDefinition = function makeSidebarDefinition() {\n      var partSocket = OuterContainer.parts.socket({\n        dom: {\n          tag: 'div',\n          classes: ['tox-edit-area']\n        }\n      });\n      var partSidebar = OuterContainer.parts.sidebar({\n        dom: {\n          tag: 'div',\n          classes: ['tox-sidebar']\n        }\n      });\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-sidebar-wrap']\n        },\n        components: [partSocket, partSidebar]\n      };\n    };\n    var renderDialogUi = function renderDialogUi() {\n      var uiContainer = getUiContainer(editor);\n      var isGridUiContainer = eq(body(), uiContainer) && get$e(uiContainer, 'display') === 'grid';\n      var sinkSpec = {\n        dom: {\n          tag: 'div',\n          classes: ['tox', 'tox-silver-sink', 'tox-tinymce-aux'].concat(deviceClasses),\n          attributes: _objectSpread({}, global$8.isRtl() ? {\n            dir: 'rtl'\n          } : {})\n        },\n        behaviours: derive$1([Positioning.config({\n          useFixed: function useFixed() {\n            return header.isDocked(_lazyHeader);\n          }\n        })])\n      };\n      var reactiveWidthSpec = {\n        dom: {\n          styles: {\n            width: document.body.clientWidth + 'px'\n          }\n        },\n        events: derive$2([run$1(windowResize(), function (comp) {\n          set$8(comp.element, 'width', document.body.clientWidth + 'px');\n        })])\n      };\n      var sink = build$1(deepMerge(sinkSpec, isGridUiContainer ? reactiveWidthSpec : {}));\n      var uiMothership = takeover(sink);\n      lazyDialogMothership.set(uiMothership);\n      return {\n        sink: sink,\n        mothership: uiMothership\n      };\n    };\n    var renderPopupUi = function renderPopupUi() {\n      var sinkSpec = {\n        dom: {\n          tag: 'div',\n          classes: ['tox', 'tox-silver-sink', 'tox-silver-popup-sink', 'tox-tinymce-aux'].concat(deviceClasses),\n          attributes: _objectSpread({}, global$8.isRtl() ? {\n            dir: 'rtl'\n          } : {})\n        },\n        behaviours: derive$1([Positioning.config({\n          useFixed: function useFixed() {\n            return header.isDocked(_lazyHeader);\n          },\n          getBounds: function getBounds() {\n            return setupForTheme.getPopupSinkBounds();\n          }\n        })])\n      };\n      var sink = build$1(sinkSpec);\n      var uiMothership = takeover(sink);\n      lazyPopupMothership.set(uiMothership);\n      return {\n        sink: sink,\n        mothership: uiMothership\n      };\n    };\n    var renderMainUi = function renderMainUi() {\n      var partHeader = makeHeaderPart();\n      var sidebarContainer = makeSidebarDefinition();\n      var partThrobber = OuterContainer.parts.throbber({\n        dom: {\n          tag: 'div',\n          classes: ['tox-throbber']\n        },\n        backstage: backstages.popup\n      });\n      var partViewWrapper = OuterContainer.parts.viewWrapper({\n        backstage: backstages.popup\n      });\n      var statusbar = useStatusBar(editor) && !isInline ? Optional.some(renderStatusbar(editor, backstages.popup.shared.providers)) : Optional.none();\n      var editorComponents = flatten([isToolbarBottom ? [] : [partHeader], isInline ? [] : [sidebarContainer], isToolbarBottom ? [partHeader] : []]);\n      var editorContainer = OuterContainer.parts.editorContainer({\n        components: flatten([editorComponents, isInline ? [] : [memBottomAnchorBar.asSpec()].concat(_toConsumableArray(statusbar.toArray()))])\n      });\n      var isHidden = isDistractionFree(editor);\n      var attributes = _objectSpread({\n        role: 'application'\n      }, global$8.isRtl() ? {\n        dir: 'rtl'\n      } : {}, isHidden ? {\n        'aria-hidden': 'true'\n      } : {});\n      var outerContainer = build$1(OuterContainer.sketch({\n        dom: {\n          tag: 'div',\n          classes: ['tox', 'tox-tinymce'].concat(isInline ? ['tox-tinymce-inline'] : []).concat(isToolbarBottom ? ['tox-tinymce--toolbar-bottom'] : []).concat(deviceClasses),\n          styles: _objectSpread({\n            visibility: 'hidden'\n          }, isHidden ? {\n            opacity: '0',\n            border: '0'\n          } : {}),\n          attributes: attributes\n        },\n        components: [editorContainer].concat(_toConsumableArray(isInline ? [] : [partViewWrapper]), [partThrobber]),\n        behaviours: derive$1([receivingConfig(), Disabling.config({\n          disableClass: 'tox-tinymce--disabled'\n        }), Keying.config({\n          mode: 'cyclic',\n          selector: '.tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle'\n        })])\n      }));\n      var mothership = takeover(outerContainer);\n      lazyMothership.set(mothership);\n      return {\n        mothership: mothership,\n        outerContainer: outerContainer\n      };\n    };\n    var setEditorSize = function setEditorSize(outerContainer) {\n      var parsedHeight = numToPx(getHeightWithFallback(editor));\n      var parsedWidth = numToPx(getWidthWithFallback(editor));\n      if (!editor.inline) {\n        if (isValidValue$1('div', 'width', parsedWidth)) {\n          set$8(outerContainer.element, 'width', parsedWidth);\n        }\n        if (isValidValue$1('div', 'height', parsedHeight)) {\n          set$8(outerContainer.element, 'height', parsedHeight);\n        } else {\n          set$8(outerContainer.element, 'height', '400px');\n        }\n      }\n      return parsedHeight;\n    };\n    var setupShortcutsAndCommands = function setupShortcutsAndCommands(outerContainer) {\n      editor.addShortcut('alt+F9', 'focus menubar', function () {\n        OuterContainer.focusMenubar(outerContainer);\n      });\n      editor.addShortcut('alt+F10', 'focus toolbar', function () {\n        OuterContainer.focusToolbar(outerContainer);\n      });\n      editor.addCommand('ToggleToolbarDrawer', function (_ui, options) {\n        if (options === null || options === void 0 ? void 0 : options.skipFocus) {\n          OuterContainer.toggleToolbarDrawerWithoutFocusing(outerContainer);\n        } else {\n          OuterContainer.toggleToolbarDrawer(outerContainer);\n        }\n      });\n      editor.addQueryStateHandler('ToggleToolbarDrawer', function () {\n        return OuterContainer.isToolbarDrawerToggled(outerContainer);\n      });\n    };\n    var renderUIWithRefs = function renderUIWithRefs(uiRefs) {\n      var mainUi = uiRefs.mainUi,\n        popupUi = uiRefs.popupUi,\n        uiMotherships = uiRefs.uiMotherships;\n      map$1(getToolbarGroups(editor), function (toolbarGroupButtonConfig, name) {\n        editor.ui.registry.addGroupToolbarButton(name, toolbarGroupButtonConfig);\n      });\n      var _editor$ui$registry$g3 = editor.ui.registry.getAll(),\n        buttons = _editor$ui$registry$g3.buttons,\n        menuItems = _editor$ui$registry$g3.menuItems,\n        contextToolbars = _editor$ui$registry$g3.contextToolbars,\n        sidebars = _editor$ui$registry$g3.sidebars,\n        views = _editor$ui$registry$g3.views;\n      var toolbarOpt = getMultipleToolbarsOption(editor);\n      var rawUiConfig = {\n        menuItems: menuItems,\n        menus: getMenus(editor),\n        menubar: getMenubar(editor),\n        toolbar: toolbarOpt.getOrThunk(function () {\n          return getToolbar(editor);\n        }),\n        allowToolbarGroups: toolbarMode === ToolbarMode$1.floating,\n        buttons: buttons,\n        sidebar: sidebars,\n        views: views\n      };\n      setupShortcutsAndCommands(mainUi.outerContainer);\n      setup$b(editor, mainUi.mothership, uiMotherships);\n      header.setup(editor, backstages.popup.shared, _lazyHeader);\n      setup$6(editor, backstages.popup);\n      setup$5(editor, backstages.popup.shared.getSink, backstages.popup);\n      setup$8(editor);\n      setup$7(editor, lazyThrobber, backstages.popup.shared);\n      register$9(editor, contextToolbars, popupUi.sink, {\n        backstage: backstages.popup\n      });\n      setup$4(editor, popupUi.sink);\n      var elm = editor.getElement();\n      var height = setEditorSize(mainUi.outerContainer);\n      var args = {\n        targetNode: elm,\n        height: height\n      };\n      return mode.render(editor, uiRefs, rawUiConfig, backstages.popup, args);\n    };\n    var reuseDialogUiForPopuUi = function reuseDialogUiForPopuUi(dialogUi) {\n      lazyPopupMothership.set(dialogUi.mothership);\n      return dialogUi;\n    };\n    var renderUI = function renderUI() {\n      var mainUi = renderMainUi();\n      var dialogUi = renderDialogUi();\n      var popupUi = isSplitUiMode(editor) ? renderPopupUi() : reuseDialogUiForPopuUi(dialogUi);\n      lazyUiRefs.dialogUi.set(dialogUi);\n      lazyUiRefs.popupUi.set(popupUi);\n      lazyUiRefs.mainUi.set(mainUi);\n      var uiRefs = {\n        popupUi: popupUi,\n        dialogUi: dialogUi,\n        mainUi: mainUi,\n        uiMotherships: lazyUiRefs.getUiMotherships()\n      };\n      return renderUIWithRefs(uiRefs);\n    };\n    return {\n      popups: {\n        backstage: backstages.popup,\n        getMothership: function getMothership() {\n          return getLazyMothership('popups', lazyPopupMothership);\n        }\n      },\n      dialogs: {\n        backstage: backstages.dialog,\n        getMothership: function getMothership() {\n          return getLazyMothership('dialogs', lazyDialogMothership);\n        }\n      },\n      renderUI: renderUI\n    };\n  };\n  var labelledBy = function labelledBy(labelledElement, labelElement) {\n    var labelId = getOpt(labelledElement, 'id').fold(function () {\n      var id = generate$6('dialog-label');\n      set$9(labelElement, 'id', id);\n      return id;\n    }, identity);\n    set$9(labelledElement, 'aria-labelledby', labelId);\n  };\n  var schema$2 = constant$1([required$1('lazySink'), option$3('dragBlockClass'), defaultedFunction('getBounds', win), defaulted('useTabstopAt', always), defaulted('firstTabstop', 0), defaulted('eventOrder', {}), field('modalBehaviours', [Keying]), onKeyboardHandler('onExecute'), onStrictKeyboardHandler('onEscape')]);\n  var basic = {\n    sketch: identity\n  };\n  var parts$2 = constant$1([optional({\n    name: 'draghandle',\n    overrides: function overrides(detail, spec) {\n      return {\n        behaviours: derive$1([Dragging.config({\n          mode: 'mouse',\n          getTarget: function getTarget(handle) {\n            return ancestor(handle, '[role=\"dialog\"]').getOr(handle);\n          },\n          blockerClass: detail.dragBlockClass.getOrDie(new Error('The drag blocker class was not specified for a dialog with a drag handle: \\n' + JSON.stringify(spec, null, 2)).message),\n          getBounds: detail.getDragBounds\n        })])\n      };\n    }\n  }), required({\n    schema: [required$1('dom')],\n    name: 'title'\n  }), required({\n    factory: basic,\n    schema: [required$1('dom')],\n    name: 'close'\n  }), required({\n    factory: basic,\n    schema: [required$1('dom')],\n    name: 'body'\n  }), optional({\n    factory: basic,\n    schema: [required$1('dom')],\n    name: 'footer'\n  }), external({\n    factory: {\n      sketch: function sketch(spec, detail) {\n        return _objectSpread({}, spec, {\n          dom: detail.dom,\n          components: detail.components\n        });\n      }\n    },\n    schema: [defaulted('dom', {\n      tag: 'div',\n      styles: {\n        position: 'fixed',\n        left: '0px',\n        top: '0px',\n        right: '0px',\n        bottom: '0px'\n      }\n    }), defaulted('components', [])],\n    name: 'blocker'\n  })]);\n  var factory$4 = function factory$4(detail, components, spec, externals) {\n    var dialogComp = value$2();\n    var showDialog = function showDialog(dialog) {\n      dialogComp.set(dialog);\n      var sink = detail.lazySink(dialog).getOrDie();\n      var externalBlocker = externals.blocker();\n      var blocker = sink.getSystem().build(_objectSpread({}, externalBlocker, {\n        components: externalBlocker.components.concat([premade(dialog)]),\n        behaviours: derive$1([Focusing.config({}), config('dialog-blocker-events', [runOnSource(focusin(), function () {\n          Blocking.isBlocked(dialog) ? noop() : Keying.focusIn(dialog);\n        })])])\n      }));\n      attach(sink, blocker);\n      Keying.focusIn(dialog);\n    };\n    var hideDialog = function hideDialog(dialog) {\n      dialogComp.clear();\n      parent(dialog.element).each(function (blockerDom) {\n        dialog.getSystem().getByDom(blockerDom).each(function (blocker) {\n          detach(blocker);\n        });\n      });\n    };\n    var getDialogBody = function getDialogBody(dialog) {\n      return getPartOrDie(dialog, detail, 'body');\n    };\n    var getDialogFooter = function getDialogFooter(dialog) {\n      return getPart(dialog, detail, 'footer');\n    };\n    var setBusy = function setBusy(dialog, getBusySpec) {\n      Blocking.block(dialog, getBusySpec);\n    };\n    var setIdle = function setIdle(dialog) {\n      Blocking.unblock(dialog);\n    };\n    var modalEventsId = generate$6('modal-events');\n    var eventOrder = _objectSpread({}, detail.eventOrder, _defineProperty({}, attachedToDom(), [modalEventsId].concat(detail.eventOrder['alloy.system.attached'] || [])));\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      apis: {\n        show: showDialog,\n        hide: hideDialog,\n        getBody: getDialogBody,\n        getFooter: getDialogFooter,\n        setIdle: setIdle,\n        setBusy: setBusy\n      },\n      eventOrder: eventOrder,\n      domModification: {\n        attributes: {\n          'role': 'dialog',\n          'aria-modal': 'true'\n        }\n      },\n      behaviours: augment(detail.modalBehaviours, [Replacing.config({}), Keying.config({\n        mode: 'cyclic',\n        onEnter: detail.onExecute,\n        onEscape: detail.onEscape,\n        useTabstopAt: detail.useTabstopAt,\n        firstTabstop: detail.firstTabstop\n      }), Blocking.config({\n        getRoot: dialogComp.get\n      }), config(modalEventsId, [runOnAttached(function (c) {\n        labelledBy(c.element, getPartOrDie(c, detail, 'title').element);\n      })])])\n    };\n  };\n  var ModalDialog = composite({\n    name: 'ModalDialog',\n    configFields: schema$2(),\n    partFields: parts$2(),\n    factory: factory$4,\n    apis: {\n      show: function show(apis, dialog) {\n        apis.show(dialog);\n      },\n      hide: function hide(apis, dialog) {\n        apis.hide(dialog);\n      },\n      getBody: function getBody(apis, dialog) {\n        return apis.getBody(dialog);\n      },\n      getFooter: function getFooter(apis, dialog) {\n        return apis.getFooter(dialog);\n      },\n      setBusy: function setBusy(apis, dialog, getBusySpec) {\n        apis.setBusy(dialog, getBusySpec);\n      },\n      setIdle: function setIdle(apis, dialog) {\n        apis.setIdle(dialog);\n      }\n    }\n  });\n  var dialogToggleMenuItemSchema = objOf([type, name$1].concat(commonMenuItemFields));\n  var dialogToggleMenuItemDataProcessor = boolean;\n  var baseFooterButtonFields = [generatedName('button'), optionalIcon, defaultedStringEnum('align', 'end', ['start', 'end']), primary, enabled, optionStringEnum('buttonType', ['primary', 'secondary'])];\n  var dialogFooterButtonFields = [].concat(baseFooterButtonFields, [text]);\n  var normalFooterButtonFields = [requiredStringEnum('type', ['submit', 'cancel', 'custom'])].concat(_toConsumableArray(dialogFooterButtonFields));\n  var menuFooterButtonFields = [requiredStringEnum('type', ['menu']), optionalText, optionalTooltip, optionalIcon, requiredArrayOf('items', dialogToggleMenuItemSchema)].concat(baseFooterButtonFields);\n  var toggleButtonSpecFields = [].concat(baseFooterButtonFields, [requiredStringEnum('type', ['togglebutton']), requiredString('tooltip'), optionalIcon, optionalText, defaultedBoolean('active', false)]);\n  var dialogFooterButtonSchema = choose$1('type', {\n    submit: normalFooterButtonFields,\n    cancel: normalFooterButtonFields,\n    custom: normalFooterButtonFields,\n    menu: menuFooterButtonFields,\n    togglebutton: toggleButtonSpecFields\n  });\n  var alertBannerFields = [type, text, requiredStringEnum('level', ['info', 'warn', 'error', 'success']), icon, defaulted('url', '')];\n  var alertBannerSchema = objOf(alertBannerFields);\n  var createBarFields = function createBarFields(itemsField) {\n    return [type, itemsField];\n  };\n  var buttonFields = [type, text, enabled, generatedName('button'), optionalIcon, borderless, optionStringEnum('buttonType', ['primary', 'secondary', 'toolbar']), primary];\n  var buttonSchema = objOf(buttonFields);\n  var formComponentFields = [type, name$1];\n  var formComponentWithLabelFields = formComponentFields.concat([optionalLabel]);\n  var checkboxFields = formComponentFields.concat([label, enabled]);\n  var checkboxSchema = objOf(checkboxFields);\n  var checkboxDataProcessor = boolean;\n  var collectionFields = formComponentWithLabelFields.concat([defaultedColumns('auto')]);\n  var collectionSchema = objOf(collectionFields);\n  var collectionDataProcessor = arrOfObj([value$1, text, icon]);\n  var colorInputFields = formComponentWithLabelFields.concat([defaultedString('storageKey', 'default')]);\n  var colorInputSchema = objOf(colorInputFields);\n  var colorInputDataProcessor = string;\n  var colorPickerFields = formComponentWithLabelFields;\n  var colorPickerSchema = objOf(colorPickerFields);\n  var colorPickerDataProcessor = string;\n  var customEditorFields = formComponentFields.concat([defaultedString('tag', 'textarea'), requiredString('scriptId'), requiredString('scriptUrl'), defaultedPostMsg('settings', undefined)]);\n  var customEditorFieldsOld = formComponentFields.concat([defaultedString('tag', 'textarea'), requiredFunction('init')]);\n  var customEditorSchema = valueOf(function (v) {\n    return asRaw('customeditor.old', objOfOnly(customEditorFieldsOld), v).orThunk(function () {\n      return asRaw('customeditor.new', objOfOnly(customEditorFields), v);\n    });\n  });\n  var customEditorDataProcessor = string;\n  var dropZoneFields = formComponentWithLabelFields;\n  var dropZoneSchema = objOf(dropZoneFields);\n  var dropZoneDataProcessor = arrOfVal();\n  var createGridFields = function createGridFields(itemsField) {\n    return [type, requiredNumber('columns'), itemsField];\n  };\n  var htmlPanelFields = [type, requiredString('html'), defaultedStringEnum('presets', 'presentation', ['presentation', 'document'])];\n  var htmlPanelSchema = objOf(htmlPanelFields);\n  var iframeFields = formComponentWithLabelFields.concat([defaultedBoolean('border', false), defaultedBoolean('sandboxed', true), defaultedBoolean('streamContent', false), defaultedBoolean('transparent', true)]);\n  var iframeSchema = objOf(iframeFields);\n  var iframeDataProcessor = string;\n  var imagePreviewSchema = objOf(formComponentFields.concat([optionString('height')]));\n  var imagePreviewDataProcessor = objOf([requiredString('url'), optionNumber('zoom'), optionNumber('cachedWidth'), optionNumber('cachedHeight')]);\n  var inputFields = formComponentWithLabelFields.concat([optionString('inputMode'), optionString('placeholder'), defaultedBoolean('maximized', false), enabled]);\n  var inputSchema = objOf(inputFields);\n  var inputDataProcessor = string;\n  var createLabelFields = function createLabelFields(itemsField) {\n    return [type, label, itemsField, defaultedStringEnum('align', 'start', ['start', 'center', 'end'])];\n  };\n  var listBoxSingleItemFields = [text, value$1];\n  var listBoxNestedItemFields = [text, requiredArrayOf('items', thunkOf('items', function () {\n    return listBoxItemSchema;\n  }))];\n  var listBoxItemSchema = oneOf([objOf(listBoxSingleItemFields), objOf(listBoxNestedItemFields)]);\n  var listBoxFields = formComponentWithLabelFields.concat([requiredArrayOf('items', listBoxItemSchema), enabled]);\n  var listBoxSchema = objOf(listBoxFields);\n  var listBoxDataProcessor = string;\n  var selectBoxFields = formComponentWithLabelFields.concat([requiredArrayOfObj('items', [text, value$1]), defaultedNumber('size', 1), enabled]);\n  var selectBoxSchema = objOf(selectBoxFields);\n  var selectBoxDataProcessor = string;\n  var sizeInputFields = formComponentWithLabelFields.concat([defaultedBoolean('constrain', true), enabled]);\n  var sizeInputSchema = objOf(sizeInputFields);\n  var sizeInputDataProcessor = objOf([requiredString('width'), requiredString('height')]);\n  var sliderFields = formComponentFields.concat([label, defaultedNumber('min', 0), defaultedNumber('max', 0)]);\n  var sliderSchema = objOf(sliderFields);\n  var sliderInputDataProcessor = number;\n  var tableFields = [type, requiredArrayOf('header', string), requiredArrayOf('cells', arrOf(string))];\n  var tableSchema = objOf(tableFields);\n  var textAreaFields = formComponentWithLabelFields.concat([optionString('placeholder'), defaultedBoolean('maximized', false), enabled]);\n  var textAreaSchema = objOf(textAreaFields);\n  var textAreaDataProcessor = string;\n  var baseTreeItemFields = [requiredStringEnum('type', ['directory', 'leaf']), title$5, requiredString('id'), optionOf('menu', MenuButtonSchema)];\n  var treeItemLeafFields = baseTreeItemFields;\n  var treeItemLeafSchema = objOf(treeItemLeafFields);\n  var treeItemDirectoryFields = baseTreeItemFields.concat([requiredArrayOf('children', thunkOf('children', function () {\n    return choose$2('type', {\n      directory: treeItemDirectorySchema,\n      leaf: treeItemLeafSchema\n    });\n  }))]);\n  var treeItemDirectorySchema = objOf(treeItemDirectoryFields);\n  var treeItemSchema = choose$2('type', {\n    directory: treeItemDirectorySchema,\n    leaf: treeItemLeafSchema\n  });\n  var treeFields = [type, requiredArrayOf('items', treeItemSchema), optionFunction('onLeafAction'), optionFunction('onToggleExpand'), defaultedArrayOf('defaultExpandedIds', [], string), optionString('defaultSelectedId')];\n  var treeSchema = objOf(treeFields);\n  var urlInputFields = formComponentWithLabelFields.concat([defaultedStringEnum('filetype', 'file', ['image', 'media', 'file']), enabled, optionString('picker_text')]);\n  var urlInputSchema = objOf(urlInputFields);\n  var urlInputDataProcessor = objOf([value$1, defaultedMeta]);\n  var createItemsField = function createItemsField(name) {\n    return field$1('items', 'items', required$2(), arrOf(valueOf(function (v) {\n      return asRaw(\"Checking item of \".concat(name), itemSchema, v).fold(function (sErr) {\n        return Result.error(formatError(sErr));\n      }, function (passValue) {\n        return Result.value(passValue);\n      });\n    })));\n  };\n  var itemSchema = valueThunk(function () {\n    return choose$2('type', {\n      alertbanner: alertBannerSchema,\n      bar: objOf(createBarFields(createItemsField('bar'))),\n      button: buttonSchema,\n      checkbox: checkboxSchema,\n      colorinput: colorInputSchema,\n      colorpicker: colorPickerSchema,\n      dropzone: dropZoneSchema,\n      grid: objOf(createGridFields(createItemsField('grid'))),\n      iframe: iframeSchema,\n      input: inputSchema,\n      listbox: listBoxSchema,\n      selectbox: selectBoxSchema,\n      sizeinput: sizeInputSchema,\n      slider: sliderSchema,\n      textarea: textAreaSchema,\n      urlinput: urlInputSchema,\n      customeditor: customEditorSchema,\n      htmlpanel: htmlPanelSchema,\n      imagepreview: imagePreviewSchema,\n      collection: collectionSchema,\n      label: objOf(createLabelFields(createItemsField('label'))),\n      table: tableSchema,\n      tree: treeSchema,\n      panel: panelSchema\n    });\n  });\n  var panelFields = [type, defaulted('classes', []), requiredArrayOf('items', itemSchema)];\n  var panelSchema = objOf(panelFields);\n  var tabFields = [generatedName('tab'), title$5, requiredArrayOf('items', itemSchema)];\n  var tabPanelFields = [type, requiredArrayOfObj('tabs', tabFields)];\n  var tabPanelSchema = objOf(tabPanelFields);\n  var dialogButtonFields = dialogFooterButtonFields;\n  var dialogButtonSchema = dialogFooterButtonSchema;\n  var dialogSchema = objOf([requiredString('title'), requiredOf('body', choose$2('type', {\n    panel: panelSchema,\n    tabpanel: tabPanelSchema\n  })), defaultedString('size', 'normal'), defaultedArrayOf('buttons', [], dialogButtonSchema), defaulted('initialData', {}), defaultedFunction('onAction', noop), defaultedFunction('onChange', noop), defaultedFunction('onSubmit', noop), defaultedFunction('onClose', noop), defaultedFunction('onCancel', noop), defaultedFunction('onTabChange', noop)]);\n  var createDialog = function createDialog(spec) {\n    return asRaw('dialog', dialogSchema, spec);\n  };\n  var urlDialogButtonSchema = objOf([requiredStringEnum('type', ['cancel', 'custom'])].concat(_toConsumableArray(dialogButtonFields)));\n  var urlDialogSchema = objOf([requiredString('title'), requiredString('url'), optionNumber('height'), optionNumber('width'), optionArrayOf('buttons', urlDialogButtonSchema), defaultedFunction('onAction', noop), defaultedFunction('onCancel', noop), defaultedFunction('onClose', noop), defaultedFunction('onMessage', noop)]);\n  var createUrlDialog = function createUrlDialog(spec) {\n    return asRaw('dialog', urlDialogSchema, spec);\n  };\n  var getAllObjects = function getAllObjects(obj) {\n    if (isObject(obj)) {\n      return [obj].concat(bind$3(values(obj), getAllObjects));\n    } else if (isArray(obj)) {\n      return bind$3(obj, getAllObjects);\n    } else {\n      return [];\n    }\n  };\n  var isNamedItem = function isNamedItem(obj) {\n    return isString(obj.type) && isString(obj.name);\n  };\n  var dataProcessors = {\n    checkbox: checkboxDataProcessor,\n    colorinput: colorInputDataProcessor,\n    colorpicker: colorPickerDataProcessor,\n    dropzone: dropZoneDataProcessor,\n    input: inputDataProcessor,\n    iframe: iframeDataProcessor,\n    imagepreview: imagePreviewDataProcessor,\n    selectbox: selectBoxDataProcessor,\n    sizeinput: sizeInputDataProcessor,\n    slider: sliderInputDataProcessor,\n    listbox: listBoxDataProcessor,\n    size: sizeInputDataProcessor,\n    textarea: textAreaDataProcessor,\n    urlinput: urlInputDataProcessor,\n    customeditor: customEditorDataProcessor,\n    collection: collectionDataProcessor,\n    togglemenuitem: dialogToggleMenuItemDataProcessor\n  };\n  var getDataProcessor = function getDataProcessor(item) {\n    return Optional.from(dataProcessors[item.type]);\n  };\n  var getNamedItems = function getNamedItems(structure) {\n    return filter$2(getAllObjects(structure), isNamedItem);\n  };\n  var createDataValidator = function createDataValidator(structure) {\n    var namedItems = getNamedItems(structure);\n    var fields = bind$3(namedItems, function (item) {\n      return getDataProcessor(item).fold(function () {\n        return [];\n      }, function (schema) {\n        return [requiredOf(item.name, schema)];\n      });\n    });\n    return objOf(fields);\n  };\n  var extract = function extract(structure) {\n    var _a;\n    var internalDialog = getOrDie(createDialog(structure));\n    var dataValidator = createDataValidator(structure);\n    var initialData = (_a = structure.initialData) !== null && _a !== void 0 ? _a : {};\n    return {\n      internalDialog: internalDialog,\n      dataValidator: dataValidator,\n      initialData: initialData\n    };\n  };\n  var DialogManager = {\n    open: function open(factory, structure) {\n      var extraction = extract(structure);\n      return factory(extraction.internalDialog, extraction.initialData, extraction.dataValidator);\n    },\n    openUrl: function openUrl(factory, structure) {\n      var internalDialog = getOrDie(createUrlDialog(structure));\n      return factory(internalDialog);\n    },\n    redial: function redial(structure) {\n      return extract(structure);\n    }\n  };\n  var events = function events(reflectingConfig, reflectingState) {\n    var update = function update(component, data) {\n      reflectingConfig.updateState.each(function (updateState) {\n        var newState = updateState(component, data);\n        reflectingState.set(newState);\n      });\n      reflectingConfig.renderComponents.each(function (renderComponents) {\n        var newComponents = renderComponents(data, reflectingState.get());\n        var replacer = reflectingConfig.reuseDom ? withReuse : withoutReuse;\n        replacer(component, newComponents);\n      });\n    };\n    return derive$2([run$1(receive(), function (component, message) {\n      var receivingData = message;\n      if (!receivingData.universal) {\n        var channel = reflectingConfig.channel;\n        if (contains$2(receivingData.channels, channel)) {\n          update(component, receivingData.data);\n        }\n      }\n    }), runOnAttached(function (comp, _se) {\n      reflectingConfig.initialData.each(function (rawData) {\n        update(comp, rawData);\n      });\n    })]);\n  };\n  var ActiveReflecting = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    events: events\n  });\n  var getState = function getState(component, replaceConfig, reflectState) {\n    return reflectState;\n  };\n  var ReflectingApis = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getState: getState\n  });\n  var ReflectingSchema = [required$1('channel'), option$3('renderComponents'), option$3('updateState'), option$3('initialData'), defaultedBoolean('reuseDom', true)];\n  var init = function init() {\n    var cell = Cell(Optional.none());\n    var clear = function clear() {\n      return cell.set(Optional.none());\n    };\n    var readState = function readState() {\n      return cell.get().getOr('none');\n    };\n    return {\n      readState: readState,\n      get: cell.get,\n      set: cell.set,\n      clear: clear\n    };\n  };\n  var ReflectingState = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    init: init\n  });\n  var Reflecting = create$4({\n    fields: ReflectingSchema,\n    name: 'reflecting',\n    active: ActiveReflecting,\n    apis: ReflectingApis,\n    state: ReflectingState\n  });\n  var toValidValues = function toValidValues(values) {\n    var errors = [];\n    var result = {};\n    each(values, function (value, name) {\n      value.fold(function () {\n        errors.push(name);\n      }, function (v) {\n        result[name] = v;\n      });\n    });\n    return errors.length > 0 ? Result.error(errors) : Result.value(result);\n  };\n  var renderBodyPanel = function renderBodyPanel(spec, dialogData, backstage) {\n    var memForm = record(Form.sketch(function (parts) {\n      return {\n        dom: {\n          tag: 'div',\n          classes: ['tox-form'].concat(spec.classes)\n        },\n        components: map$2(spec.items, function (item) {\n          return interpretInForm(parts, item, dialogData, backstage);\n        })\n      };\n    }));\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__body']\n      },\n      components: [{\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__body-content']\n        },\n        components: [memForm.asSpec()]\n      }],\n      behaviours: derive$1([Keying.config({\n        mode: 'acyclic',\n        useTabstopAt: not(isPseudoStop)\n      }), ComposingConfigs.memento(memForm), memento(memForm, {\n        postprocess: function postprocess(formValue) {\n          return toValidValues(formValue).fold(function (err) {\n            console.error(err);\n            return {};\n          }, identity);\n        }\n      }), config('dialog-body-panel', [run$1(focusin(), function (comp, se) {\n        comp.getSystem().broadcastOn([dialogFocusShiftedChannel], {\n          newFocus: Optional.some(se.event.target)\n        });\n      })])])\n    };\n  };\n  var factory$3 = function factory$3(detail, _spec) {\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: detail.components,\n      events: events$a(detail.action),\n      behaviours: augment(detail.tabButtonBehaviours, [Focusing.config({}), Keying.config({\n        mode: 'execution',\n        useSpace: true,\n        useEnter: true\n      }), Representing.config({\n        store: {\n          mode: 'memory',\n          initialValue: detail.value\n        }\n      })]),\n      domModification: detail.domModification\n    };\n  };\n  var TabButton = single({\n    name: 'TabButton',\n    configFields: [defaulted('uid', undefined), required$1('value'), field$1('dom', 'dom', mergeWithThunk(function () {\n      return {\n        attributes: {\n          'role': 'tab',\n          'id': generate$6('aria'),\n          'aria-selected': 'false'\n        }\n      };\n    }), anyValue()), option$3('action'), defaulted('domModification', {}), field('tabButtonBehaviours', [Focusing, Keying, Representing]), required$1('view')],\n    factory: factory$3\n  });\n  var schema$1 = constant$1([required$1('tabs'), required$1('dom'), defaulted('clickToDismiss', false), field('tabbarBehaviours', [Highlighting, Keying]), markers$1(['tabClass', 'selectedClass'])]);\n  var tabsPart = group({\n    factory: TabButton,\n    name: 'tabs',\n    unit: 'tab',\n    overrides: function overrides(barDetail) {\n      var dismissTab$1 = function dismissTab$1(tabbar, button) {\n        Highlighting.dehighlight(tabbar, button);\n        emitWith(tabbar, dismissTab(), {\n          tabbar: tabbar,\n          button: button\n        });\n      };\n      var changeTab$1 = function changeTab$1(tabbar, button) {\n        Highlighting.highlight(tabbar, button);\n        emitWith(tabbar, changeTab(), {\n          tabbar: tabbar,\n          button: button\n        });\n      };\n      return {\n        action: function action(button) {\n          var tabbar = button.getSystem().getByUid(barDetail.uid).getOrDie();\n          var activeButton = Highlighting.isHighlighted(tabbar, button);\n          var response = function () {\n            if (activeButton && barDetail.clickToDismiss) {\n              return dismissTab$1;\n            } else if (!activeButton) {\n              return changeTab$1;\n            } else {\n              return noop;\n            }\n          }();\n          response(tabbar, button);\n        },\n        domModification: {\n          classes: [barDetail.markers.tabClass]\n        }\n      };\n    }\n  });\n  var parts$1 = constant$1([tabsPart]);\n  var factory$2 = function factory$2(detail, components, _spec, _externals) {\n    return {\n      'uid': detail.uid,\n      'dom': detail.dom,\n      components: components,\n      'debug.sketcher': 'Tabbar',\n      'domModification': {\n        attributes: {\n          role: 'tablist'\n        }\n      },\n      'behaviours': augment(detail.tabbarBehaviours, [Highlighting.config({\n        highlightClass: detail.markers.selectedClass,\n        itemClass: detail.markers.tabClass,\n        onHighlight: function onHighlight(tabbar, tab) {\n          set$9(tab.element, 'aria-selected', 'true');\n        },\n        onDehighlight: function onDehighlight(tabbar, tab) {\n          set$9(tab.element, 'aria-selected', 'false');\n        }\n      }), Keying.config({\n        mode: 'flow',\n        getInitial: function getInitial(tabbar) {\n          return Highlighting.getHighlighted(tabbar).map(function (tab) {\n            return tab.element;\n          });\n        },\n        selector: '.' + detail.markers.tabClass,\n        executeOnMove: true\n      })])\n    };\n  };\n  var Tabbar = composite({\n    name: 'Tabbar',\n    configFields: schema$1(),\n    partFields: parts$1(),\n    factory: factory$2\n  });\n  var factory$1 = function factory$1(detail, _spec) {\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      behaviours: augment(detail.tabviewBehaviours, [Replacing.config({})]),\n      domModification: {\n        attributes: {\n          role: 'tabpanel'\n        }\n      }\n    };\n  };\n  var Tabview = single({\n    name: 'Tabview',\n    configFields: [field('tabviewBehaviours', [Replacing])],\n    factory: factory$1\n  });\n  var schema = constant$1([defaulted('selectFirst', true), onHandler('onChangeTab'), onHandler('onDismissTab'), defaulted('tabs', []), field('tabSectionBehaviours', [])]);\n  var barPart = required({\n    factory: Tabbar,\n    schema: [required$1('dom'), requiredObjOf('markers', [required$1('tabClass'), required$1('selectedClass')])],\n    name: 'tabbar',\n    defaults: function defaults(detail) {\n      return {\n        tabs: detail.tabs\n      };\n    }\n  });\n  var viewPart = required({\n    factory: Tabview,\n    name: 'tabview'\n  });\n  var parts = constant$1([barPart, viewPart]);\n  var factory = function factory(detail, components, _spec, _externals) {\n    var changeTab$1 = function changeTab$1(button) {\n      var tabValue = Representing.getValue(button);\n      getPart(button, detail, 'tabview').each(function (tabview) {\n        var tabWithValue = find$5(detail.tabs, function (t) {\n          return t.value === tabValue;\n        });\n        tabWithValue.each(function (tabData) {\n          var panel = tabData.view();\n          getOpt(button.element, 'id').each(function (id) {\n            set$9(tabview.element, 'aria-labelledby', id);\n          });\n          Replacing.set(tabview, panel);\n          detail.onChangeTab(tabview, button, panel);\n        });\n      });\n    };\n    var changeTabBy = function changeTabBy(section, byPred) {\n      getPart(section, detail, 'tabbar').each(function (tabbar) {\n        byPred(tabbar).each(emitExecute);\n      });\n    };\n    return {\n      uid: detail.uid,\n      dom: detail.dom,\n      components: components,\n      behaviours: get$3(detail.tabSectionBehaviours),\n      events: derive$2(flatten([detail.selectFirst ? [runOnAttached(function (section, _simulatedEvent) {\n        changeTabBy(section, Highlighting.getFirst);\n      })] : [], [run$1(changeTab(), function (section, simulatedEvent) {\n        var button = simulatedEvent.event.button;\n        changeTab$1(button);\n      }), run$1(dismissTab(), function (section, simulatedEvent) {\n        var button = simulatedEvent.event.button;\n        detail.onDismissTab(section, button);\n      })]])),\n      apis: {\n        getViewItems: function getViewItems(section) {\n          return getPart(section, detail, 'tabview').map(function (tabview) {\n            return Replacing.contents(tabview);\n          }).getOr([]);\n        },\n        showTab: function showTab(section, tabKey) {\n          var getTabIfNotActive = function getTabIfNotActive(tabbar) {\n            var candidates = Highlighting.getCandidates(tabbar);\n            var optTab = find$5(candidates, function (c) {\n              return Representing.getValue(c) === tabKey;\n            });\n            return optTab.filter(function (tab) {\n              return !Highlighting.isHighlighted(tabbar, tab);\n            });\n          };\n          changeTabBy(section, getTabIfNotActive);\n        }\n      }\n    };\n  };\n  var TabSection = composite({\n    name: 'TabSection',\n    configFields: schema(),\n    partFields: parts(),\n    factory: factory,\n    apis: {\n      getViewItems: function getViewItems(apis, component) {\n        return apis.getViewItems(component);\n      },\n      showTab: function showTab(apis, component, tabKey) {\n        apis.showTab(component, tabKey);\n      }\n    }\n  });\n  var measureHeights = function measureHeights(allTabs, tabview, tabviewComp) {\n    return map$2(allTabs, function (_tab, i) {\n      Replacing.set(tabviewComp, allTabs[i].view());\n      var rect = tabview.dom.getBoundingClientRect();\n      Replacing.set(tabviewComp, []);\n      return rect.height;\n    });\n  };\n  var getMaxHeight = function getMaxHeight(heights) {\n    return head(sort(heights, function (a, b) {\n      if (a > b) {\n        return -1;\n      } else if (a < b) {\n        return +1;\n      } else {\n        return 0;\n      }\n    }));\n  };\n  var getMaxTabviewHeight = function getMaxTabviewHeight(dialog, tabview, tablist) {\n    var documentElement$1 = documentElement(dialog).dom;\n    var rootElm = ancestor(dialog, '.tox-dialog-wrap').getOr(dialog);\n    var isFixed = get$e(rootElm, 'position') === 'fixed';\n    var maxHeight;\n    if (isFixed) {\n      maxHeight = Math.max(documentElement$1.clientHeight, window.innerHeight);\n    } else {\n      maxHeight = Math.max(documentElement$1.offsetHeight, documentElement$1.scrollHeight);\n    }\n    var tabviewHeight = get$d(tabview);\n    var isTabListBeside = tabview.dom.offsetLeft >= tablist.dom.offsetLeft + get$c(tablist);\n    var currentTabHeight = isTabListBeside ? Math.max(get$d(tablist), tabviewHeight) : tabviewHeight;\n    var dialogTopMargin = parseInt(get$e(dialog, 'margin-top'), 10) || 0;\n    var dialogBottomMargin = parseInt(get$e(dialog, 'margin-bottom'), 10) || 0;\n    var dialogHeight = get$d(dialog) + dialogTopMargin + dialogBottomMargin;\n    var chromeHeight = dialogHeight - currentTabHeight;\n    return maxHeight - chromeHeight;\n  };\n  var showTab = function showTab(allTabs, comp) {\n    head(allTabs).each(function (tab) {\n      return TabSection.showTab(comp, tab.value);\n    });\n  };\n  var setTabviewHeight = function setTabviewHeight(tabview, height) {\n    set$8(tabview, 'height', height + 'px');\n    set$8(tabview, 'flex-basis', height + 'px');\n  };\n  var updateTabviewHeight = function updateTabviewHeight(dialogBody, tabview, maxTabHeight) {\n    ancestor(dialogBody, '[role=\"dialog\"]').each(function (dialog) {\n      descendant(dialog, '[role=\"tablist\"]').each(function (tablist) {\n        maxTabHeight.get().map(function (height) {\n          set$8(tabview, 'height', '0');\n          set$8(tabview, 'flex-basis', '0');\n          return Math.min(height, getMaxTabviewHeight(dialog, tabview, tablist));\n        }).each(function (height) {\n          setTabviewHeight(tabview, height);\n        });\n      });\n    });\n  };\n  var getTabview = function getTabview(dialog) {\n    return descendant(dialog, '[role=\"tabpanel\"]');\n  };\n  var smartMode = function smartMode(allTabs) {\n    var maxTabHeight = value$2();\n    var extraEvents = [runOnAttached(function (comp) {\n      var dialog = comp.element;\n      getTabview(dialog).each(function (tabview) {\n        set$8(tabview, 'visibility', 'hidden');\n        comp.getSystem().getByDom(tabview).toOptional().each(function (tabviewComp) {\n          var heights = measureHeights(allTabs, tabview, tabviewComp);\n          var maxTabHeightOpt = getMaxHeight(heights);\n          maxTabHeightOpt.fold(maxTabHeight.clear, maxTabHeight.set);\n        });\n        updateTabviewHeight(dialog, tabview, maxTabHeight);\n        remove$6(tabview, 'visibility');\n        showTab(allTabs, comp);\n        requestAnimationFrame(function () {\n          updateTabviewHeight(dialog, tabview, maxTabHeight);\n        });\n      });\n    }), run$1(windowResize(), function (comp) {\n      var dialog = comp.element;\n      getTabview(dialog).each(function (tabview) {\n        updateTabviewHeight(dialog, tabview, maxTabHeight);\n      });\n    }), run$1(formResizeEvent, function (comp, _se) {\n      var dialog = comp.element;\n      getTabview(dialog).each(function (tabview) {\n        var oldFocus = active$1(getRootNode(tabview));\n        set$8(tabview, 'visibility', 'hidden');\n        var oldHeight = getRaw(tabview, 'height').map(function (h) {\n          return parseInt(h, 10);\n        });\n        remove$6(tabview, 'height');\n        remove$6(tabview, 'flex-basis');\n        var newHeight = tabview.dom.getBoundingClientRect().height;\n        var hasGrown = oldHeight.forall(function (h) {\n          return newHeight > h;\n        });\n        if (hasGrown) {\n          maxTabHeight.set(newHeight);\n          updateTabviewHeight(dialog, tabview, maxTabHeight);\n        } else {\n          oldHeight.each(function (h) {\n            setTabviewHeight(tabview, h);\n          });\n        }\n        remove$6(tabview, 'visibility');\n        oldFocus.each(focus$3);\n      });\n    })];\n    var selectFirst = false;\n    return {\n      extraEvents: extraEvents,\n      selectFirst: selectFirst\n    };\n  };\n  var SendDataToSectionChannel = 'send-data-to-section';\n  var SendDataToViewChannel = 'send-data-to-view';\n  var renderTabPanel = function renderTabPanel(spec, dialogData, backstage) {\n    var storedValue = Cell({});\n    var updateDataWithForm = function updateDataWithForm(form) {\n      var formData = Representing.getValue(form);\n      var validData = toValidValues(formData).getOr({});\n      var currentData = storedValue.get();\n      var newData = deepMerge(currentData, validData);\n      storedValue.set(newData);\n    };\n    var setDataOnForm = function setDataOnForm(form) {\n      var tabData = storedValue.get();\n      Representing.setValue(form, tabData);\n    };\n    var oldTab = Cell(null);\n    var allTabs = map$2(spec.tabs, function (tab) {\n      return {\n        value: tab.name,\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__body-nav-item']\n        },\n        components: [text$2(backstage.shared.providers.translate(tab.title))],\n        view: function view() {\n          return [Form.sketch(function (parts) {\n            return {\n              dom: {\n                tag: 'div',\n                classes: ['tox-form']\n              },\n              components: map$2(tab.items, function (item) {\n                return interpretInForm(parts, item, dialogData, backstage);\n              }),\n              formBehaviours: derive$1([Keying.config({\n                mode: 'acyclic',\n                useTabstopAt: not(isPseudoStop)\n              }), config('TabView.form.events', [runOnAttached(setDataOnForm), runOnDetached(updateDataWithForm)]), Receiving.config({\n                channels: wrapAll([{\n                  key: SendDataToSectionChannel,\n                  value: {\n                    onReceive: updateDataWithForm\n                  }\n                }, {\n                  key: SendDataToViewChannel,\n                  value: {\n                    onReceive: setDataOnForm\n                  }\n                }])\n              })])\n            };\n          })];\n        }\n      };\n    });\n    var tabMode = smartMode(allTabs);\n    return TabSection.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__body']\n      },\n      onChangeTab: function onChangeTab(section, button, _viewItems) {\n        var name = Representing.getValue(button);\n        emitWith(section, formTabChangeEvent, {\n          name: name,\n          oldName: oldTab.get()\n        });\n        oldTab.set(name);\n      },\n      tabs: allTabs,\n      components: [TabSection.parts.tabbar({\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__body-nav']\n        },\n        components: [Tabbar.parts.tabs({})],\n        markers: {\n          tabClass: 'tox-tab',\n          selectedClass: 'tox-dialog__body-nav-item--active'\n        },\n        tabbarBehaviours: derive$1([Tabstopping.config({})])\n      }), TabSection.parts.tabview({\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__body-content']\n        }\n      })],\n      selectFirst: tabMode.selectFirst,\n      tabSectionBehaviours: derive$1([config('tabpanel', tabMode.extraEvents), Keying.config({\n        mode: 'acyclic'\n      }), Composing.config({\n        find: function find(comp) {\n          return head(TabSection.getViewItems(comp));\n        }\n      }), withComp(Optional.none(), function (tsection) {\n        tsection.getSystem().broadcastOn([SendDataToSectionChannel], {});\n        return storedValue.get();\n      }, function (tsection, value) {\n        storedValue.set(value);\n        tsection.getSystem().broadcastOn([SendDataToViewChannel], {});\n      })])\n    });\n  };\n  var renderBody = function renderBody(spec, dialogId, contentId, backstage, ariaAttrs) {\n    var renderComponents = function renderComponents(incoming) {\n      var body = incoming.body;\n      switch (body.type) {\n        case 'tabpanel':\n          {\n            return [renderTabPanel(body, incoming.initialData, backstage)];\n          }\n        default:\n          {\n            return [renderBodyPanel(body, incoming.initialData, backstage)];\n          }\n      }\n    };\n    var updateState = function updateState(_comp, incoming) {\n      return Optional.some({\n        isTabPanel: function isTabPanel() {\n          return incoming.body.type === 'tabpanel';\n        }\n      });\n    };\n    var ariaAttributes = {\n      'aria-live': 'polite'\n    };\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__content-js'],\n        attributes: _objectSpread({}, contentId.map(function (x) {\n          return {\n            id: x\n          };\n        }).getOr({}), ariaAttrs ? ariaAttributes : {})\n      },\n      components: [],\n      behaviours: derive$1([ComposingConfigs.childAt(0), Reflecting.config({\n        channel: \"\".concat(bodyChannel, \"-\").concat(dialogId),\n        updateState: updateState,\n        renderComponents: renderComponents,\n        initialData: spec\n      })])\n    };\n  };\n  var renderInlineBody = function renderInlineBody(spec, dialogId, contentId, backstage, ariaAttrs) {\n    return renderBody(spec, dialogId, Optional.some(contentId), backstage, ariaAttrs);\n  };\n  var renderModalBody = function renderModalBody(spec, dialogId, backstage) {\n    var bodySpec = renderBody(spec, dialogId, Optional.none(), backstage, false);\n    return ModalDialog.parts.body(bodySpec);\n  };\n  var renderIframeBody = function renderIframeBody(spec) {\n    var bodySpec = {\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__content-js']\n      },\n      components: [{\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__body-iframe']\n        },\n        components: [craft(Optional.none(), {\n          dom: {\n            tag: 'iframe',\n            attributes: {\n              src: spec.url\n            }\n          },\n          behaviours: derive$1([Tabstopping.config({}), Focusing.config({})])\n        })]\n      }],\n      behaviours: derive$1([Keying.config({\n        mode: 'acyclic',\n        useTabstopAt: not(isPseudoStop)\n      })])\n    };\n    return ModalDialog.parts.body(bodySpec);\n  };\n  var isTouch = global$5.deviceType.isTouch();\n  var hiddenHeader = function hiddenHeader(title, close) {\n    return {\n      dom: {\n        tag: 'div',\n        styles: {\n          display: 'none'\n        },\n        classes: ['tox-dialog__header']\n      },\n      components: [title, close]\n    };\n  };\n  var pClose = function pClose(onClose, providersBackstage) {\n    return ModalDialog.parts.close(Button.sketch({\n      dom: {\n        tag: 'button',\n        classes: ['tox-button', 'tox-button--icon', 'tox-button--naked'],\n        attributes: {\n          'type': 'button',\n          'aria-label': providersBackstage.translate('Close')\n        }\n      },\n      action: onClose,\n      buttonBehaviours: derive$1([Tabstopping.config({})])\n    }));\n  };\n  var pUntitled = function pUntitled() {\n    return ModalDialog.parts.title({\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__title'],\n        innerHtml: '',\n        styles: {\n          display: 'none'\n        }\n      }\n    });\n  };\n  var pBodyMessage = function pBodyMessage(message, providersBackstage) {\n    return ModalDialog.parts.body({\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__body']\n      },\n      components: [{\n        dom: {\n          tag: 'div',\n          classes: ['tox-dialog__body-content']\n        },\n        components: [{\n          dom: fromHtml(\"<p>\".concat(sanitizeHtmlString(providersBackstage.translate(message)), \"</p>\"))\n        }]\n      }]\n    });\n  };\n  var pFooter = function pFooter(buttons) {\n    return ModalDialog.parts.footer({\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__footer']\n      },\n      components: buttons\n    });\n  };\n  var pFooterGroup = function pFooterGroup(startButtons, endButtons) {\n    return [Container.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__footer-start']\n      },\n      components: startButtons\n    }), Container.sketch({\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__footer-end']\n      },\n      components: endButtons\n    })];\n  };\n  var renderDialog$1 = function renderDialog$1(spec) {\n    var _objectSpread9;\n    var dialogClass = 'tox-dialog';\n    var blockerClass = dialogClass + '-wrap';\n    var blockerBackdropClass = blockerClass + '__backdrop';\n    var scrollLockClass = dialogClass + '__disable-scroll';\n    return ModalDialog.sketch({\n      lazySink: spec.lazySink,\n      onEscape: function onEscape(comp) {\n        spec.onEscape(comp);\n        return Optional.some(true);\n      },\n      useTabstopAt: function useTabstopAt(elem) {\n        return !isPseudoStop(elem);\n      },\n      firstTabstop: spec.firstTabstop,\n      dom: {\n        tag: 'div',\n        classes: [dialogClass].concat(spec.extraClasses),\n        styles: _objectSpread({\n          position: 'relative'\n        }, spec.extraStyles)\n      },\n      components: [spec.header, spec.body].concat(_toConsumableArray(spec.footer.toArray())),\n      parts: {\n        blocker: {\n          dom: fromHtml(\"<div class=\\\"\".concat(blockerClass, \"\\\"></div>\")),\n          components: [{\n            dom: {\n              tag: 'div',\n              classes: isTouch ? [blockerBackdropClass, blockerBackdropClass + '--opaque'] : [blockerBackdropClass]\n            }\n          }]\n        }\n      },\n      dragBlockClass: blockerClass,\n      modalBehaviours: derive$1([Focusing.config({}), config('dialog-events', spec.dialogEvents.concat([runOnSource(focusin(), function (comp, _se) {\n        Blocking.isBlocked(comp) ? noop() : Keying.focusIn(comp);\n      }), run$1(focusShifted(), function (comp, se) {\n        comp.getSystem().broadcastOn([dialogFocusShiftedChannel], {\n          newFocus: se.event.newFocus\n        });\n      })])), config('scroll-lock', [runOnAttached(function () {\n        add$2(body(), scrollLockClass);\n      }), runOnDetached(function () {\n        remove$2(body(), scrollLockClass);\n      })])].concat(_toConsumableArray(spec.extraBehaviours))),\n      eventOrder: _objectSpread((_objectSpread9 = {}, _defineProperty(_objectSpread9, execute$5(), ['dialog-events']), _defineProperty(_objectSpread9, attachedToDom(), ['scroll-lock', 'dialog-events', 'alloy.base.behaviour']), _defineProperty(_objectSpread9, detachedFromDom(), ['alloy.base.behaviour', 'dialog-events', 'scroll-lock']), _objectSpread9), spec.eventOrder)\n    });\n  };\n  var renderClose = function renderClose(providersBackstage) {\n    return Button.sketch({\n      dom: {\n        tag: 'button',\n        classes: ['tox-button', 'tox-button--icon', 'tox-button--naked'],\n        attributes: {\n          'type': 'button',\n          'aria-label': providersBackstage.translate('Close'),\n          'title': providersBackstage.translate('Close')\n        }\n      },\n      buttonBehaviours: derive$1([Tabstopping.config({})]),\n      components: [render$3('close', {\n        tag: 'span',\n        classes: ['tox-icon']\n      }, providersBackstage.icons)],\n      action: function action(comp) {\n        emit(comp, formCancelEvent);\n      }\n    });\n  };\n  var renderTitle = function renderTitle(spec, dialogId, titleId, providersBackstage) {\n    var renderComponents = function renderComponents(data) {\n      return [text$2(providersBackstage.translate(data.title))];\n    };\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__title'],\n        attributes: _objectSpread({}, titleId.map(function (x) {\n          return {\n            id: x\n          };\n        }).getOr({}))\n      },\n      components: [],\n      behaviours: derive$1([Reflecting.config({\n        channel: \"\".concat(titleChannel, \"-\").concat(dialogId),\n        initialData: spec,\n        renderComponents: renderComponents\n      })])\n    };\n  };\n  var renderDragHandle = function renderDragHandle() {\n    return {\n      dom: fromHtml('<div class=\"tox-dialog__draghandle\"></div>')\n    };\n  };\n  var renderInlineHeader = function renderInlineHeader(spec, dialogId, titleId, providersBackstage) {\n    return Container.sketch({\n      dom: fromHtml('<div class=\"tox-dialog__header\"></div>'),\n      components: [renderTitle(spec, dialogId, Optional.some(titleId), providersBackstage), renderDragHandle(), renderClose(providersBackstage)],\n      containerBehaviours: derive$1([Dragging.config({\n        mode: 'mouse',\n        blockerClass: 'blocker',\n        getTarget: function getTarget(handle) {\n          return closest$1(handle, '[role=\"dialog\"]').getOrDie();\n        },\n        snaps: {\n          getSnapPoints: function getSnapPoints() {\n            return [];\n          },\n          leftAttr: 'data-drag-left',\n          topAttr: 'data-drag-top'\n        }\n      })])\n    });\n  };\n  var renderModalHeader = function renderModalHeader(spec, dialogId, providersBackstage) {\n    var pTitle = ModalDialog.parts.title(renderTitle(spec, dialogId, Optional.none(), providersBackstage));\n    var pHandle = ModalDialog.parts.draghandle(renderDragHandle());\n    var pClose = ModalDialog.parts.close(renderClose(providersBackstage));\n    var components = [pTitle].concat(spec.draggable ? [pHandle] : []).concat([pClose]);\n    return Container.sketch({\n      dom: fromHtml('<div class=\"tox-dialog__header\"></div>'),\n      components: components\n    });\n  };\n  var getHeader = function getHeader(title, dialogId, backstage) {\n    return renderModalHeader({\n      title: backstage.shared.providers.translate(title),\n      draggable: backstage.dialog.isDraggableModal()\n    }, dialogId, backstage.shared.providers);\n  };\n  var getBusySpec = function getBusySpec(message, bs, providers, headerHeight) {\n    return {\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog__busy-spinner'],\n        attributes: {\n          'aria-label': providers.translate(message)\n        },\n        styles: {\n          left: '0px',\n          right: '0px',\n          bottom: '0px',\n          top: \"\".concat(headerHeight.getOr(0), \"px\"),\n          position: 'absolute'\n        }\n      },\n      behaviours: bs,\n      components: [{\n        dom: fromHtml('<div class=\"tox-spinner\"><div></div><div></div><div></div></div>')\n      }]\n    };\n  };\n  var getEventExtras = function getEventExtras(lazyDialog, providers, extra) {\n    return {\n      onClose: function onClose() {\n        return extra.closeWindow();\n      },\n      onBlock: function onBlock(blockEvent) {\n        var headerHeight = descendant(lazyDialog().element, '.tox-dialog__header').map(function (header) {\n          return get$d(header);\n        });\n        ModalDialog.setBusy(lazyDialog(), function (_comp, bs) {\n          return getBusySpec(blockEvent.message, bs, providers, headerHeight);\n        });\n      },\n      onUnblock: function onUnblock() {\n        ModalDialog.setIdle(lazyDialog());\n      }\n    };\n  };\n  var fullscreenClass = 'tox-dialog--fullscreen';\n  var largeDialogClass = 'tox-dialog--width-lg';\n  var mediumDialogClass = 'tox-dialog--width-md';\n  var getDialogSizeClass = function getDialogSizeClass(size) {\n    switch (size) {\n      case 'large':\n        return Optional.some(largeDialogClass);\n      case 'medium':\n        return Optional.some(mediumDialogClass);\n      default:\n        return Optional.none();\n    }\n  };\n  var updateDialogSizeClass = function updateDialogSizeClass(size, component) {\n    var dialogBody = SugarElement.fromDom(component.element.dom);\n    if (!has(dialogBody, fullscreenClass)) {\n      remove$1(dialogBody, [largeDialogClass, mediumDialogClass]);\n      getDialogSizeClass(size).each(function (dialogSizeClass) {\n        return add$2(dialogBody, dialogSizeClass);\n      });\n    }\n  };\n  var toggleFullscreen = function toggleFullscreen(comp, currentSize) {\n    var dialogBody = SugarElement.fromDom(comp.element.dom);\n    var classes = get$7(dialogBody);\n    var currentSizeClass = find$5(classes, function (c) {\n      return c === largeDialogClass || c === mediumDialogClass;\n    }).or(getDialogSizeClass(currentSize));\n    toggle$3(dialogBody, [fullscreenClass].concat(_toConsumableArray(currentSizeClass.toArray())));\n  };\n  var renderModalDialog = function renderModalDialog(spec, dialogEvents, backstage) {\n    var _eventOrder9;\n    return build$1(renderDialog$1(_objectSpread({}, spec, {\n      firstTabstop: 1,\n      lazySink: backstage.shared.getSink,\n      extraBehaviours: [memory({})].concat(_toConsumableArray(spec.extraBehaviours)),\n      onEscape: function onEscape(comp) {\n        emit(comp, formCancelEvent);\n      },\n      dialogEvents: dialogEvents,\n      eventOrder: (_eventOrder9 = {}, _defineProperty(_eventOrder9, receive(), [Reflecting.name(), Receiving.name()]), _defineProperty(_eventOrder9, attachedToDom(), ['scroll-lock', Reflecting.name(), 'messages', 'dialog-events', 'alloy.base.behaviour']), _defineProperty(_eventOrder9, detachedFromDom(), ['alloy.base.behaviour', 'dialog-events', 'messages', Reflecting.name(), 'scroll-lock']), _eventOrder9)\n    })));\n  };\n  var mapMenuButtons = function mapMenuButtons(buttons) {\n    var menuItemStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var mapItems = function mapItems(button) {\n      var items = map$2(button.items, function (item) {\n        var cell = get$g(menuItemStates, item.name).getOr(Cell(false));\n        return _objectSpread({}, item, {\n          storage: cell\n        });\n      });\n      return _objectSpread({}, button, {\n        items: items\n      });\n    };\n    return map$2(buttons, function (button) {\n      return button.type === 'menu' ? mapItems(button) : button;\n    });\n  };\n  var extractCellsToObject = function extractCellsToObject(buttons) {\n    return foldl(buttons, function (acc, button) {\n      if (button.type === 'menu') {\n        var menuButton = button;\n        return foldl(menuButton.items, function (innerAcc, item) {\n          innerAcc[item.name] = item.storage;\n          return innerAcc;\n        }, acc);\n      }\n      return acc;\n    }, {});\n  };\n  var initCommonEvents = function initCommonEvents(fireApiEvent, extras) {\n    return [runWithTarget(focusin(), onFocus), fireApiEvent(formCloseEvent, function (_api, spec, _event, self) {\n      active$1(getRootNode(self.element)).fold(noop, blur$1);\n      extras.onClose();\n      spec.onClose();\n    }), fireApiEvent(formCancelEvent, function (api, spec, _event, self) {\n      spec.onCancel(api);\n      emit(self, formCloseEvent);\n    }), run$1(formUnblockEvent, function (_c, _se) {\n      return extras.onUnblock();\n    }), run$1(formBlockEvent, function (_c, se) {\n      return extras.onBlock(se.event);\n    })];\n  };\n  var initUrlDialog = function initUrlDialog(getInstanceApi, extras) {\n    var fireApiEvent = function fireApiEvent(eventName, f) {\n      return run$1(eventName, function (c, se) {\n        withSpec(c, function (spec, _c) {\n          f(getInstanceApi(), spec, se.event, c);\n        });\n      });\n    };\n    var withSpec = function withSpec(c, f) {\n      Reflecting.getState(c).get().each(function (currentDialog) {\n        f(currentDialog, c);\n      });\n    };\n    return [].concat(_toConsumableArray(initCommonEvents(fireApiEvent, extras)), [fireApiEvent(formActionEvent, function (api, spec, event) {\n      spec.onAction(api, {\n        name: event.name\n      });\n    })]);\n  };\n  var initDialog = function initDialog(getInstanceApi, extras, getSink) {\n    var fireApiEvent = function fireApiEvent(eventName, f) {\n      return run$1(eventName, function (c, se) {\n        withSpec(c, function (spec, _c) {\n          f(getInstanceApi(), spec, se.event, c);\n        });\n      });\n    };\n    var withSpec = function withSpec(c, f) {\n      Reflecting.getState(c).get().each(function (currentDialogInit) {\n        f(currentDialogInit.internalDialog, c);\n      });\n    };\n    return [].concat(_toConsumableArray(initCommonEvents(fireApiEvent, extras)), [fireApiEvent(formSubmitEvent, function (api, spec) {\n      return spec.onSubmit(api);\n    }), fireApiEvent(formChangeEvent, function (api, spec, event) {\n      spec.onChange(api, {\n        name: event.name\n      });\n    }), fireApiEvent(formActionEvent, function (api, spec, event, component) {\n      var focusIn = function focusIn() {\n        return component.getSystem().isConnected() ? Keying.focusIn(component) : undefined;\n      };\n      var isDisabled = function isDisabled(focused) {\n        return has$1(focused, 'disabled') || getOpt(focused, 'aria-disabled').exists(function (val) {\n          return val === 'true';\n        });\n      };\n      var rootNode = getRootNode(component.element);\n      var current = active$1(rootNode);\n      spec.onAction(api, {\n        name: event.name,\n        value: event.value\n      });\n      active$1(rootNode).fold(focusIn, function (focused) {\n        if (isDisabled(focused)) {\n          focusIn();\n        } else if (current.exists(function (cur) {\n          return contains(focused, cur) && isDisabled(cur);\n        })) {\n          focusIn();\n        } else {\n          getSink().toOptional().filter(function (sink) {\n            return !contains(sink.element, focused);\n          }).each(focusIn);\n        }\n      });\n    }), fireApiEvent(formTabChangeEvent, function (api, spec, event) {\n      spec.onTabChange(api, {\n        newTabName: event.name,\n        oldTabName: event.oldName\n      });\n    }), runOnDetached(function (component) {\n      var api = getInstanceApi();\n      Representing.setValue(component, api.getData());\n    })]);\n  };\n  var makeButton = function makeButton(button, backstage) {\n    return renderFooterButton(button, button.type, backstage);\n  };\n  var lookup = function lookup(compInSystem, footerButtons, buttonName) {\n    return find$5(footerButtons, function (button) {\n      return button.name === buttonName;\n    }).bind(function (memButton) {\n      return memButton.memento.getOpt(compInSystem);\n    });\n  };\n  var renderComponents = function renderComponents(_data, state) {\n    var footerButtons = state.map(function (s) {\n      return s.footerButtons;\n    }).getOr([]);\n    var buttonGroups = partition$3(footerButtons, function (button) {\n      return button.align === 'start';\n    });\n    var makeGroup = function makeGroup(edge, buttons) {\n      return Container.sketch({\n        dom: {\n          tag: 'div',\n          classes: [\"tox-dialog__footer-\".concat(edge)]\n        },\n        components: map$2(buttons, function (button) {\n          return button.memento.asSpec();\n        })\n      });\n    };\n    var startButtons = makeGroup('start', buttonGroups.pass);\n    var endButtons = makeGroup('end', buttonGroups.fail);\n    return [startButtons, endButtons];\n  };\n  var renderFooter = function renderFooter(initSpec, dialogId, backstage) {\n    var updateState = function updateState(comp, data) {\n      var footerButtons = map$2(data.buttons, function (button) {\n        var memButton = record(makeButton(button, backstage));\n        return {\n          name: button.name,\n          align: button.align,\n          memento: memButton\n        };\n      });\n      var lookupByName = function lookupByName(buttonName) {\n        return lookup(comp, footerButtons, buttonName);\n      };\n      return Optional.some({\n        lookupByName: lookupByName,\n        footerButtons: footerButtons\n      });\n    };\n    return {\n      dom: fromHtml('<div class=\"tox-dialog__footer\"></div>'),\n      components: [],\n      behaviours: derive$1([Reflecting.config({\n        channel: \"\".concat(footerChannel, \"-\").concat(dialogId),\n        initialData: initSpec,\n        updateState: updateState,\n        renderComponents: renderComponents\n      })])\n    };\n  };\n  var renderInlineFooter = function renderInlineFooter(initSpec, dialogId, backstage) {\n    return renderFooter(initSpec, dialogId, backstage);\n  };\n  var renderModalFooter = function renderModalFooter(initSpec, dialogId, backstage) {\n    return ModalDialog.parts.footer(renderFooter(initSpec, dialogId, backstage));\n  };\n  var getCompByName = function getCompByName(access, name) {\n    var root = access.getRoot();\n    if (root.getSystem().isConnected()) {\n      var form = Composing.getCurrent(access.getFormWrapper()).getOr(access.getFormWrapper());\n      return Form.getField(form, name).orThunk(function () {\n        var footer = access.getFooter();\n        var footerState = footer.bind(function (f) {\n          return Reflecting.getState(f).get();\n        });\n        return footerState.bind(function (f) {\n          return f.lookupByName(name);\n        });\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n  var validateData$1 = function validateData$1(access, data) {\n    var root = access.getRoot();\n    return Reflecting.getState(root).get().map(function (dialogState) {\n      return getOrDie(asRaw('data', dialogState.dataValidator, data));\n    }).getOr(data);\n  };\n  var getDialogApi = function getDialogApi(access, doRedial, menuItemStates) {\n    var withRoot = function withRoot(f) {\n      var root = access.getRoot();\n      if (root.getSystem().isConnected()) {\n        f(root);\n      }\n    };\n    var getData = function getData() {\n      var root = access.getRoot();\n      var valueComp = root.getSystem().isConnected() ? access.getFormWrapper() : root;\n      var representedValues = Representing.getValue(valueComp);\n      var menuItemCurrentState = map$1(menuItemStates, function (cell) {\n        return cell.get();\n      });\n      return _objectSpread({}, representedValues, menuItemCurrentState);\n    };\n    var setData = function setData(newData) {\n      withRoot(function (_) {\n        var prevData = instanceApi.getData();\n        var mergedData = deepMerge(prevData, newData);\n        var newInternalData = validateData$1(access, mergedData);\n        var form = access.getFormWrapper();\n        Representing.setValue(form, newInternalData);\n        each(menuItemStates, function (v, k) {\n          if (has$2(mergedData, k)) {\n            v.set(mergedData[k]);\n          }\n        });\n      });\n    };\n    var setEnabled = function setEnabled(name, state) {\n      getCompByName(access, name).each(state ? Disabling.enable : Disabling.disable);\n    };\n    var focus = function focus(name) {\n      getCompByName(access, name).each(Focusing.focus);\n    };\n    var block = function block(message) {\n      if (!isString(message)) {\n        throw new Error('The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument');\n      }\n      withRoot(function (root) {\n        emitWith(root, formBlockEvent, {\n          message: message\n        });\n      });\n    };\n    var unblock = function unblock() {\n      withRoot(function (root) {\n        emit(root, formUnblockEvent);\n      });\n    };\n    var showTab = function showTab(name) {\n      withRoot(function (_) {\n        var body = access.getBody();\n        var bodyState = Reflecting.getState(body);\n        if (bodyState.get().exists(function (b) {\n          return b.isTabPanel();\n        })) {\n          Composing.getCurrent(body).each(function (tabSection) {\n            TabSection.showTab(tabSection, name);\n          });\n        }\n      });\n    };\n    var redial = function redial(d) {\n      withRoot(function (root) {\n        var id = access.getId();\n        var dialogInit = doRedial(d);\n        var storedMenuButtons = mapMenuButtons(dialogInit.internalDialog.buttons, menuItemStates);\n        root.getSystem().broadcastOn([\"\".concat(dialogChannel, \"-\").concat(id)], dialogInit);\n        root.getSystem().broadcastOn([\"\".concat(titleChannel, \"-\").concat(id)], dialogInit.internalDialog);\n        root.getSystem().broadcastOn([\"\".concat(bodyChannel, \"-\").concat(id)], dialogInit.internalDialog);\n        root.getSystem().broadcastOn([\"\".concat(footerChannel, \"-\").concat(id)], _objectSpread({}, dialogInit.internalDialog, {\n          buttons: storedMenuButtons\n        }));\n        instanceApi.setData(dialogInit.initialData);\n      });\n    };\n    var close = function close() {\n      withRoot(function (root) {\n        emit(root, formCloseEvent);\n      });\n    };\n    var instanceApi = {\n      getData: getData,\n      setData: setData,\n      setEnabled: setEnabled,\n      focus: focus,\n      block: block,\n      unblock: unblock,\n      showTab: showTab,\n      redial: redial,\n      close: close,\n      toggleFullscreen: access.toggleFullscreen\n    };\n    return instanceApi;\n  };\n  var renderDialog = function renderDialog(dialogInit, extra, backstage) {\n    var dialogId = generate$6('dialog');\n    var internalDialog = dialogInit.internalDialog;\n    var header = getHeader(internalDialog.title, dialogId, backstage);\n    var dialogSize = Cell(internalDialog.size);\n    var dialogSizeClasses = getDialogSizeClass(dialogSize.get()).toArray();\n    var updateState = function updateState(comp, incoming) {\n      dialogSize.set(incoming.internalDialog.size);\n      updateDialogSizeClass(incoming.internalDialog.size, comp);\n      return Optional.some(incoming);\n    };\n    var body = renderModalBody({\n      body: internalDialog.body,\n      initialData: internalDialog.initialData\n    }, dialogId, backstage);\n    var storedMenuButtons = mapMenuButtons(internalDialog.buttons);\n    var objOfCells = extractCellsToObject(storedMenuButtons);\n    var footer = someIf(storedMenuButtons.length !== 0, renderModalFooter({\n      buttons: storedMenuButtons\n    }, dialogId, backstage));\n    var dialogEvents = initDialog(function () {\n      return instanceApi;\n    }, getEventExtras(function () {\n      return dialog;\n    }, backstage.shared.providers, extra), backstage.shared.getSink);\n    var spec = {\n      id: dialogId,\n      header: header,\n      body: body,\n      footer: footer,\n      extraClasses: dialogSizeClasses,\n      extraBehaviours: [Reflecting.config({\n        channel: \"\".concat(dialogChannel, \"-\").concat(dialogId),\n        updateState: updateState,\n        initialData: dialogInit\n      })],\n      extraStyles: {}\n    };\n    var dialog = renderModalDialog(spec, dialogEvents, backstage);\n    var modalAccess = function () {\n      var getForm = function getForm() {\n        var outerForm = ModalDialog.getBody(dialog);\n        return Composing.getCurrent(outerForm).getOr(outerForm);\n      };\n      var toggleFullscreen$1 = function toggleFullscreen$1() {\n        toggleFullscreen(dialog, dialogSize.get());\n      };\n      return {\n        getId: constant$1(dialogId),\n        getRoot: constant$1(dialog),\n        getBody: function getBody() {\n          return ModalDialog.getBody(dialog);\n        },\n        getFooter: function getFooter() {\n          return ModalDialog.getFooter(dialog);\n        },\n        getFormWrapper: getForm,\n        toggleFullscreen: toggleFullscreen$1\n      };\n    }();\n    var instanceApi = getDialogApi(modalAccess, extra.redial, objOfCells);\n    return {\n      dialog: dialog,\n      instanceApi: instanceApi\n    };\n  };\n  var renderInlineDialog = function renderInlineDialog(dialogInit, extra, backstage) {\n    var _eventOrder10;\n    var ariaAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var refreshDocking = arguments.length > 4 ? arguments[4] : undefined;\n    var dialogId = generate$6('dialog');\n    var dialogLabelId = generate$6('dialog-label');\n    var dialogContentId = generate$6('dialog-content');\n    var internalDialog = dialogInit.internalDialog;\n    var dialogSize = Cell(internalDialog.size);\n    var dialogSizeClass = getDialogSizeClass(dialogSize.get()).toArray();\n    var updateState = function updateState(comp, incoming) {\n      dialogSize.set(incoming.internalDialog.size);\n      updateDialogSizeClass(incoming.internalDialog.size, comp);\n      refreshDocking();\n      return Optional.some(incoming);\n    };\n    var memHeader = record(renderInlineHeader({\n      title: internalDialog.title,\n      draggable: true\n    }, dialogId, dialogLabelId, backstage.shared.providers));\n    var memBody = record(renderInlineBody({\n      body: internalDialog.body,\n      initialData: internalDialog.initialData\n    }, dialogId, dialogContentId, backstage, ariaAttrs));\n    var storagedMenuButtons = mapMenuButtons(internalDialog.buttons);\n    var objOfCells = extractCellsToObject(storagedMenuButtons);\n    var optMemFooter = someIf(storagedMenuButtons.length !== 0, record(renderInlineFooter({\n      buttons: storagedMenuButtons\n    }, dialogId, backstage)));\n    var dialogEvents = initDialog(function () {\n      return instanceApi;\n    }, {\n      onBlock: function onBlock(event) {\n        Blocking.block(dialog, function (_comp, bs) {\n          var headerHeight = memHeader.getOpt(dialog).map(function (dialog) {\n            return get$d(dialog.element);\n          });\n          return getBusySpec(event.message, bs, backstage.shared.providers, headerHeight);\n        });\n      },\n      onUnblock: function onUnblock() {\n        Blocking.unblock(dialog);\n      },\n      onClose: function onClose() {\n        return extra.closeWindow();\n      }\n    }, backstage.shared.getSink);\n    var inlineClass = 'tox-dialog-inline';\n    var dialog = build$1({\n      dom: {\n        tag: 'div',\n        classes: ['tox-dialog', inlineClass].concat(_toConsumableArray(dialogSizeClass)),\n        attributes: _defineProperty({\n          role: 'dialog'\n        }, 'aria-labelledby', dialogLabelId)\n      },\n      eventOrder: (_eventOrder10 = {}, _defineProperty(_eventOrder10, receive(), [Reflecting.name(), Receiving.name()]), _defineProperty(_eventOrder10, execute$5(), ['execute-on-form']), _defineProperty(_eventOrder10, attachedToDom(), ['reflecting', 'execute-on-form']), _eventOrder10),\n      behaviours: derive$1([Keying.config({\n        mode: 'cyclic',\n        onEscape: function onEscape(c) {\n          emit(c, formCloseEvent);\n          return Optional.some(true);\n        },\n        useTabstopAt: function useTabstopAt(elem) {\n          return !isPseudoStop(elem) && (name$3(elem) !== 'button' || get$f(elem, 'disabled') !== 'disabled');\n        },\n        firstTabstop: 1\n      }), Reflecting.config({\n        channel: \"\".concat(dialogChannel, \"-\").concat(dialogId),\n        updateState: updateState,\n        initialData: dialogInit\n      }), Focusing.config({}), config('execute-on-form', dialogEvents.concat([runOnSource(focusin(), function (comp, _se) {\n        Keying.focusIn(comp);\n      }), run$1(focusShifted(), function (comp, se) {\n        comp.getSystem().broadcastOn([dialogFocusShiftedChannel], {\n          newFocus: se.event.newFocus\n        });\n      })])), Blocking.config({\n        getRoot: function getRoot() {\n          return Optional.some(dialog);\n        }\n      }), Replacing.config({}), memory({})]),\n      components: [memHeader.asSpec(), memBody.asSpec()].concat(_toConsumableArray(optMemFooter.map(function (memFooter) {\n        return memFooter.asSpec();\n      }).toArray()))\n    });\n    var toggleFullscreen$1 = function toggleFullscreen$1() {\n      toggleFullscreen(dialog, dialogSize.get());\n    };\n    var instanceApi = getDialogApi({\n      getId: constant$1(dialogId),\n      getRoot: constant$1(dialog),\n      getFooter: function getFooter() {\n        return optMemFooter.map(function (memFooter) {\n          return memFooter.get(dialog);\n        });\n      },\n      getBody: function getBody() {\n        return memBody.get(dialog);\n      },\n      getFormWrapper: function getFormWrapper() {\n        var body = memBody.get(dialog);\n        return Composing.getCurrent(body).getOr(body);\n      },\n      toggleFullscreen: toggleFullscreen$1\n    }, extra.redial, objOfCells);\n    return {\n      dialog: dialog,\n      instanceApi: instanceApi\n    };\n  };\n  var global = tinymce.util.Tools.resolve('tinymce.util.URI');\n  var getUrlDialogApi = function getUrlDialogApi(root) {\n    var withRoot = function withRoot(f) {\n      if (root.getSystem().isConnected()) {\n        f(root);\n      }\n    };\n    var block = function block(message) {\n      if (!isString(message)) {\n        throw new Error('The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument');\n      }\n      withRoot(function (root) {\n        emitWith(root, formBlockEvent, {\n          message: message\n        });\n      });\n    };\n    var unblock = function unblock() {\n      withRoot(function (root) {\n        emit(root, formUnblockEvent);\n      });\n    };\n    var close = function close() {\n      withRoot(function (root) {\n        emit(root, formCloseEvent);\n      });\n    };\n    var sendMessage = function sendMessage(data) {\n      withRoot(function (root) {\n        root.getSystem().broadcastOn([bodySendMessageChannel], data);\n      });\n    };\n    return {\n      block: block,\n      unblock: unblock,\n      close: close,\n      sendMessage: sendMessage\n    };\n  };\n  var SUPPORTED_MESSAGE_ACTIONS = ['insertContent', 'setContent', 'execCommand', 'close', 'block', 'unblock'];\n  var isSupportedMessage = function isSupportedMessage(data) {\n    return isObject(data) && SUPPORTED_MESSAGE_ACTIONS.indexOf(data.mceAction) !== -1;\n  };\n  var isCustomMessage = function isCustomMessage(data) {\n    return !isSupportedMessage(data) && isObject(data) && has$2(data, 'mceAction');\n  };\n  var handleMessage = function handleMessage(editor, api, data) {\n    switch (data.mceAction) {\n      case 'insertContent':\n        editor.insertContent(data.content);\n        break;\n      case 'setContent':\n        editor.setContent(data.content);\n        break;\n      case 'execCommand':\n        var ui = isBoolean(data.ui) ? data.ui : false;\n        editor.execCommand(data.cmd, ui, data.value);\n        break;\n      case 'close':\n        api.close();\n        break;\n      case 'block':\n        api.block(data.message);\n        break;\n      case 'unblock':\n        api.unblock();\n        break;\n    }\n  };\n  var renderUrlDialog = function renderUrlDialog(internalDialog, extra, editor, backstage) {\n    var dialogId = generate$6('dialog');\n    var header = getHeader(internalDialog.title, dialogId, backstage);\n    var body = renderIframeBody(internalDialog);\n    var footer = internalDialog.buttons.bind(function (buttons) {\n      if (buttons.length === 0) {\n        return Optional.none();\n      } else {\n        return Optional.some(renderModalFooter({\n          buttons: buttons\n        }, dialogId, backstage));\n      }\n    });\n    var dialogEvents = initUrlDialog(function () {\n      return instanceApi;\n    }, getEventExtras(function () {\n      return dialog;\n    }, backstage.shared.providers, extra));\n    var styles = _objectSpread({}, internalDialog.height.fold(function () {\n      return {};\n    }, function (height) {\n      return {\n        'height': height + 'px',\n        'max-height': height + 'px'\n      };\n    }), internalDialog.width.fold(function () {\n      return {};\n    }, function (width) {\n      return {\n        'width': width + 'px',\n        'max-width': width + 'px'\n      };\n    }));\n    var classes = internalDialog.width.isNone() && internalDialog.height.isNone() ? ['tox-dialog--width-lg'] : [];\n    var iframeUri = new global(internalDialog.url, {\n      base_uri: new global(window.location.href)\n    });\n    var iframeDomain = \"\".concat(iframeUri.protocol, \"://\").concat(iframeUri.host).concat(iframeUri.port ? ':' + iframeUri.port : '');\n    var messageHandlerUnbinder = unbindable();\n    var updateState = function updateState(_comp, incoming) {\n      return Optional.some(incoming);\n    };\n    var extraBehaviours = [Reflecting.config({\n      channel: \"\".concat(dialogChannel, \"-\").concat(dialogId),\n      updateState: updateState,\n      initialData: internalDialog\n    }), config('messages', [runOnAttached(function () {\n      var unbind = bind(SugarElement.fromDom(window), 'message', function (e) {\n        if (iframeUri.isSameOrigin(new global(e.raw.origin))) {\n          var data = e.raw.data;\n          if (isSupportedMessage(data)) {\n            handleMessage(editor, instanceApi, data);\n          } else if (isCustomMessage(data)) {\n            internalDialog.onMessage(instanceApi, data);\n          }\n        }\n      });\n      messageHandlerUnbinder.set(unbind);\n    }), runOnDetached(messageHandlerUnbinder.clear)]), Receiving.config({\n      channels: _defineProperty({}, bodySendMessageChannel, {\n        onReceive: function onReceive(comp, data) {\n          descendant(comp.element, 'iframe').each(function (iframeEle) {\n            var iframeWin = iframeEle.dom.contentWindow;\n            if (isNonNullable(iframeWin)) {\n              iframeWin.postMessage(data, iframeDomain);\n            }\n          });\n        }\n      })\n    })];\n    var spec = {\n      id: dialogId,\n      header: header,\n      body: body,\n      footer: footer,\n      extraClasses: classes,\n      extraBehaviours: extraBehaviours,\n      extraStyles: styles\n    };\n    var dialog = renderModalDialog(spec, dialogEvents, backstage);\n    var instanceApi = getUrlDialogApi(dialog);\n    return {\n      dialog: dialog,\n      instanceApi: instanceApi\n    };\n  };\n  var setup$2 = function setup$2(backstage) {\n    var sharedBackstage = backstage.shared;\n    var open = function open(message, callback) {\n      var closeDialog = function closeDialog() {\n        ModalDialog.hide(alertDialog);\n        callback();\n      };\n      var memFooterClose = record(renderFooterButton({\n        name: 'close-alert',\n        text: 'OK',\n        primary: true,\n        buttonType: Optional.some('primary'),\n        align: 'end',\n        enabled: true,\n        icon: Optional.none()\n      }, 'cancel', backstage));\n      var titleSpec = pUntitled();\n      var closeSpec = pClose(closeDialog, sharedBackstage.providers);\n      var alertDialog = build$1(renderDialog$1({\n        lazySink: function lazySink() {\n          return sharedBackstage.getSink();\n        },\n        header: hiddenHeader(titleSpec, closeSpec),\n        body: pBodyMessage(message, sharedBackstage.providers),\n        footer: Optional.some(pFooter(pFooterGroup([], [memFooterClose.asSpec()]))),\n        onEscape: closeDialog,\n        extraClasses: ['tox-alert-dialog'],\n        extraBehaviours: [],\n        extraStyles: {},\n        dialogEvents: [run$1(formCancelEvent, closeDialog)],\n        eventOrder: {}\n      }));\n      ModalDialog.show(alertDialog);\n      var footerCloseButton = memFooterClose.get(alertDialog);\n      Focusing.focus(footerCloseButton);\n    };\n    return {\n      open: open\n    };\n  };\n  var setup$1 = function setup$1(backstage) {\n    var sharedBackstage = backstage.shared;\n    var open = function open(message, callback) {\n      var closeDialog = function closeDialog(state) {\n        ModalDialog.hide(confirmDialog);\n        callback(state);\n      };\n      var memFooterYes = record(renderFooterButton({\n        name: 'yes',\n        text: 'Yes',\n        primary: true,\n        buttonType: Optional.some('primary'),\n        align: 'end',\n        enabled: true,\n        icon: Optional.none()\n      }, 'submit', backstage));\n      var footerNo = renderFooterButton({\n        name: 'no',\n        text: 'No',\n        primary: false,\n        buttonType: Optional.some('secondary'),\n        align: 'end',\n        enabled: true,\n        icon: Optional.none()\n      }, 'cancel', backstage);\n      var titleSpec = pUntitled();\n      var closeSpec = pClose(function () {\n        return closeDialog(false);\n      }, sharedBackstage.providers);\n      var confirmDialog = build$1(renderDialog$1({\n        lazySink: function lazySink() {\n          return sharedBackstage.getSink();\n        },\n        header: hiddenHeader(titleSpec, closeSpec),\n        body: pBodyMessage(message, sharedBackstage.providers),\n        footer: Optional.some(pFooter(pFooterGroup([], [footerNo, memFooterYes.asSpec()]))),\n        onEscape: function onEscape() {\n          return closeDialog(false);\n        },\n        extraClasses: ['tox-confirm-dialog'],\n        extraBehaviours: [],\n        extraStyles: {},\n        dialogEvents: [run$1(formCancelEvent, function () {\n          return closeDialog(false);\n        }), run$1(formSubmitEvent, function () {\n          return closeDialog(true);\n        })],\n        eventOrder: {}\n      }));\n      ModalDialog.show(confirmDialog);\n      var footerYesButton = memFooterYes.get(confirmDialog);\n      Focusing.focus(footerYesButton);\n    };\n    return {\n      open: open\n    };\n  };\n  var validateData = function validateData(data, validator) {\n    return getOrDie(asRaw('data', validator, data));\n  };\n  var isAlertOrConfirmDialog = function isAlertOrConfirmDialog(target) {\n    return closest(target, '.tox-alert-dialog') || closest(target, '.tox-confirm-dialog');\n  };\n  var inlineAdditionalBehaviours = function inlineAdditionalBehaviours(editor, isStickyToolbar, isToolbarLocationTop) {\n    if (isStickyToolbar && isToolbarLocationTop) {\n      return [];\n    } else {\n      return [Docking.config({\n        contextual: {\n          lazyContext: function lazyContext() {\n            return Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer())));\n          },\n          fadeInClass: 'tox-dialog-dock-fadein',\n          fadeOutClass: 'tox-dialog-dock-fadeout',\n          transitionClass: 'tox-dialog-dock-transition'\n        },\n        modes: ['top'],\n        lazyViewport: function lazyViewport(comp) {\n          var optScrollingContext = detectWhenSplitUiMode(editor, comp.element);\n          return optScrollingContext.map(function (sc) {\n            var combinedBounds = getBoundsFrom(sc);\n            return {\n              bounds: combinedBounds,\n              optScrollEnv: Optional.some({\n                currentScrollTop: sc.element.dom.scrollTop,\n                scrollElmTop: absolute$3(sc.element).top\n              })\n            };\n          }).getOrThunk(function () {\n            return {\n              bounds: win(),\n              optScrollEnv: Optional.none()\n            };\n          });\n        }\n      })];\n    }\n  };\n  var setup = function setup(extras) {\n    var editor = extras.editor;\n    var isStickyToolbar$1 = isStickyToolbar(editor);\n    var alertDialog = setup$2(extras.backstages.dialog);\n    var confirmDialog = setup$1(extras.backstages.dialog);\n    var open = function open(config, params, closeWindow) {\n      if (!isUndefined(params)) {\n        if (params.inline === 'toolbar') {\n          return openInlineDialog(config, extras.backstages.popup.shared.anchors.inlineDialog(), closeWindow, params);\n        } else if (params.inline === 'bottom') {\n          return openBottomInlineDialog(config, extras.backstages.popup.shared.anchors.inlineBottomDialog(), closeWindow, params);\n        } else if (params.inline === 'cursor') {\n          return openInlineDialog(config, extras.backstages.popup.shared.anchors.cursor(), closeWindow, params);\n        }\n      }\n      return openModalDialog(config, closeWindow);\n    };\n    var openUrl = function openUrl(config, closeWindow) {\n      return openModalUrlDialog(config, closeWindow);\n    };\n    var openModalUrlDialog = function openModalUrlDialog(config, _closeWindow) {\n      var factory = function factory(contents) {\n        var dialog = renderUrlDialog(contents, {\n          closeWindow: function closeWindow() {\n            ModalDialog.hide(dialog.dialog);\n            _closeWindow(dialog.instanceApi);\n          }\n        }, editor, extras.backstages.dialog);\n        ModalDialog.show(dialog.dialog);\n        return dialog.instanceApi;\n      };\n      return DialogManager.openUrl(factory, config);\n    };\n    var openModalDialog = function openModalDialog(config, _closeWindow2) {\n      var factory = function factory(contents, internalInitialData, dataValidator) {\n        var initialData = internalInitialData;\n        var dialogInit = {\n          dataValidator: dataValidator,\n          initialData: initialData,\n          internalDialog: contents\n        };\n        var dialog = renderDialog(dialogInit, {\n          redial: DialogManager.redial,\n          closeWindow: function closeWindow() {\n            ModalDialog.hide(dialog.dialog);\n            _closeWindow2(dialog.instanceApi);\n          }\n        }, extras.backstages.dialog);\n        ModalDialog.show(dialog.dialog);\n        dialog.instanceApi.setData(initialData);\n        return dialog.instanceApi;\n      };\n      return DialogManager.open(factory, config);\n    };\n    var openInlineDialog = function openInlineDialog(config$1, anchor, _closeWindow3, windowParams) {\n      var factory = function factory(contents, internalInitialData, dataValidator) {\n        var initialData = validateData(internalInitialData, dataValidator);\n        var inlineDialog = value$2();\n        var isToolbarLocationTop = extras.backstages.popup.shared.header.isPositionedAtTop();\n        var dialogInit = {\n          dataValidator: dataValidator,\n          initialData: initialData,\n          internalDialog: contents\n        };\n        var refreshDocking = function refreshDocking() {\n          return inlineDialog.on(function (dialog) {\n            InlineView.reposition(dialog);\n            if (!isStickyToolbar$1 || !isToolbarLocationTop) {\n              Docking.refresh(dialog);\n            }\n          });\n        };\n        var dialogUi = renderInlineDialog(dialogInit, {\n          redial: DialogManager.redial,\n          closeWindow: function closeWindow() {\n            inlineDialog.on(InlineView.hide);\n            editor.off('ResizeEditor', refreshDocking);\n            inlineDialog.clear();\n            _closeWindow3(dialogUi.instanceApi);\n          }\n        }, extras.backstages.popup, windowParams.ariaAttrs, refreshDocking);\n        var inlineDialogComp = build$1(InlineView.sketch(_objectSpread({\n          lazySink: extras.backstages.popup.shared.getSink,\n          dom: {\n            tag: 'div',\n            classes: []\n          },\n          fireDismissalEventInstead: windowParams.persistent ? {\n            event: 'doNotDismissYet'\n          } : {}\n        }, isToolbarLocationTop ? {} : {\n          fireRepositionEventInstead: {}\n        }, {\n          inlineBehaviours: derive$1([config('window-manager-inline-events', [run$1(dismissRequested(), function (_comp, _se) {\n            emit(dialogUi.dialog, formCancelEvent);\n          })])].concat(_toConsumableArray(inlineAdditionalBehaviours(editor, isStickyToolbar$1, isToolbarLocationTop)))),\n          isExtraPart: function isExtraPart(_comp, target) {\n            return isAlertOrConfirmDialog(target);\n          }\n        })));\n        inlineDialog.set(inlineDialogComp);\n        var getInlineDialogBounds = function getInlineDialogBounds() {\n          var elem = editor.inline ? body() : SugarElement.fromDom(editor.getContainer());\n          var bounds = box$1(elem);\n          return Optional.some(bounds);\n        };\n        InlineView.showWithinBounds(inlineDialogComp, premade(dialogUi.dialog), {\n          anchor: anchor\n        }, getInlineDialogBounds);\n        if (!isStickyToolbar$1 || !isToolbarLocationTop) {\n          Docking.refresh(inlineDialogComp);\n          editor.on('ResizeEditor', refreshDocking);\n        }\n        dialogUi.instanceApi.setData(initialData);\n        Keying.focusIn(dialogUi.dialog);\n        return dialogUi.instanceApi;\n      };\n      return DialogManager.open(factory, config$1);\n    };\n    var openBottomInlineDialog = function openBottomInlineDialog(config$1, anchor, _closeWindow4, windowParams) {\n      var factory = function factory(contents, internalInitialData, dataValidator) {\n        var initialData = validateData(internalInitialData, dataValidator);\n        var inlineDialog = value$2();\n        var isToolbarLocationTop = extras.backstages.popup.shared.header.isPositionedAtTop();\n        var dialogInit = {\n          dataValidator: dataValidator,\n          initialData: initialData,\n          internalDialog: contents\n        };\n        var refreshDocking = function refreshDocking() {\n          return inlineDialog.on(function (dialog) {\n            InlineView.reposition(dialog);\n            Docking.refresh(dialog);\n          });\n        };\n        var dialogUi = renderInlineDialog(dialogInit, {\n          redial: DialogManager.redial,\n          closeWindow: function closeWindow() {\n            inlineDialog.on(InlineView.hide);\n            editor.off('ResizeEditor ScrollWindow ElementScroll', refreshDocking);\n            inlineDialog.clear();\n            _closeWindow4(dialogUi.instanceApi);\n          }\n        }, extras.backstages.popup, windowParams.ariaAttrs, refreshDocking);\n        var inlineDialogComp = build$1(InlineView.sketch(_objectSpread({\n          lazySink: extras.backstages.popup.shared.getSink,\n          dom: {\n            tag: 'div',\n            classes: []\n          },\n          fireDismissalEventInstead: windowParams.persistent ? {\n            event: 'doNotDismissYet'\n          } : {}\n        }, isToolbarLocationTop ? {} : {\n          fireRepositionEventInstead: {}\n        }, {\n          inlineBehaviours: derive$1([config('window-manager-inline-events', [run$1(dismissRequested(), function (_comp, _se) {\n            emit(dialogUi.dialog, formCancelEvent);\n          })]), Docking.config({\n            contextual: {\n              lazyContext: function lazyContext() {\n                return Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer())));\n              },\n              fadeInClass: 'tox-dialog-dock-fadein',\n              fadeOutClass: 'tox-dialog-dock-fadeout',\n              transitionClass: 'tox-dialog-dock-transition'\n            },\n            modes: ['top', 'bottom'],\n            lazyViewport: function lazyViewport(comp) {\n              var optScrollingContext = detectWhenSplitUiMode(editor, comp.element);\n              return optScrollingContext.map(function (sc) {\n                var combinedBounds = getBoundsFrom(sc);\n                return {\n                  bounds: combinedBounds,\n                  optScrollEnv: Optional.some({\n                    currentScrollTop: sc.element.dom.scrollTop,\n                    scrollElmTop: absolute$3(sc.element).top\n                  })\n                };\n              }).getOrThunk(function () {\n                return {\n                  bounds: win(),\n                  optScrollEnv: Optional.none()\n                };\n              });\n            }\n          })]),\n          isExtraPart: function isExtraPart(_comp, target) {\n            return isAlertOrConfirmDialog(target);\n          }\n        })));\n        inlineDialog.set(inlineDialogComp);\n        var getInlineDialogBounds = function getInlineDialogBounds() {\n          return extras.backstages.popup.shared.getSink().toOptional().bind(function (s) {\n            var optScrollingContext = detectWhenSplitUiMode(editor, s.element);\n            var margin = 15;\n            var bounds$1 = optScrollingContext.map(function (sc) {\n              return getBoundsFrom(sc);\n            }).getOr(win());\n            var contentAreaContainer = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));\n            var constrainedBounds = constrain(contentAreaContainer, bounds$1);\n            return Optional.some(bounds(constrainedBounds.x, constrainedBounds.y, constrainedBounds.width, constrainedBounds.height - margin));\n          });\n        };\n        InlineView.showWithinBounds(inlineDialogComp, premade(dialogUi.dialog), {\n          anchor: anchor\n        }, getInlineDialogBounds);\n        Docking.refresh(inlineDialogComp);\n        editor.on('ResizeEditor ScrollWindow ElementScroll ResizeWindow', refreshDocking);\n        dialogUi.instanceApi.setData(initialData);\n        Keying.focusIn(dialogUi.dialog);\n        return dialogUi.instanceApi;\n      };\n      return DialogManager.open(factory, config$1);\n    };\n    var confirm = function confirm(message, callback) {\n      confirmDialog.open(message, callback);\n    };\n    var alert = function alert(message, callback) {\n      alertDialog.open(message, callback);\n    };\n    var close = function close(instanceApi) {\n      instanceApi.close();\n    };\n    return {\n      open: open,\n      openUrl: openUrl,\n      alert: alert,\n      close: close,\n      confirm: confirm\n    };\n  };\n  var registerOptions = function registerOptions(editor) {\n    register$e(editor);\n    register$d(editor);\n    register(editor);\n  };\n  var Theme = function Theme() {\n    global$a.add('silver', function (editor) {\n      registerOptions(editor);\n      var popupSinkBounds = function popupSinkBounds() {\n        return win();\n      };\n      var _setup$ = setup$3(editor, {\n          getPopupSinkBounds: function getPopupSinkBounds() {\n            return popupSinkBounds();\n          }\n        }),\n        dialogs = _setup$.dialogs,\n        popups = _setup$.popups,\n        renderModeUI = _setup$.renderUI;\n      var renderUI = function renderUI() {\n        var renderResult = renderModeUI();\n        var optScrollingContext = detectWhenSplitUiMode(editor, popups.getMothership().element);\n        optScrollingContext.each(function (sc) {\n          popupSinkBounds = function popupSinkBounds() {\n            return getBoundsFrom(sc);\n          };\n        });\n        return renderResult;\n      };\n      Autocompleter.register(editor, popups.backstage.shared);\n      var windowMgr = setup({\n        editor: editor,\n        backstages: {\n          popup: popups.backstage,\n          dialog: dialogs.backstage\n        }\n      });\n      var getNotificationManagerImpl = function getNotificationManagerImpl() {\n        return NotificationManagerImpl(editor, {\n          backstage: popups.backstage\n        }, popups.getMothership());\n      };\n      return {\n        renderUI: renderUI,\n        getWindowManagerImpl: constant$1(windowMgr),\n        getNotificationManagerImpl: getNotificationManagerImpl\n      };\n    });\n  };\n  Theme();\n})();","map":null,"metadata":{},"sourceType":"script"}